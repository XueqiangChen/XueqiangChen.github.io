<!doctype html><html lang=en><meta charset=utf-8>
<meta name=viewport content="width=device-width">
<title>Java 多线程 - 初识 Synchronized | AhaMoment</title>
<meta name=generator content="Hugo Eureka 0.8.3">
<link rel=stylesheet href=https://ahamoment.cn/css/eureka.min.css>
<script defer src=https://ahamoment.cn/js/eureka.min.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload="this.onload=null,this.rel='stylesheet'">
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js integrity="sha256-uNYoXefWRqv+PsIF/OflNmwtKM4lStn9yrz2gVl6ymo=" crossorigin></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js integrity="sha256-Zmpaaj+GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE=" crossorigin></script>
<link rel=preconnect href=https://www.google-analytics.com crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-80D5T229MJ"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-80D5T229MJ')</script>
<style type=text/css>.widget+.widget{margin-top:1rem}.widget-title{font-weight:700;margin-bottom:1rem}.widget-list li{font-size:.9rem}.bg-cover img{opacity:1;transition:all .5s ease-in-out}.bg-cover img.dark{opacity:0;height:0}.dark .bg-cover img.day{opacity:0;height:0}.dark .bg-cover img.dark{opacity:1;height:auto}.search-container{margin-top:-.3rem;margin-right:1rem}.search-container .search{border:1px solid #e2e8f0;border-radius:4px}.search-container input{padding-left:1rem;line-height:2rem;outline:none;background:0 0}.search-container button{font-size:.8rem;margin-right:.5rem;color:#e2e8f0}</style>
<link rel=icon type=image/png sizes=32x32 href=https://ahamoment.cn/images/icon_hudefd788b34d9017ea35c49e86618f3e1_134481_32x32_fill_box_center_3.png>
<link rel=apple-touch-icon sizes=180x180 href=https://ahamoment.cn/images/icon_hudefd788b34d9017ea35c49e86618f3e1_134481_180x180_fill_box_center_3.png>
<meta name=description content="Synchronized 简介  本文出自汪文君老师的《Java 并发编程》课程，如需转载，请注明源出处！
 先来看一个例子，这个例子是模拟银行叫号的，使用三个线程模拟三个柜台一起叫号，总共50个号。在不加 synchronized 的关键字的情况下，很容易就会出现并发问题。
public class BankRunnable { public static void main(String[] args) { // 一个runnable实例被多个线程共享 TicketWindowRunnable ticketWindow = new TicketWindowRunnable(); Thread windowThread1 = new Thread(ticketWindow, &#34;一号窗口&#34;); Thread windowThread2 = new Thread(ticketWindow, &#34;二号窗口&#34;); Thread windowThread3 = new Thread(ticketWindow, &#34;三号窗口&#34;); windowThread1.start(); windowThread2.start(); windowThread3.start(); } } public class TicketWindowRunnable implements Runnable { private int index = 1; private static final int MAX = 50; @Override public void run() { while (true) { if (index > MAX) {//1 break; } try { Thread.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ahamoment.cn/posts/"},{"@type":"ListItem","position":2,"name":"Java 多线程 - 初识 Synchronized","item":"https://ahamoment.cn/posts/java/java-multithread-synchronized/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ahamoment.cn/posts/java/java-multithread-synchronized/"},"headline":"Java 多线程 - 初识 Synchronized | AhaMoment","datePublished":"2020-06-10T19:16:24+08:00","dateModified":"2020-06-10T19:16:24+08:00","wordCount":607,"publisher":{"@type":"Person","name":"Chenxueqiang","logo":{"@type":"ImageObject","url":"https://ahamoment.cn/images/icon.png"}},"description":"Synchronized 简介  本文出自汪文君老师的《Java 并发编程》课程，如需转载，请注明源出处！\n 先来看一个例子，这个例子是模拟银行叫号的，使用三个线程模拟三个柜台一起叫号，总共50个号。在不加 synchronized 的关键字的情况下，很容易就会出现并发问题。\npublic class BankRunnable { public static void main(String[] args) { \/\/ 一个runnable实例被多个线程共享 TicketWindowRunnable ticketWindow = new TicketWindowRunnable(); Thread windowThread1 = new Thread(ticketWindow, \u0026quot;一号窗口\u0026quot;); Thread windowThread2 = new Thread(ticketWindow, \u0026quot;二号窗口\u0026quot;); Thread windowThread3 = new Thread(ticketWindow, \u0026quot;三号窗口\u0026quot;); windowThread1.start(); windowThread2.start(); windowThread3.start(); } } public class TicketWindowRunnable implements Runnable { private int index = 1; private static final int MAX = 50; @Override public void run() { while (true) { if (index \u0026gt; MAX) {\/\/1 break; } try { Thread."}</script><meta property="og:title" content="Java 多线程 - 初识 Synchronized | AhaMoment">
<meta property="og:type" content="article">
<meta property="og:image" content="https://ahamoment.cn/images/icon.png">
<meta property="og:url" content="https://ahamoment.cn/posts/java/java-multithread-synchronized/">
<meta property="og:description" content="Synchronized 简介  本文出自汪文君老师的《Java 并发编程》课程，如需转载，请注明源出处！
 先来看一个例子，这个例子是模拟银行叫号的，使用三个线程模拟三个柜台一起叫号，总共50个号。在不加 synchronized 的关键字的情况下，很容易就会出现并发问题。
public class BankRunnable { public static void main(String[] args) { // 一个runnable实例被多个线程共享 TicketWindowRunnable ticketWindow = new TicketWindowRunnable(); Thread windowThread1 = new Thread(ticketWindow, &#34;一号窗口&#34;); Thread windowThread2 = new Thread(ticketWindow, &#34;二号窗口&#34;); Thread windowThread3 = new Thread(ticketWindow, &#34;三号窗口&#34;); windowThread1.start(); windowThread2.start(); windowThread3.start(); } } public class TicketWindowRunnable implements Runnable { private int index = 1; private static final int MAX = 50; @Override public void run() { while (true) { if (index > MAX) {//1 break; } try { Thread.">
<meta property="og:locale" content="en">
<meta property="og:site_name" content="AhaMoment">
<meta property="article:published_time" content="2020-06-10T19:16:24+08:00">
<meta property="article:modified_time" content="2020-06-10T19:16:24+08:00">
<meta property="article:section" content="posts">
<meta property="article:tag" content="多线程">
<body class="flex flex-col min-h-screen">
<header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
<div class="w-full max-w-screen-xl mx-auto"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=='Auto'||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName('html')[0].classList.add('dark')</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
<a href=/ class="mr-6 text-primary-text text-xl font-bold">AhaMoment</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i>
</button>
<div id=target class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
<div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
<a href=/docs/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent mr-4">文档</a>
<a href=/archive/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent mr-4">归档</a>
<a href=/authors/chenxq/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent mr-4">关于我</a>
</div>
<div class=flex>
<div class="search-container relative pt-4 md:pt-0">
<div class=search>
<form role=search class=search-form action=/search/index.html method=get>
<label>
<input name=q type=text placeholder="搜索 ..." class=search-field>
</label>
<button>
<i class="fas fa-search"></i>
</button>
</form>
</div>
</div>
<div class="relative pt-4 md:pt-0">
<div class="cursor-pointer hover:text-eureka" id=lightDarkMode>
<i class="fas fa-adjust"></i>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open>
</div>
<div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions>
<span class="px-4 py-1 hover:text-eureka" name=Light>Light</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>Dark</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>Auto</span>
</div>
</div>
</div>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile>
</div>
</nav>
<script>let element=document.getElementById('lightDarkMode');storageColorScheme==null||storageColorScheme=='Auto'?document.addEventListener('DOMContentLoaded',()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change',switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'sun'),element.firstElementChild.classList.add('fa-sun')):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'moon'),element.firstElementChild.classList.add('fa-moon')),document.addEventListener('DOMContentLoaded',()=>{getcolorscheme(),switchBurger()})</script>
</div>
</header>
<main class="flex-grow pt-16">
<div class=pl-scrollbar>
<div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">
<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
<div class="col-span-2 lg:col-start-2 lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
<h1 class="font-bold text-3xl text-primary-text">Java 多线程 - 初识 Synchronized</h1>
<div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
<div class="mr-6 my-2">
<i class="fas fa-calendar mr-1"></i>
<span>2020-06-10</span>
</div>
<div class="mr-6 my-2">
<i class="fas fa-clock mr-1"></i>
<span>3 min read</span>
</div>
<div class="mr-6 my-2">
<i class="fas fa-folder mr-1"></i>
<a href=https://ahamoment.cn/categories/java/ class=hover:text-eureka>java</a>
</div>
</div>
<div class=content>
<h2 id=synchronized-简介>Synchronized 简介</h2>
<blockquote>
<p>本文出自汪文君老师的《Java 并发编程》课程，如需转载，请注明源出处！</p>
</blockquote>
<p>先来看一个例子，这个例子是模拟银行叫号的，使用三个线程模拟三个柜台一起叫号，总共50个号。在不加 synchronized 的关键字的情况下，很容易就会出现并发问题。</p>
<pre><code class=language-java>public class BankRunnable {
    public static void main(String[] args) {
        // 一个runnable实例被多个线程共享
        TicketWindowRunnable ticketWindow = new TicketWindowRunnable();

        Thread windowThread1 = new Thread(ticketWindow, &quot;一号窗口&quot;);
        Thread windowThread2 = new Thread(ticketWindow, &quot;二号窗口&quot;);
        Thread windowThread3 = new Thread(ticketWindow, &quot;三号窗口&quot;);
        windowThread1.start();
        windowThread2.start();
        windowThread3.start();
    }
}

public class TicketWindowRunnable implements Runnable {
    private int index = 1;
    private static final int MAX = 50;

    @Override
    public void run() {
        while (true) {
            if (index &gt; MAX) {//1
                break;
            }
            try {
                Thread.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName()+&quot; 的号码是：&quot;+(index++));//2
        }
    }
}
</code></pre>
<p>多运行几遍程序，就会出现下面这个问题：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3Fha2dsNmVueC5ia3QuY2xvdWRkbi5jb20vcGljZ28vaW1hZ2UtMjAyMDA2MDMxOTIyMjA1MTcucG5n?x-oss-process=image/format,png" alt=image-20200603192220517></p>
<p>在一号窗口拿完最后一个号码之后，二号窗口和三号窗口又后续拿到了 52 和 51 号。为什么会出现这种现象呢？</p>
<p>首先当 <code>index=499</code> 的时候，三个线程均不满足 <code>index > MAX</code>，都会向下执行。三个线程都可以向下执行，将 index 加 1。</p>
<p>为了解决这个问题，这里引入了 synchronized 。</p>
<h2 id=什么是-synchronized>什么是 synchronized</h2>
<blockquote>
<p>synchronized关键字可以实现一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象对多个线程是可见的，那么对该对象的所有读或者写都将通过同步的方式来进行。</p>
</blockquote>
<p>上面这段话是oracle官网对synchronized关键字的解释，具体表现如下：</p>
<ul>
<li>synchronized关键字提供了一种锁的机制，能够确保共享变量的互斥访问，从而防止数据不一致问题的出现。</li>
<li>synchronized关键字包括monitor enter和monitor exit两个JVM指令，它能够保证在任何时候任何线程执行到monitor enter成功之前都必须从主内存中获取数据，而不是从缓存中，在monitor exit运行成功之后，共享变量被更新后的值必须刷入主内存（在本书的第三部分会重点介绍）。</li>
<li>synchronized的指令严格遵守java happens-before规则，一个monitor exit指令之前必定要有一个monitor enter。</li>
</ul>
<h2 id=synchronized关键字的用法>synchronized关键字的用法</h2>
<p>Java通过 synchronized 对共享数据的线程访问提供了一种避免竞争条件的机制。synchronized 可以修饰方法或者代码块，被修饰的方法或者代码块同一时间只会允许一个线程执行，这条执行的线程持有同步部分的锁。synchronized 方法不能用于对class及其变量进行修饰。</p>
<p>synchronized 关键字可以修饰方法或者代码块，那么这两者有什么区别呢？</p>
<pre><code class=language-java>// 同步代码块
public class TicketWindowRunnable implements Runnable {
    private int index = 1;
    private static final int MAX = 500;

    private final Object MONITOR = new Object();

    @Override
    public void run() {
        while (true) {
            synchronized (MONITOR) {
                if (index &gt; MAX) {
                    break;
                }
                try {
                    Thread.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));
            }
        }
    }
}
</code></pre>
<p>synchronized 方法修饰代码块的时候，使用的是 monitor 锁。再来用 synchronized 修饰一下同步方法：</p>
<pre><code class=language-java>@Override
public synchronized void run() {
    while (true) {
        if (index &gt; MAX) {
            break;
        }
        try {
            Thread.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));
    }
}
</code></pre>
<p>运行之后发现都是同一个线程在跑，另外两个线程无法执行。这是因为 synchronized 在修饰方法的时候使用的是 this 锁，当其中一个线程拿到锁进到 while 循环之后，就一直去做事情，直到满足条件退出为止。将 while 里面的代码抽出来放到一个方法里，用 synchronized 来修饰该方法就可以解决这个问题。</p>
<pre><code class=language-java>@Override
public void run() {
    while (true) {
        if (ticket()) {
            break;
        }
    }
}

private synchronized boolean ticket() {
    if (index &gt; MAX) {
        return true;
    }
    try {
        Thread.sleep(5);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));
    return false;
}
</code></pre>
<p>synchronized 修饰方法时默认是使用的 this 锁，修饰代码块时使用的是对象锁。synchronized 关键字还可以用来修饰静态方法和静态代码块。</p>
<pre><code class=language-java>public class SynchronizedStatic {

    public synchronized static void m1() {
        System.out.println(&quot;m1 &quot; + Thread.currentThread().getName());
        try {
            Thread.sleep(10_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public synchronized static void m2() {
        System.out.println(&quot;m2 &quot; + Thread.currentThread().getName());
        try {
            Thread.sleep(10_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class SynchronizedStaticTest {
    public static void main(String[] args) {
        new Thread(&quot;T1&quot;) {
            @Override
            public void run() {
                SynchronizedStatic.m1();
            }
        }.start();

        new Thread(&quot;T2&quot;) {
            @Override
            public void run() {
                SynchronizedStatic.m2();
            }
        }.start();
    }
}

// output
m1 T1
m2 T2
</code></pre>
<p>静态方法 m1 和 m2 同时被 synchronized 修饰，这个时候线程 T2 会等到线程 T1 执行完再执行，说明这两个方法使用的是同一把锁，这就是 Class 锁。我们把 sleep 的时间变长一点来观察一下是不是 Class 锁。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3Fha2dsNmVueC5ia3QuY2xvdWRkbi5jb20vcGljZ28vaW1hZ2UtMjAyMDA2MDkxOTE1NTc0NTUucG5n?x-oss-process=image/format,png" alt=image-20200609191557455></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3Fha2dsNmVueC5ia3QuY2xvdWRkbi5jb20vcGljZ28vaW1hZ2UtMjAyMDA2MDkxOTE2Mjk4NjcucG5n?x-oss-process=image/format,png" alt=image-20200609191629867></p>
<p>可以看到，线程 T1 执行的时候，持有的是 Class 锁，此时线程 T2 在等待 T1 执行完释放锁，当 T1 执行完之后，T2 拿到 Class 锁执行代码。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3Fha2dsNmVueC5ia3QuY2xvdWRkbi5jb20vcGljZ28vaW1hZ2UtMjAyMDA2MDkxOTE4MTIwODYucG5n?x-oss-process=image/format,png" alt=image-20200609191812086></p>
<p>了解了 synchronized 修饰静态方法使用的是 Class 锁之后，我们再来验证一下当它修饰静态方法的时候是不是也是使用 Class 锁？</p>
<pre><code class=language-java>public class SynchronizedStatic {
    public synchronized static void m1() {
        System.out.println(&quot;m1 &quot; + Thread.currentThread().getName());
        try {
            Thread.sleep(100_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    public static void m3() {
        System.out.println(&quot;m3 &quot; + Thread.currentThread().getName());
        try {
            Thread.sleep(10_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class SynchronizedStaticTest {
    public static void main(String[] args) {
        new Thread(&quot;T1&quot;) {
            @Override
            public void run() {
                SynchronizedStatic.m1();
            }
        }.start();

        new Thread(&quot;T3&quot;) {
            @Override
            public void run() {
                SynchronizedStatic.m3();
            }
        }.start();
    }
}
</code></pre>
<p>这里加了一个没有 synchronized 修饰的静态方法 m3，运行之后很容易知道，这两个线程是同时运行的。我们在 SynchronizedStatic 开始的地方加一个静态代码块，静态代码块内部使用 synchronized 锁。</p>
<pre><code class=language-java>public class SynchronizedStatic {
    static {
        synchronized (SynchronizedStatic.class) {
            System.out.println(&quot;static &quot; + Thread.currentThread().getName());
            try {
                Thread.sleep(10_000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public synchronized static void m1() {
        System.out.println(&quot;m1 &quot; + Thread.currentThread().getName());
        try {
            Thread.sleep(100_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void m3() {
        System.out.println(&quot;m3 &quot; + Thread.currentThread().getName());
        try {
            Thread.sleep(10_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

//output
static T1
m1 T1
m3 T3
</code></pre>
<p>可以发现，T1 线程要先执行静态代码块才能往下走，说明静态代码块使用的锁和静态方法是一样的，另外这个时候没有用 synchronized 修饰的 m3 也要等静态代码块执行实例化才行。</p>
<p>总结一下，synchronized 关键字能够避免多线程竞争导致的数据不一致，被 synchronized 修饰的方法或者代码块同一时间只会允许一个线程执行，这条执行的线程持有同步部分的锁。synchronized 关键字修饰普通方法时，使用的是 this 锁，修饰静态方法和静态代码块时，使用 Class 锁，修饰代码块时，使用 LOCK 锁。</p>
</div>
<div class=my-4>
<a href=https://ahamoment.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#多线程</a>
</div>
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
<div>
<span class="block font-bold">Previous</span>
<a href=https://ahamoment.cn/posts/java/java-multithread-dead-lock/ class=block>Java 多线程 - 死锁问题</a>
</div>
<div class="md:text-right mt-4 md:mt-0">
<span class="block font-bold">Next</span>
<a href=https://ahamoment.cn/posts/linux/linux-20-rpm-command/ class=block>20 常用的 RPM 命令</a>
</div>
</div>
</div>
</div>
<script>document.addEventListener('DOMContentLoaded',()=>{hljs.initHighlightingOnLoad()})</script>
</div>
</div>
</main>
<footer class=pl-scrollbar>
<div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
<p class="text-sm text-tertiary-text">&copy; 2021
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p>
</div></div>
</footer>
</body>
</html>