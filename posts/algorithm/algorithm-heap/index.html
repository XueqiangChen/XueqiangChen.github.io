<!doctype html><html lang=en><meta charset=utf-8>
<meta name=viewport content="width=device-width">
<title>堆 | AhaMoment</title>
<meta name=generator content="Hugo Eureka 0.8.3-dev">
<link rel=stylesheet href=https://ahamoment.cn/css/eureka.min.css>
<script defer src=https://ahamoment.cn/js/eureka.min.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload="this.onload=null,this.rel='stylesheet'">
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js integrity="sha256-uNYoXefWRqv+PsIF/OflNmwtKM4lStn9yrz2gVl6ymo=" crossorigin></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js integrity="sha256-Zmpaaj+GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE=" crossorigin></script>
<link rel=preconnect href=https://www.google-analytics.com crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-80D5T229MJ"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-80D5T229MJ')</script>
<style type=text/css>.widget+.widget{margin-top:1rem}.widget-title{font-weight:700;margin-bottom:1rem}.widget-list li{font-size:.9rem}.bg-cover img{opacity:1;transition:all .5s ease-in-out}.bg-cover img.dark{opacity:0;height:0}.dark .bg-cover img.day{opacity:0;height:0}.dark .bg-cover img.dark{opacity:1;height:auto}.search-container{margin-top:-.3rem;margin-right:1rem}.search-container .search{border:1px solid #e2e8f0;border-radius:4px}.search-container input{padding-left:1rem;line-height:2rem;outline:none;background:0 0}.search-container button{font-size:.8rem;margin-right:.5rem;color:#e2e8f0}</style>
<link rel=icon type=image/png sizes=32x32 href=https://ahamoment.cn/images/icon_hudefd788b34d9017ea35c49e86618f3e1_134481_32x32_fill_box_center_3.png>
<link rel=apple-touch-icon sizes=180x180 href=https://ahamoment.cn/images/icon_hudefd788b34d9017ea35c49e86618f3e1_134481_180x180_fill_box_center_3.png>
<meta name=description content="什么是堆 了解什么是堆之前，我们知道队列的概念，队列的特点是先进先出，但是有一种特殊的队列，取出元素的顺序是按照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序，这就是优先队列(Priority Queue)。
若采用数组或者链表实现优先队列，总会有插入、删除或者查找中的一项操作的复杂度是$O(N)$ 的。
若采用二叉搜索树实现，那么插入和删除都跟树的高度有关，也就是$O(log_2N)$ 的复杂度，但是删除的时候，由于每次都要删除最大的或者最小的，这样操作几次后，会造成搜索树失去平衡，所以不能简单的使用二叉搜索树。
如果采用二叉树结构，我们更关注的应该是删除的操作，那么我们把最大的值放到根结点，左右两边也是最大值作为左右子树的根结点，每次删除只需要删除根结点。同时，为了保证树的平衡性，可以考虑使用完全二叉树来实现优先队列。
优先队列使用完全二叉树表示如上图所示，数组的第 0 个元素空着，后面的按照层序遍历的顺序存放到数组中。使用完全二叉实现的优先队列，也可以称之为堆，堆的特性如下：
 结构性：用数组表示的完全二叉树。 有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）  &ldquo;最大堆&rdquo;，也称 &ldquo;大顶堆&rdquo;：堆顶元素是整个树的最大值 &ldquo;最小堆&rdquo;，也称&#34;小顶堆&#34;：堆顶元素是整个树的最小值    如下图所示的几个二叉树，不是堆。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ahamoment.cn/posts/"},{"@type":"ListItem","position":2,"name":"堆","item":"https://ahamoment.cn/posts/algorithm/algorithm-heap/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://ahamoment.cn/posts/algorithm/algorithm-heap/"},"headline":"堆 | AhaMoment","datePublished":"2020-09-15T11:44:06+08:00","dateModified":"2020-09-15T11:44:06+08:00","wordCount":653,"publisher":{"@type":"Person","name":"Chenxueqiang","logo":{"@type":"ImageObject","url":"https://ahamoment.cn/images/icon.png"}},"description":"什么是堆 了解什么是堆之前，我们知道队列的概念，队列的特点是先进先出，但是有一种特殊的队列，取出元素的顺序是按照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序，这就是优先队列(Priority Queue)。\n若采用数组或者链表实现优先队列，总会有插入、删除或者查找中的一项操作的复杂度是$O(N)$ 的。\n若采用二叉搜索树实现，那么插入和删除都跟树的高度有关，也就是$O(log_2N)$ 的复杂度，但是删除的时候，由于每次都要删除最大的或者最小的，这样操作几次后，会造成搜索树失去平衡，所以不能简单的使用二叉搜索树。\n如果采用二叉树结构，我们更关注的应该是删除的操作，那么我们把最大的值放到根结点，左右两边也是最大值作为左右子树的根结点，每次删除只需要删除根结点。同时，为了保证树的平衡性，可以考虑使用完全二叉树来实现优先队列。\n优先队列使用完全二叉树表示如上图所示，数组的第 0 个元素空着，后面的按照层序遍历的顺序存放到数组中。使用完全二叉实现的优先队列，也可以称之为堆，堆的特性如下：\n 结构性：用数组表示的完全二叉树。 有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）  \u0026ldquo;最大堆\u0026rdquo;，也称 \u0026ldquo;大顶堆\u0026rdquo;：堆顶元素是整个树的最大值 \u0026ldquo;最小堆\u0026rdquo;，也称\u0026quot;小顶堆\u0026quot;：堆顶元素是整个树的最小值    如下图所示的几个二叉树，不是堆。"}</script><meta property="og:title" content="堆 | AhaMoment">
<meta property="og:type" content="article">
<meta property="og:image" content="https://ahamoment.cn/images/icon.png">
<meta property="og:url" content="https://ahamoment.cn/posts/algorithm/algorithm-heap/">
<meta property="og:description" content="什么是堆 了解什么是堆之前，我们知道队列的概念，队列的特点是先进先出，但是有一种特殊的队列，取出元素的顺序是按照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序，这就是优先队列(Priority Queue)。
若采用数组或者链表实现优先队列，总会有插入、删除或者查找中的一项操作的复杂度是$O(N)$ 的。
若采用二叉搜索树实现，那么插入和删除都跟树的高度有关，也就是$O(log_2N)$ 的复杂度，但是删除的时候，由于每次都要删除最大的或者最小的，这样操作几次后，会造成搜索树失去平衡，所以不能简单的使用二叉搜索树。
如果采用二叉树结构，我们更关注的应该是删除的操作，那么我们把最大的值放到根结点，左右两边也是最大值作为左右子树的根结点，每次删除只需要删除根结点。同时，为了保证树的平衡性，可以考虑使用完全二叉树来实现优先队列。
优先队列使用完全二叉树表示如上图所示，数组的第 0 个元素空着，后面的按照层序遍历的顺序存放到数组中。使用完全二叉实现的优先队列，也可以称之为堆，堆的特性如下：
 结构性：用数组表示的完全二叉树。 有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）  &ldquo;最大堆&rdquo;，也称 &ldquo;大顶堆&rdquo;：堆顶元素是整个树的最大值 &ldquo;最小堆&rdquo;，也称&#34;小顶堆&#34;：堆顶元素是整个树的最小值    如下图所示的几个二叉树，不是堆。">
<meta property="og:locale" content="en">
<meta property="og:site_name" content="AhaMoment">
<meta property="article:published_time" content="2020-09-15T11:44:06+08:00">
<meta property="article:modified_time" content="2020-09-15T11:44:06+08:00">
<meta property="article:section" content="posts">
<meta property="article:tag" content="树">
<meta property="article:tag" content="堆">
<meta property="og:see_also" content="https://ahamoment.cn/posts/algorithm/algorithm-balanced-binary-tree/">
<meta property="og:see_also" content="https://ahamoment.cn/posts/algorithm/algorithm-binary-search-tree/">
<meta property="og:see_also" content="https://ahamoment.cn/posts/algorithm/algorithm-binary-tree/">
<meta property="og:see_also" content="https://ahamoment.cn/posts/algorithm/algorithm-tree/">
<body class="flex flex-col min-h-screen">
<header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
<div class="w-full max-w-screen-xl mx-auto"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=='Auto'||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName('html')[0].classList.add('dark')</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
<a href=/ class="mr-6 text-primary-text text-xl font-bold">AhaMoment</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i>
</button>
<div id=target class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
<div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
<a href=/docs/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent mr-4">文档</a>
<a href=/archive/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent mr-4">归档</a>
<a href=/authors/chenxq/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent mr-4">关于我</a>
</div>
<div class=flex>
<div class="search-container relative pt-4 md:pt-0">
<div class=search>
<form role=search class=search-form action=/search/index.html method=get>
<label>
<input name=q type=text placeholder="搜索 ..." class=search-field>
</label>
<button>
<i class="fas fa-search"></i>
</button>
</form>
</div>
</div>
<div class="relative pt-4 md:pt-0">
<div class="cursor-pointer hover:text-eureka" id=lightDarkMode>
<i class="fas fa-adjust"></i>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open>
</div>
<div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions>
<span class="px-4 py-1 hover:text-eureka" name=Light>Light</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>Dark</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>Auto</span>
</div>
</div>
</div>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile>
</div>
</nav>
<script>let element=document.getElementById('lightDarkMode');storageColorScheme==null||storageColorScheme=='Auto'?document.addEventListener('DOMContentLoaded',()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change',switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'sun'),element.firstElementChild.classList.add('fa-sun')):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'moon'),element.firstElementChild.classList.add('fa-moon')),document.addEventListener('DOMContentLoaded',()=>{getcolorscheme(),switchBurger()})</script>
</div>
</header>
<main class="flex-grow pt-16">
<div class=pl-scrollbar>
<div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">
<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
<div class="col-span-2 lg:col-start-2 lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
<h1 class="font-bold text-3xl text-primary-text">堆</h1>
<div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
<div class="mr-6 my-2">
<i class="fas fa-calendar mr-1"></i>
<span>2020-09-15</span>
</div>
<div class="mr-6 my-2">
<i class="fas fa-clock mr-1"></i>
<span>4 min read</span>
</div>
<div class="mr-6 my-2">
<i class="fas fa-folder mr-1"></i>
<a href=https://ahamoment.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ class=hover:text-eureka>数据结构与算法</a>
</div>
</div>
<div class=content>
<h2 id=什么是堆>什么是堆</h2>
<p>了解什么是堆之前，我们知道队列的概念，队列的特点是先进先出，但是有一种特殊的队列，取出元素的顺序是按照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序，这就是优先队列(Priority Queue)。</p>
<p>若采用数组或者链表实现优先队列，总会有插入、删除或者查找中的一项操作的复杂度是$O(N)$ 的。</p>
<p>若采用二叉搜索树实现，那么插入和删除都跟树的高度有关，也就是$O(log_2N)$ 的复杂度，但是删除的时候，由于每次都要删除最大的或者最小的，这样操作几次后，会造成搜索树失去平衡，所以不能简单的使用二叉搜索树。</p>
<p>如果采用二叉树结构，我们更关注的应该是删除的操作，那么我们把最大的值放到根结点，左右两边也是最大值作为左右子树的根结点，每次删除只需要删除根结点。同时，为了保证树的平衡性，可以考虑使用完全二叉树来实现优先队列。</p>
<p><img src=https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917105413123.png alt=image-20200917105413123></p>
<p>优先队列使用完全二叉树表示如上图所示，数组的第 0 个元素空着，后面的按照层序遍历的顺序存放到数组中。使用完全二叉实现的优先队列，也可以称之为堆，堆的特性如下：</p>
<ul>
<li>结构性：用数组表示的完全二叉树。</li>
<li>有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）
<ul>
<li>&ldquo;最大堆&rdquo;，也称 &ldquo;大顶堆&rdquo;：堆顶元素是整个树的最大值</li>
<li>&ldquo;最小堆&rdquo;，也称"小顶堆"：堆顶元素是整个树的最小值</li>
</ul>
</li>
</ul>
<p>如下图所示的几个二叉树，不是堆。</p>
<p><img src=https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917111328827.png alt=image-20200917111328827></p>
<p>第一和第二棵二叉树虽然满足有序性，但是不是完全二叉树。第三和第四棵二叉树是完全二叉树，但是不满足有序性的特点。</p>
<blockquote>
<p>注意：堆从根结点到任意结点路径上的结点顺序都是有序的！</p>
</blockquote>
<h2 id=最大堆的创建>最大堆的创建</h2>
<p>堆的数据结构包括存储完全二叉树的数组 data，堆中当前元素个数 size，堆的最大容量 capacity。</p>
<p>数组的元素从1开始，0的位置定义为哨兵，方便以后更快操作。</p>
<pre><code class=language-java>public abstract class Heap {
    // 堆的类型定义
    protected int[] data; //存储元素的数组
    protected int size;//堆中当前元素个数
    protected int capacity; //堆的最大容量

    public Heap() {
        this.size = 0;
        this.capacity = 0;
    }

    public Heap(int[] data, int capacity) {
        this.data = data;
        this.size = 0;
        this.capacity = capacity;
        this.data[0] = Integer.MAX_VALUE;
    }

    public Heap(int maxSize) {
        this.data = new int[maxSize + 1];//最大元素从1开始
        this.size = 0;
        this.capacity = maxSize;
        this.data[0] = Integer.MAX_VALUE;// 定义哨兵，为大于最大堆中所有可能元素的值
    }

    public boolean isFull() {
        return this.size == this.capacity;
    }

    public boolean isEmpty() {
        return this.size == 0;
    }

    public abstract boolean insert(int element);
}
</code></pre>
<h2 id=最大堆的插入>最大堆的插入</h2>
<p><img src=https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917112957455.png alt=image-20200917112957455></p>
<p>插入元素时，插入到数组的最后一个位置，这里插入的结点值为20，检查插入后仍然符合堆的两个特性，插入完成。</p>
<p><img src=https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917113136023.png alt=image-20200917113136023></p>
<p>当插入的值为35的时候，当前堆的有序性被破坏了，将35和31的位置调换后就可以了。</p>
<p><img src=https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917113303675.png alt=image-20200917113303675><img src=https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917113324619.png alt=image-20200917113324619></p>
<p>当插入的值为58的时候，58 > 31，跟31对调位置，58 > 44 继续跟根结点调换位置。调整后保证了有序性，同时，从58 -> 44 -> 31这条线也是按照从大到小的顺序。</p>
<pre><code class=language-java>public boolean insert(int element) {
    // 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵
    int i;

    if (isFull()) {
        System.out.println(&quot;最大堆已满&quot;);
        return false;
    }
    i = ++this.size; // i指向插入后堆中的最后一个元素的位置
    for (; this.data[i / 2] &lt; element; i /= 2) {
        data[i] = data[i / 2]; // 向下过滤结点，对调父结点的位置
    }
    data[i] = element; // 将X插入
    return true;
}
</code></pre>
<p>由于我们将数组的第 0 个元素设置为哨兵，哨兵的值为一个非常大的整数值。如果没有哨兵结点，我们在循环中还需要判断 i > 1 这个条件，有了哨兵之后，循环在 i = 0 的时候就会停下来，可以少写一个条件，提高程序效率。</p>
<p><img src=https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917114313272.png alt=image-20200917114313272></p>
<h2 id=最大堆的删除>最大堆的删除</h2>
<p>最大堆的删除过程就是取出根结点（最大值）元素，同时删除堆的一个结点。</p>
<p>删除下图的这个堆的最大值：</p>
<p><img src=https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917133516355.png alt=image-20200917133516355></p>
<ol>
<li>把 31 移至根</li>
<li>找出 31 的较大的孩子</li>
</ol>
<p>时间复杂度为： $T(N)=O(logN)$</p>
<pre><code class=language-java>public int deleteMax() {
    // 从最大堆中取出键值为最大的元素，并删除一个结点
    int parent, child;
    int maxItem, temp;//maxItem-堆顶元素，temp-临时变量
    if (isEmpty()) {
        System.out.println(&quot;最大堆已经为空&quot;);
        return -1;
    }

    maxItem = this.data[1];//取出根结点最大值
    // 用最大堆中的最后一个元素从根结点开始向上过滤下层结点
    temp = this.data[this.size--];
    for (parent = 1; parent * 2 &lt; this.size; parent = child) {
        child = parent * 2; // 左儿子的位置
        if (child != this.size &amp;&amp; this.data[child] &lt; this.data[child + 1]) {
            child++; //child 指向左右结点的较大者
        }
        if (temp &gt; this.data[child]) {//找到位置了
            break;
        } else {//将子结点与父节点对换
            this.data[parent] = this.data[child];
        }
    }
    this.data[parent] = temp;
    return maxItem;
}
</code></pre>
<h2 id=最大堆的建立>最大堆的建立</h2>
<p>建立最大堆是将已经存在的N个元素按最大堆的要求存放在一个一维数组中。</p>
<p>建堆的过程可以从树的从最后一个结点的父节点开始，到根结点1，将最后一个结点的父节点所在的小堆调整为最大堆，然后向左寻找有儿子的结点，每次调整一个最大堆，直到根结点。</p>
<pre><code class=language-java>public void buildHeap() {
    //* 调整Data[]中的元素，使满足最大堆的有序性  *//*
    //* 这里假设所有Size个元素已经存在Data[]中 *//*

    int i;

    //* 从最后一个结点的父节点开始，到根结点1 *//*
    for (i = this.size / 2; i &gt; 0; i--) {
        preDown(i);
    }
}

private void preDown(int p) {
    //* 下滤：将H中以Data[p]为根的子堆调整为最大堆 *//*
    int parent, child;
    int temp;

    temp = data[p]; //* 取出根结点存放的值 *//*
    for (parent = p; parent * 2 &lt;= size; parent = child) { //这个过程与删除的过程一样
        child = parent * 2;
        if ((child != size) &amp;&amp; (data[child] &lt; data[child + 1]))
            child++;  //* Child指向左右子结点的较大者 *//*
        if (temp &gt;= data[child]) break; //* 找到了合适位置 *//*
        else  //* 下滤X *//*
            data[parent] = data[child];
    }
    data[parent] = temp;
}

</code></pre>
<h2 id=最小堆>最小堆</h2>
<p>最小堆的建立和操作与最大堆大致上是一样的。</p>
<pre><code class=language-java>public class MinHeap extends Heap{

    public MinHeap(int maxSize, int sentinalVal) {
        super(maxSize, sentinalVal);
    }

    public MinHeap(int[] data, int maxSize, int sentinalVal) {//哨兵值
        super(data, maxSize, sentinalVal);
    }

    public boolean insert(int element) {
        // 将元素X插入最小堆H，其中H-&gt;Data[0]已经定义为哨兵
        int i;

        if (isFull()) {
            System.out.println(&quot;最大堆已满&quot;);
            return false;
        }
        i = ++this.size; // i指向插入后堆中的最后一个元素的位置
        for (; this.data[i / 2] &gt; element; i /= 2) {
            data[i] = data[i / 2]; // 向下过滤结点，对调父结点的位置
        }
        data[i] = element; // 将X插入
        return true;
    }

    public int deleteMin() {
        // 从最小堆中取出键值为最小的元素，并删除一个结点
        int parent, child;
        int minItem, temp;//minItem-堆顶元素，temp-临时变量
        if (isEmpty()) {
            System.out.println(&quot;最大堆已经为空&quot;);
            return -1;
        }

        minItem = this.data[1];//取出根结点最小值
        // 用最小堆中的最后一个元素从根结点开始向上过滤下层结点
        temp = this.data[this.size--];
        for (parent = 1; parent * 2 &lt; this.size; parent = child) {
            child = parent * 2; // 左儿子的位置
            if (child != this.size &amp;&amp; this.data[child] &gt; this.data[child + 1]) {
                child++; //child 指向左右结点的较小者
            }
            if (temp &lt; this.data[child]) {//找到位置了
                break;
            } else {//将子结点与父节点对换
                this.data[parent] = this.data[child];
            }
        }
        this.data[parent] = temp;
        return minItem;
    }

    //*----------- 建造最小堆 -----------*//*
    private void preDown(int p) {
        //* 下滤：将H中以Data[p]为根的子堆调整为最小堆 *//*
        int parent, child;
        int temp;

        temp = data[p]; //* 取出根结点存放的值 *//*
        for (parent = p; parent * 2 &lt;= size; parent = child) { //这个过程与删除的过程一样
            child = parent * 2;
            if ((child != size) &amp;&amp; (data[child] &gt; data[child + 1]))
                child++;  //* Child指向左右子结点的较小者 *//*
            if (temp &lt;= data[child]) break; //* 找到了合适位置 *//*
            else  //* 下滤X *//*
                data[parent] = data[child];
        }
        data[parent] = temp;
    }

    public void buildHeap() {
        //* 调整Data[]中的元素，使满足最大堆的有序性  *//*
        //* 这里假设所有Size个元素已经存在Data[]中 *//*

        int i;

        //* 从最后一个结点的父节点开始，到根结点1 *//*
        for (i = this.size / 2; i &gt; 0; i--) {
            preDown(i);
        }
    }
}
</code></pre>
<h2 id=总结>总结</h2>
<p>从堆的几种操作可以发现，删除和建堆的过程，就是从上往下调整堆的有序性的过程，插入元素的过程是从下往上调整堆的有序性的过程。</p>
<h2 id=参考>参考</h2>
<p>【1】<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1207006212#/learn/content?type=detail&id=1212031639&cid=1215166239">数据结构-浙江大学</a></p>
</div>
<div class=my-4>
<a href=https://ahamoment.cn/tags/%E6%A0%91/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#树</a>
<a href=https://ahamoment.cn/tags/%E5%A0%86/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#堆</a>
</div>
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
<div>
<span class="block font-bold">Previous</span>
<a href=https://ahamoment.cn/posts/linux/linux-nscd/ class=block>认识 Linux NSCD 服务缓存</a>
</div>
<div class="md:text-right mt-4 md:mt-0">
<span class="block font-bold">Next</span>
<a href=https://ahamoment.cn/posts/cloud/cloud-container-get-cpu/ class=block>容器内获取 CPU 核数问题</a>
</div>
</div>
</div>
<div class="col-span-2 lg:col-start-2 lg:col-span-6 bg-secondary-bg rounded p-6">
<h2 class="text-lg font-semibold mb-4">See Also</h2>
<div class=content>
<a href=https://ahamoment.cn/posts/algorithm/algorithm-balanced-binary-tree/>平衡二叉树</a>
<br>
<a href=https://ahamoment.cn/posts/algorithm/algorithm-binary-search-tree/>二叉搜索树</a>
<br>
<a href=https://ahamoment.cn/posts/algorithm/algorithm-binary-tree/>二叉树及存储结构</a>
<br>
<a href=https://ahamoment.cn/posts/algorithm/algorithm-tree/>树的定义及表示</a>
<br>
</div>
</div>
</div>
<script>document.addEventListener('DOMContentLoaded',()=>{hljs.initHighlightingOnLoad()})</script>
</div>
</div>
</main>
<footer class=pl-scrollbar>
<div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
<p class="text-sm text-tertiary-text">&copy; 2021
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p>
</div></div>
</footer>
</body>
</html>