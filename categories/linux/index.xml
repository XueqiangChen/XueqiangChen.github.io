<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on Ahamoment</title><link>https://ahamoment.cn/categories/linux/</link><description>Recent content in Linux on Ahamoment</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Wed, 10 Feb 2021 11:54:23 +0800</lastBuildDate><atom:link href="https://ahamoment.cn/categories/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 常用命令</title><link>https://ahamoment.cn/post/linux-commands/</link><pubDate>Wed, 10 Feb 2021 11:54:23 +0800</pubDate><guid>https://ahamoment.cn/post/linux-commands/</guid><description>
&lt;p>设置 JAVA_HOME&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bas" data-lang="bas">&lt;span class="ln">1&lt;/span>&lt;span class="vg">export&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="vg">JAVA_HOME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;$(dirname $(dirname $(realpath $(which javac))))&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="tee">tee&lt;/h2>
&lt;p>Linux tee命令用于读取标准输入的数据，并将其内容输出成文件。&lt;/p>
&lt;h3 id="语法">语法&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>tee &lt;span class="o">[&lt;/span>OPTION&lt;span class="o">]&lt;/span>... &lt;span class="o">[&lt;/span>FILE&lt;span class="o">]&lt;/span>...
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="说明">说明&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>-a, --append
&lt;span class="ln">2&lt;/span>添加内容到指定文件，不会覆盖源文件内容
&lt;span class="ln">3&lt;/span>
&lt;span class="ln">4&lt;/span>-i, --ignore-interrupts
&lt;span class="ln">5&lt;/span>忽略输入
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="cat">cat&lt;/h2>
&lt;p>将文件内容输出到控制台。&lt;/p></description></item><item><title>认识 Linux NSCD 服务缓存</title><link>https://ahamoment.cn/post/linux-nscd/</link><pubDate>Sun, 27 Sep 2020 13:23:05 +0800</pubDate><guid>https://ahamoment.cn/post/linux-nscd/</guid><description>
&lt;p>NSCD(Name Service Cache Daemon)是服务缓存守护进程。&lt;/p>
&lt;h2 id="nscd-安装">NSCD 安装&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>RHEL/CentOS&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>yum -y install nscd
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Debian/Ubuntu&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>apt-get install nscd
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>RPM&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>https://centos.pkgs.org/7/centos-x86_64/nscd-2.17-307.el7.1.x86_64.rpm.html
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>CentOS7 之后 NSCD 使用 systemd 进行管理。&lt;/p>
&lt;h2 id="nscd-命令选项">NSCD 命令选项&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ nscd --help
&lt;span class="ln"> 2&lt;/span>用法： nscd &lt;span class="o">[&lt;/span>选项...&lt;span class="o">]&lt;/span>
&lt;span class="ln"> 3&lt;/span>Name Service Cache Daemon.
&lt;span class="ln"> 4&lt;/span> -d, --debug Do not fork and display messages on the current
&lt;span class="ln"> 5&lt;/span> tty
&lt;span class="ln"> 6&lt;/span> -f, --config-file&lt;span class="o">=&lt;/span>名称 从NAME中读取配置数据
&lt;span class="ln"> 7&lt;/span> -g, --statistics Print current configuration statistics
&lt;span class="ln"> 8&lt;/span> -i, --invalidate&lt;span class="o">=&lt;/span>TABLE Invalidate the specified cache
&lt;span class="ln"> 9&lt;/span> -K, --shutdown 关闭服务器
&lt;span class="ln">10&lt;/span> -t, --nthreads&lt;span class="o">=&lt;/span>NUMBER 启动 NUMBER 个线程
&lt;span class="ln">11&lt;/span> -?, --help 给出该系统求助列表
&lt;span class="ln">12&lt;/span> --usage 给出简要的用法信息
&lt;span class="ln">13&lt;/span> -V, --version 打印程序版本号
&lt;span class="ln">14&lt;/span>
&lt;span class="ln">15&lt;/span>长选项的强制或可选参数对对应的短选项也是强制或可选的。
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nscd-配置文件">NSCD 配置文件&lt;/h2>
&lt;p>NSCD配置文件为&lt;code>/etc/nscd.conf&lt;/code>，NSCD程序在启动的时候会读取&lt;code>/etc/nscd.conf&lt;/code>文件，每一行指定一个属性和对应的值，或者指定一个服务和对应的值，#表示注释。有效的服务设定是：passwd, group, hosts, services, or netgroup五个。&lt;/p>
&lt;p>NSCD 的缓存文件路径默认为 &lt;code>/var/db/nscd/&lt;/code>。&lt;/p>
&lt;p>NSCD 的配置文件相关参数&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1">#设置日志文件&lt;/span>
&lt;span class="ln"> 2&lt;/span>logfile debug-file-name
&lt;span class="ln"> 3&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">#设置debug记录的级别，默认是0&lt;/span>
&lt;span class="ln"> 5&lt;/span>debug-level value
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">#程序启动时，等待进去请求的处理线程数，至少5个&lt;/span>
&lt;span class="ln"> 8&lt;/span>threads number
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="c1">#最大线程数，默认32&lt;/span>
&lt;span class="ln">11&lt;/span>max-threads number
&lt;span class="ln">12&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="c1">#nscd程序以哪个用户运行,如果设置了该选项，nscd将作为该用户运行，而不是作为root。如果每个用户都使用一个单独的缓存(-S参数)，将忽略该选项。&lt;/span>
&lt;span class="ln">14&lt;/span>server-user user
&lt;span class="ln">15&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="c1">#哪个用户可以请求统计用户&lt;/span>
&lt;span class="ln">17&lt;/span>stat-user user
&lt;span class="ln">18&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="c1">#在一个缓存项被删除之前允许使用的次数，默认值是5，代表SUCCESS的缓存在内存中会Reload5次&lt;/span>
&lt;span class="ln">20&lt;/span>reload-count unlimited &lt;span class="p">|&lt;/span> number
&lt;span class="ln">21&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="c1">#是否启用偏执模式，启用会导致nscd周期性重启，默认是no&lt;/span>
&lt;span class="ln">23&lt;/span>paranoia &amp;lt;yes&lt;span class="p">|&lt;/span>no&amp;gt;
&lt;span class="ln">24&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="c1">#如果启用偏执模式，设置的定期重启nscd的时间间隔，默认是3600秒&lt;/span>
&lt;span class="ln">26&lt;/span>restart-interval &lt;span class="nb">time&lt;/span>
&lt;span class="ln">27&lt;/span>
&lt;span class="ln">28&lt;/span>&lt;span class="c1">#开启或者关闭服务缓存，默认是no&lt;/span>
&lt;span class="ln">29&lt;/span>enable-cache service &amp;lt;yes&lt;span class="p">|&lt;/span>no&amp;gt;
&lt;span class="ln">30&lt;/span>
&lt;span class="ln">31&lt;/span>&lt;span class="c1">#为成功请求的元素设置缓存TTL，单位是秒，值越大缓存命中率越高，降低平均响应时间，但会增加缓存的一致性问题&lt;/span>
&lt;span class="ln">32&lt;/span>positive-time-to-live service value
&lt;span class="ln">33&lt;/span>
&lt;span class="ln">34&lt;/span>&lt;span class="c1">#为失败查询元素设置缓存TTL，单位是秒，应保持小值，减小缓存一致性问题&lt;/span>
&lt;span class="ln">35&lt;/span>negative-time-to-live service value
&lt;span class="ln">36&lt;/span>
&lt;span class="ln">37&lt;/span>&lt;span class="c1">#内部的散列表大小，value应该保持一个素数以达到优化效果。默认值是211&lt;/span>
&lt;span class="ln">38&lt;/span>suggested-size service value
&lt;span class="ln">39&lt;/span>
&lt;span class="ln">40&lt;/span>&lt;span class="c1">#启用或者禁用检查文件是否属于指定的服务，这些文件是/etc/passwd、/etc/group、/etc/hosts、/etc/services、/etc/netgroup等&lt;/span>
&lt;span class="ln">41&lt;/span>check-files service &amp;lt;yes&lt;span class="p">|&lt;/span>no&amp;gt;
&lt;span class="ln">42&lt;/span>
&lt;span class="ln">43&lt;/span>&lt;span class="c1">#设置缓存在服务器重启后，仍旧能提供缓存服务，在使用偏执模式时有用，默认是no&lt;/span>
&lt;span class="ln">44&lt;/span>persistent service &amp;lt;yes&lt;span class="p">|&lt;/span>no&amp;gt;
&lt;span class="ln">45&lt;/span>
&lt;span class="ln">46&lt;/span>&lt;span class="c1">#为客户端共享nscd数据库在内存中做的映射，使客户端可以直接搜索，而不用每次都查询守护进行，默认是no&lt;/span>
&lt;span class="ln">47&lt;/span>shared service &amp;lt;yes&lt;span class="p">|&lt;/span>no&amp;gt;
&lt;span class="ln">48&lt;/span>
&lt;span class="ln">49&lt;/span>&lt;span class="c1">#该数据库的最大大小，单位是bytes，默认是33554432&lt;/span>
&lt;span class="ln">50&lt;/span>max-db-size service bytes
&lt;span class="ln">51&lt;/span>
&lt;span class="ln">52&lt;/span>&lt;span class="c1">#此选项仅使用于passwd和group服务&lt;/span>
&lt;span class="ln">53&lt;/span>auto-propagate service &amp;lt;yes&lt;span class="p">|&lt;/span>no&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nscd-使用示例对dns进行缓存">NSCD 使用示例：对DNS进行缓存&lt;/h2>
&lt;h3 id="dns缓存在服务器上的作用">DNS缓存在服务器上的作用&lt;/h3>
&lt;p>在需要通过域名与外界进行数据交互的时候,dns缓存就派上用场了,它可以减少域名解析的时间,提高效率。例如以下情况&lt;/p>
&lt;ul>
&lt;li>使用爬虫采集网络上的页面数据,&lt;/li>
&lt;li>使用auth2.0协议从其他平台(如微博或QQ)获取用户数据,&lt;/li>
&lt;li>使用第三方支付接口,&lt;/li>
&lt;li>使用短信通道下发短信等.&lt;/li>
&lt;/ul>
&lt;h3 id="开启nscd-dns-缓存服务的优缺点">开启NSCD DNS 缓存服务的优缺点&lt;/h3>
&lt;ul>
&lt;li>优点：
&lt;ul>
&lt;li>本地缓存DNS解析信息，提供解析速度。&lt;/li>
&lt;li>DNS服务挂了也没有问题，在缓存服务时间范围内，解析依旧正常。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>DNS解析信息会滞后，如域名解析更改需要手动刷新缓存，NSCD不适合做实时的切换的应用&lt;/li>
&lt;li>多条RR的情况下失去轮询功能，导致缓存周期内单机的负载均衡失效&lt;/li>
&lt;li>域名变更生效可能持续一个TTL+15s，对于一部分讲究变更快速生效的域名而言有一定的变更生效延误&lt;/li>
&lt;li>对于一部分异常导致解析错误的域名，有可能被NSCD缓存导致一段时间内解析都异常&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="配置dns缓存">配置DNS缓存&lt;/h3>
&lt;p>通过编辑&lt;code>/etc/nscd.conf&lt;/code>文件，在其中增加如下一行可以开启本地DNS Cache&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>enable-cache hosts yes &lt;span class="c1">#这个服务除了dns缓存之外还可以缓存passwd,group,servers&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>完整配置如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ cat /etc/nscd.conf
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>logfile /var/log/nscd.log
&lt;span class="ln"> 4&lt;/span>threads &lt;span class="m">5&lt;/span>
&lt;span class="ln"> 5&lt;/span>max-threads &lt;span class="m">32&lt;/span>
&lt;span class="ln"> 6&lt;/span>server-user nscd
&lt;span class="ln"> 7&lt;/span>debug-level &lt;span class="m">0&lt;/span>
&lt;span class="ln"> 8&lt;/span>paranoia no
&lt;span class="ln"> 9&lt;/span>reload-count &lt;span class="m">5&lt;/span>
&lt;span class="ln">10&lt;/span>enable-cache hosts yes
&lt;span class="ln">11&lt;/span>enable-cache passwd no
&lt;span class="ln">12&lt;/span>enable-cache group no
&lt;span class="ln">13&lt;/span>positive-time-to-live hosts &lt;span class="m">60&lt;/span>
&lt;span class="ln">14&lt;/span>negative-time-to-live hosts &lt;span class="m">20&lt;/span>
&lt;span class="ln">15&lt;/span>suggested-size hosts &lt;span class="m">211&lt;/span>
&lt;span class="ln">16&lt;/span>check-files hosts yes
&lt;span class="ln">17&lt;/span>persistent hosts yes
&lt;span class="ln">18&lt;/span>shared hosts yes
&lt;span class="ln">19&lt;/span>max-db-size hosts &lt;span class="m">33554432&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="关于主动刷新">关于主动刷新&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>reload-count &lt;span class="m">5&lt;/span> 默认值是5，代表SUCCESS的缓存在内存中会Reload 5次
&lt;/code>&lt;/pre>&lt;/div>&lt;p>reload的time是DNS应答&lt;code>TTL&lt;/code>+&lt;code>CACHE_PRUNE_INTERVAL&lt;/code>，reload过程中NSCD会主动发起DNS请求（非客户端发起），如果期间发生解析结果变更会将结果主动更新至NSCD缓存。这里的CACHE_PRUNE_INTERVAL来自于相关的宏定义：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="ln">1&lt;/span>#define CACHE_PRUNE_INTERVAL 15
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="关于非success域名的缓存">关于非success域名的缓存&lt;/h4>
&lt;p>查看代码发现对于非success域名的缓存，NSCD会读取配置中的negative-time-to-live hosts，将缓存一个negative-time-to-live hosts+CACHE_PRUNE_INTERVAL的时间&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="ln">1&lt;/span>dataset-&amp;gt;head.ttl = ttl == INT32_MAX ? db-&amp;gt;negtimeout : ttl;
&lt;span class="ln">2&lt;/span> timeout = dataset-&amp;gt;head.timeout = t + dataset-&amp;gt;head.ttl;
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="关于缓存的rr轮询">关于缓存的RR轮询&lt;/h4>
&lt;p>NSCD是直接缓存了GETHOSTBYNAME/GETHOSTBYADD的应答结果，如果存在多条RR的情况下，将只会读取应答结果中的第一条结果作为函数的返回值。多条RR在NSCD的缓存中并没有RR轮询的效果，直到下一次reload更新缓存结果。这里可能导致域名原本的负载均衡机制失效。&lt;/p>
&lt;h4 id="关于cnamea的结果">关于CNAME+A的结果&lt;/h4>
&lt;p>GLIBC的GETHOSTBYNAME/GETHOSTBYADD返回的TTL中直接读取的是A类型的TTL，代码中并没有针对CNAME的TTL做特殊处理，因此在有CNAME+A的级联应答结果中，缓存的timeout将只会读取对应的A记录的TTL。
当DNS应答结果只有CNAME时，DNS请求将被判定为失败，这时CNAME的TTL将不起作用，缓存的时间将遵循非success域名的timeout计算。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="ln">1&lt;/span>return ((qtype == T_A || qtype == T_AAAA) &amp;amp;&amp;amp; ap != host_data-&amp;gt;aliases
&lt;span class="ln">2&lt;/span> ? NSS_STATUS_NOTFOUND : NSS_STATUS_TRYAGAIN);
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="启动-nscd-进程">启动 NSCD 进程&lt;/h3>
&lt;p>默认该服务在Redhat或Centos下是关闭的，可以通过以下指令开启&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>$ systemctl start nscd
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看进程，如下所示&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>$ ps aux | grep nscd
&lt;span class="ln">2&lt;/span>nscd 1284 0.1 0.3 708056 1580 ? Ssl 23:37 0:00 /usr/sbin/nscd
&lt;/code>&lt;/pre>&lt;/div>&lt;p>说明已经正常运行了。&lt;/p>
&lt;h3 id="nscd服务查看和清除">NSCD服务查看和清除&lt;/h3>
&lt;p>NSCD缓存DB文件在&lt;code>/var/db/nscd&lt;/code>下。可以通过&lt;code>nscd -g&lt;/code>查看统计的信息，这里列出部分：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ nscd -g
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>nscd 配置：
&lt;span class="ln"> 4&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="m">0&lt;/span> 服务器调试级别
&lt;span class="ln"> 6&lt;/span> 4s server runtime
&lt;span class="ln"> 7&lt;/span> &lt;span class="m">5&lt;/span> current number of threads
&lt;span class="ln"> 8&lt;/span> &lt;span class="m">32&lt;/span> maximum number of threads
&lt;span class="ln"> 9&lt;/span> &lt;span class="m">0&lt;/span> number of &lt;span class="nb">times&lt;/span> clients had to &lt;span class="nb">wait&lt;/span>
&lt;span class="ln">10&lt;/span> no paranoia mode enabled
&lt;span class="ln">11&lt;/span> &lt;span class="m">3600&lt;/span> restart internal
&lt;span class="ln">12&lt;/span> &lt;span class="m">5&lt;/span> reload count
&lt;span class="ln">13&lt;/span>
&lt;span class="ln">14&lt;/span>... 省略输出信息若干 ...
&lt;span class="ln">15&lt;/span>
&lt;span class="ln">16&lt;/span>hosts cache:
&lt;span class="ln">17&lt;/span>
&lt;span class="ln">18&lt;/span> yes cache is enabled
&lt;span class="ln">19&lt;/span> yes cache is persistent
&lt;span class="ln">20&lt;/span> yes cache is shared
&lt;span class="ln">21&lt;/span> &lt;span class="m">211&lt;/span> suggested size
&lt;span class="ln">22&lt;/span> &lt;span class="m">216064&lt;/span> total data pool size
&lt;span class="ln">23&lt;/span> &lt;span class="m">0&lt;/span> used data pool size
&lt;span class="ln">24&lt;/span> &lt;span class="m">60&lt;/span> seconds &lt;span class="nb">time&lt;/span> to live &lt;span class="k">for&lt;/span> positive entries
&lt;span class="ln">25&lt;/span> &lt;span class="m">20&lt;/span> seconds &lt;span class="nb">time&lt;/span> to live &lt;span class="k">for&lt;/span> negative entries
&lt;span class="ln">26&lt;/span> &lt;span class="m">0&lt;/span> cache hits on positive entries
&lt;span class="ln">27&lt;/span> &lt;span class="m">0&lt;/span> cache hits on negative entries
&lt;span class="ln">28&lt;/span> &lt;span class="m">0&lt;/span> cache misses on positive entries
&lt;span class="ln">29&lt;/span> &lt;span class="m">0&lt;/span> cache misses on negative entries
&lt;span class="ln">30&lt;/span> 0% cache hit rate
&lt;span class="ln">31&lt;/span> &lt;span class="m">0&lt;/span> current number of cached values
&lt;span class="ln">32&lt;/span> &lt;span class="m">0&lt;/span> maximum number of cached values
&lt;span class="ln">33&lt;/span> &lt;span class="m">0&lt;/span> maximum chain length searched
&lt;span class="ln">34&lt;/span> &lt;span class="m">0&lt;/span> number of delays on rdlock
&lt;span class="ln">35&lt;/span> &lt;span class="m">0&lt;/span> number of delays on wrlock
&lt;span class="ln">36&lt;/span> &lt;span class="m">0&lt;/span> memory allocations failed
&lt;span class="ln">37&lt;/span> yes check /etc/hosts &lt;span class="k">for&lt;/span> changes
&lt;span class="ln">38&lt;/span>
&lt;span class="ln">39&lt;/span>... 省略输出信息若干 ...
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="清除指定类型缓存">清除指定类型缓存&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ nscd -i passwd
&lt;span class="ln">2&lt;/span>$ nscd -i group
&lt;span class="ln">3&lt;/span>$ nscd -i hosts
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="关闭服务">关闭服务&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ nscd -K
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考文章">参考文章&lt;/h2>
&lt;p>【1】&lt;a href="https://www.hi-linux.com/posts/9461.html">Linux 下开启缓存服务 NSCD&lt;/a>&lt;/p>
&lt;p>【2】&lt;a href="https://zhuanlan.zhihu.com/p/44556919">阿里DNS: NSCD-DNS缓存详解&lt;/a>&lt;/p>
&lt;p>【3】&lt;a href="https://linux.die.net/man/8/nscd">Linux man page&lt;/a>&lt;/p></description></item><item><title>解决setcap导致Java加载libjli.so 失败问题</title><link>https://ahamoment.cn/post/linux-cap/</link><pubDate>Fri, 11 Sep 2020 11:12:43 +0800</pubDate><guid>https://ahamoment.cn/post/linux-cap/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>最近碰到一个问题，有个应用在启动的时候一直报错，错误信息如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>java: error &lt;span class="k">while&lt;/span> loading shared libraries: libjli.so: cannot open shared object file: No such file or directory
&lt;/code>&lt;/pre>&lt;/div>&lt;p>错误信息是说 java 应用加载不到 libjli.so 文件，我们使用 &lt;code>java -version&lt;/code> 命令，同样的错误又出现了。使用 ldd 命令查看一下 java 应用是否加载了这个 so 文件，发现 java 应用加载的 so 文件中存在 libjli.so。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ ldd java
&lt;span class="ln">2&lt;/span> linux-vdso.so.1 &lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="o">(&lt;/span>0x00007ffe2a9c7000&lt;span class="o">)&lt;/span>
&lt;span class="ln">3&lt;/span> /usr/local/lib/libsysconfcpus.so &lt;span class="o">(&lt;/span>0x00002ac503ca8000&lt;span class="o">)&lt;/span>
&lt;span class="ln">4&lt;/span> libz.so.1 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libz.so.1 &lt;span class="o">(&lt;/span>0x00002ac503eaa000&lt;span class="o">)&lt;/span>
&lt;span class="ln">5&lt;/span> libjli.so &lt;span class="o">=&lt;/span>&amp;gt; /apps/svr/jdk-14.0.1/bin/./../lib/libjli.so &lt;span class="o">(&lt;/span>0x00002ac5040c0000&lt;span class="o">)&lt;/span>
&lt;span class="ln">6&lt;/span> libpthread.so.0 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libpthread.so.0 &lt;span class="o">(&lt;/span>0x00002ac5042d1000&lt;span class="o">)&lt;/span>
&lt;span class="ln">7&lt;/span> libdl.so.2 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libdl.so.2 &lt;span class="o">(&lt;/span>0x00002ac5044ee000&lt;span class="o">)&lt;/span>
&lt;span class="ln">8&lt;/span> libc.so.6 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libc.so.6 &lt;span class="o">(&lt;/span>0x00002ac5046f2000&lt;span class="o">)&lt;/span>
&lt;span class="ln">9&lt;/span> /lib64/ld-linux-x86-64.so.2 &lt;span class="o">(&lt;/span>0x00002ac503883000&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们接着查看了 &lt;code>LD_LIBRARY_PATH&lt;/code> 和 &lt;code>/etc/ld.so.conf.d/xxx.conf&lt;/code> 文件的配置，发现都是正常的。通过对比其他应用的启动配置，发现该应用使用了 80 端口启动，但是我们的容器只能使用 apps 权限登录，所以在启动前使用 &lt;code>setcap&lt;/code> 命令提升了 java 应用的权限，允许其使用 80 端口，会不会是这个操作导致的呢？在查看原因之前，我们需要先理解几个概念。&lt;/p>
&lt;h2 id="linux-动态库">Linux 动态库&lt;/h2>
&lt;p>动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，不同的应用程序如果调用相同的库,那么在内存中只需要有一份该动态库(共享库)的实例。这类库的名字一般是libxxx.so，其中so是 Shared Object 的缩写，即可以共享的目标文件。在链接动态库生成可执行文件时，并不会把动态库的代码复制到执行文件中，而是在执行文件中记录对动态库的引用。&lt;/p>
&lt;p>Linux下生成和使用动态库的步骤如下：&lt;/p>
&lt;ol>
&lt;li>编写源文件。&lt;/li>
&lt;li>将一个或几个源文件编译链接，生成共享库。&lt;/li>
&lt;li>通过 &lt;code>-L -lxxx&lt;/code> 的gcc选项链接生成的libxxx.so。例如&lt;code>gcc -fPIC -shared -o libmax.so max.c&lt;/code> , &lt;code>-fPIC&lt;/code> 是编译选项，PIC是 Position Independent Code 的缩写，表示要生成位置无关的代码，这是动态库需要的特性； &lt;code>-shared&lt;/code> 是链接选项，告诉gcc生成动态库而不是可执行文件&lt;/li>
&lt;li>把libxxx.so放入链接库的标准路径，或指定 &lt;code>LD_LIBRARY_PATH&lt;/code>，才能运行链接了libxxx.so的程序。&lt;/li>
&lt;/ol>
&lt;p>Linux是通过 &lt;code>/etc/ld.so.cache&lt;/code> 文件搜寻要链接的动态库的。而 &lt;code>/etc/ld.so.cache&lt;/code> 是 ldconfig 程序读取 &lt;code>/etc/ld.so.conf&lt;/code> 文件生成的。
（注意， &lt;code>/etc/ld.so.conf&lt;/code> 中并不必包含 &lt;code>/lib&lt;/code> 和 &lt;code>/usr/lib&lt;/code>，&lt;code>ldconfig&lt;/code>程序会自动搜索这两个目录）&lt;/p>
&lt;p>我们把要用的 libxx.so 文件所在的路径添加到 &lt;code>/etc/ld.so.conf&lt;/code> 中，再以root权限运行 &lt;code>ldconfig&lt;/code> 程序，更新 &lt;code>/etc/ld.so.cache&lt;/code> ，程序运行时，就可以找到 &lt;code>libxx.so&lt;/code>。另外就是通过配置 &lt;code>LD_LIBRARY_PATH&lt;/code> 的方式来指定通过某些路径寻找链接的动态库。&lt;/p>
&lt;h3 id="ldd-查看程序依赖">ldd 查看程序依赖&lt;/h3>
&lt;p>理解了动态库的概念之后，当碰到某个程序报错缺少某个库文件时，我们应该怎么查看该程序当前加载了哪些库文件呢？可以用 &lt;code>ldd&lt;/code> 命令。&lt;/p>
&lt;p>ldd 命令的作用是用来查看程式运行所需的共享库,常用来解决程式因缺少某个库文件而不能运行的一些问题。&lt;/p>
&lt;p>例如：查看test程序运行所依赖的库:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost testso&lt;span class="o">]&lt;/span>&lt;span class="c1"># ldd /etc/alternatives/java&lt;/span>
&lt;span class="ln">2&lt;/span> linux-vdso.so.1 &lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="o">(&lt;/span>0x00007ffde15f8000&lt;span class="o">)&lt;/span>
&lt;span class="ln">3&lt;/span> libpthread.so.0 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libpthread.so.0 &lt;span class="o">(&lt;/span>0x00007f03f2f8d000&lt;span class="o">)&lt;/span>
&lt;span class="ln">4&lt;/span> libdl.so.2 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libdl.so.2 &lt;span class="o">(&lt;/span>0x00007f03f2d89000&lt;span class="o">)&lt;/span>
&lt;span class="ln">5&lt;/span> libc.so.6 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libc.so.6 &lt;span class="o">(&lt;/span>0x00007f03f29bb000&lt;span class="o">)&lt;/span>
&lt;span class="ln">6&lt;/span> /lib64/ld-linux-x86-64.so.2 &lt;span class="o">(&lt;/span>0x00007f03f33ab000&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>第一列：程序需要依赖什么库&lt;/li>
&lt;li>第二列: 系统提供的与程序需要的库所对应的库&lt;/li>
&lt;li>第三列：库加载的开始地址&lt;/li>
&lt;/ul>
&lt;p>通过上面的信息，我们可以得到以下几个信息：&lt;/p>
&lt;ol>
&lt;li>通过对比第一列和第二列，我们可以分析程序需要依赖的库和系统实际提供的，是否相匹配&lt;/li>
&lt;li>通过观察第三列，我们可以知道在当前的库中的符号在对应的进程的地址空间中的开始位置&lt;/li>
&lt;/ol>
&lt;p>如果依赖的某个库找不到，通过这个命令可以迅速定位问题所在.&lt;/p>
&lt;h2 id="linux-capability">Linux capability&lt;/h2>
&lt;p>从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 capabilites。Capabilites 作为线程(Linux 并不真正区分进程和线程)的属性存在，每个单元可以独立启用和禁用。如此一来，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作。&lt;/p>
&lt;p>下面是从 &lt;a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities man page&lt;/a> 中摘取的 capabilites 列表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>capability 名称&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CAP_AUDIT_CONTROL&lt;/td>
&lt;td>启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_AUDIT_READ&lt;/td>
&lt;td>允许通过 multicast netlink 套接字读取审计日志&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_AUDIT_WRITE&lt;/td>
&lt;td>将记录写入内核审计日志&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_BLOCK_SUSPEND&lt;/td>
&lt;td>使用可以阻止系统挂起的特性&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_CHOWN&lt;/td>
&lt;td>修改文件所有者的权限&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_DAC_OVERRIDE&lt;/td>
&lt;td>忽略文件的 DAC 访问限制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_DAC_READ_SEARCH&lt;/td>
&lt;td>忽略文件读及目录搜索的 DAC 访问限制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_FOWNER&lt;/td>
&lt;td>忽略文件属主 ID 必须和进程用户 ID 相匹配的限制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_FSETID&lt;/td>
&lt;td>允许设置文件的 setuid 位&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_IPC_LOCK&lt;/td>
&lt;td>允许锁定共享内存片段&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_IPC_OWNER&lt;/td>
&lt;td>忽略 IPC 所有权检查&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_KILL&lt;/td>
&lt;td>允许对不属于自己的进程发送信号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_LEASE&lt;/td>
&lt;td>允许修改文件锁的 FL_LEASE 标志&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_LINUX_IMMUTABLE&lt;/td>
&lt;td>允许修改文件的 IMMUTABLE 和 APPEND 属性标志&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_MAC_ADMIN&lt;/td>
&lt;td>允许 MAC 配置或状态更改&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_MAC_OVERRIDE&lt;/td>
&lt;td>覆盖 MAC(Mandatory Access Control)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_MKNOD&lt;/td>
&lt;td>允许使用 mknod() 系统调用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_NET_ADMIN&lt;/td>
&lt;td>允许执行网络管理任务&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_NET_BIND_SERVICE&lt;/td>
&lt;td>允许绑定到小于 1024 的端口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_NET_BROADCAST&lt;/td>
&lt;td>允许网络广播和多播访问&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_NET_RAW&lt;/td>
&lt;td>允许使用原始套接字&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SETGID&lt;/td>
&lt;td>允许改变进程的 GID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SETFCAP&lt;/td>
&lt;td>允许为文件设置任意的 capabilities&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SETPCAP&lt;/td>
&lt;td>参考 &lt;a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities man page&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SETUID&lt;/td>
&lt;td>允许改变进程的 UID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_ADMIN&lt;/td>
&lt;td>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_BOOT&lt;/td>
&lt;td>允许重新启动系统&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_CHROOT&lt;/td>
&lt;td>允许使用 chroot() 系统调用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_MODULE&lt;/td>
&lt;td>允许插入和删除内核模块&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_NICE&lt;/td>
&lt;td>允许提升优先级及设置其他进程的优先级&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_PACCT&lt;/td>
&lt;td>允许执行进程的 BSD 式审计&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_PTRACE&lt;/td>
&lt;td>允许跟踪任何进程&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_RAWIO&lt;/td>
&lt;td>允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_RESOURCE&lt;/td>
&lt;td>忽略资源限制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_TIME&lt;/td>
&lt;td>允许改变系统时钟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_TTY_CONFIG&lt;/td>
&lt;td>允许配置 TTY 设备&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYSLOG&lt;/td>
&lt;td>允许使用 syslog() 系统调用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_WAKE_ALARM&lt;/td>
&lt;td>允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>getcap&lt;/strong> 命令和 &lt;strong>setcap&lt;/strong> 命令分别用来查看和设置程序文件的 capabilities 属性。&lt;/p>
&lt;p>例如&lt;strong>为 ping 命令文件添加 capabilities&lt;/strong>&lt;/p>
&lt;p>执行 ping 命令所需的 capabilities 为 cap_net_admin 和 cap_net_raw，通过 setcap 命令可以添加它们：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ sudo setcap cap_net_admin,cap_net_raw+ep /bin/ping
&lt;/code>&lt;/pre>&lt;/div>&lt;p>移除添加的 capabilities ，执行下面的命令：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ sudo setcap cap_net_admin,cap_net_raw-ep /bin/ping
&lt;/code>&lt;/pre>&lt;/div>&lt;p>命令中的 ep 分别表示 Effective 和 Permitted 集合(接下来会介绍)，+ 号表示把指定的 capabilities 添加到这些集合中，- 号表示从集合中移除(对于 Effective 来说是设置或者清除位)。&lt;/p>
&lt;h2 id="解决问题">解决问题&lt;/h2>
&lt;p>回到我们开始的问题，由于我们为非 root 用户赋予了使用 80 端口的权限，调用了如下命令：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>setcap &lt;span class="nv">cap_net_bind_service&lt;/span>&lt;span class="o">=&lt;/span>+ep /usr/bin/java
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当一个可执行文件提升了权限后，运行时加载程序（rtld）— ld.so，它不会与不受信任路径中的库链接。Linux 会为使用了 &lt;code>setcap&lt;/code> 或 &lt;code>suid&lt;/code> 的程序禁用掉 &lt;code>LD_LIBRARY_PATH&lt;/code>。所以就出现了 java 程序加载不到 libjli.so 的情况了，这是 JDK 的一个 bug。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="http://bugs.sun.com/view_bug.do?bug_id=7157699">JDK-7157699 : can not run java after granting posix capabilities&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>那么既然使用 setcap 后不会加载链接库，我们就可以将 libjli.so 所在的路径添加到 &lt;code>/etc/ld.so.conf/xxx.conf&lt;/code>中，例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>% cat /etc/ld.so.conf.d/java.conf
&lt;span class="ln">2&lt;/span>/usr/java/jdk1.8.0_261-amd64/lib/amd64/jli
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>ldconfig&lt;/code> 重载 so 文件。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost jli&lt;span class="o">]&lt;/span>&lt;span class="c1"># ldconfig -p | grep libjli&lt;/span>
&lt;span class="ln">2&lt;/span> libjli.so &lt;span class="o">(&lt;/span>libc6,x86-64&lt;span class="o">)&lt;/span> &lt;span class="o">=&lt;/span>&amp;gt; /usr/java/jdk1.8.0_261-amd64/lib/amd64/jli/libjli.so% ldconfig &lt;span class="p">|&lt;/span> grep libjli
&lt;span class="ln">3&lt;/span>libjli.so -&amp;gt; libjli.so
&lt;span class="ln">4&lt;/span>.......
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样再次测试就可以了。&lt;/p>
&lt;h2 id="参考文章">参考文章&lt;/h2>
&lt;p>【1】&lt;a href="https://www.cnblogs.com/jiqingwu/p/linux_dynamic_lib_create.html">Linux动态库生成与使用指南&lt;/a>&lt;/p>
&lt;p>【2】&lt;a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html#ldd">ldd 查看程序依赖库&lt;/a>&lt;/p>
&lt;p>【3】&lt;a href="https://www.cnblogs.com/sparkdev/p/11417781.html">Linux Capabiliites 简介&lt;/a>&lt;/p>
&lt;p>【4】&lt;a href="https://linux.die.net/man/7/capabilities">capabilities(7) - Linux man page&lt;/a>&lt;/p>
&lt;p>【5】&lt;a href="https://www.boris1993.com/linux/allow-non-root-process-to-bind-low-numbered-ports.html">如何允许非 root 进程绑定低位端口&lt;/a>&lt;/p>
&lt;p>【6】[&lt;a href="https://unix.stackexchange.com/questions/87978/how-to-get-oracle-java-7-to-work-with-setcap-cap-net-bind-serviceep">How to get Oracle java 7 to work with setcap cap_net_bind_service+ep&lt;/a>](&lt;a href="https://unix.stackexchange.com/questions/87978/how-to-get-oracle-java-7-to-work-with-setcap-cap-net-bind-serviceep">https://unix.stackexchange.com/questions/87978/how-to-get-oracle-java-7-to-work-with-setcap-cap-net-bind-serviceep&lt;/a>)&lt;/p></description></item><item><title>Linux Shell Script 基础教程</title><link>https://ahamoment.cn/post/linux-bash-tutorials/</link><pubDate>Thu, 27 Aug 2020 16:03:59 +0800</pubDate><guid>https://ahamoment.cn/post/linux-bash-tutorials/</guid><description>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20191206150655886.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&lt;/p>
&lt;blockquote>
&lt;p>本文翻译自&lt;a href="https://www.tutorialspoint.com/unix/unix-what-is-shell.htm">LEARN UNIX&lt;/a>，博主在原文的基础上添加了一些内容。如果没有Linux 机器，推荐使用该网站 &lt;strong>&lt;a href="https://www.tutorialspoint.com/execute_ksh_online.php">https://www.tutorialspoint.com/execute_ksh_online.php&lt;/a>&lt;/strong> 作为shell在线demo的环境。&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-shell-是什么">1. Shell 是什么&lt;/h2>
&lt;p>Shell为您提供了与Unix系统的接口。它收集您的输入，并根据该输入执行程序。程序完成执行后，将显示该程序的输出。
Shell 是可以运行我们的命令，程序，shell 脚本的环境。Shell 有不同的类型，每种Shell都有它自己的命令和功能。&lt;/p>
&lt;h3 id="11-shell-类型">1.1 Shell 类型&lt;/h3>
&lt;p>Linux 系统中，主要有两种类型的Shell：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>Bourne shell&lt;/code>&lt;/strong> - 如果使用Bourne类型的shell，默认的提示符就是&lt;code>$&lt;/code>，可以通过修改环境变量&lt;code>PS1&lt;/code>来更改你的提示符。&lt;/li>
&lt;li>&lt;strong>&lt;code>C shell&lt;/code>&lt;/strong> - C 类型的shell，默认的提示符是&lt;code>%&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>Bourne Shell&lt;/strong>&lt;/em> 又有下面几种类型：&lt;/p>
&lt;ul>
&lt;li>Bourne shell (sh)&lt;/li>
&lt;li>Korn shell (ksh)&lt;/li>
&lt;li>Bourne Again shell (bash)&lt;/li>
&lt;li>POSIX shell (sh)&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>C 类型&lt;/strong>&lt;/em> 的Shell包括以下两种：&lt;/p>
&lt;ul>
&lt;li>C shell (csh)&lt;/li>
&lt;li>TENEX/TOPS C shell (tcsh)&lt;/li>
&lt;/ul>
&lt;p>在大多数 Linux 版本中，Bourne shell 通常都安装为&lt;code>/bin/sh&lt;/code>。由于这个原因，它是不同版本的Linux 的首选 Shell。在本文中，我们将介绍大多数基于Bourne Shell的Shell概念。&lt;/p>
&lt;h3 id="12-shell-脚本">1.2 Shell 脚本&lt;/h3>
&lt;p>&lt;strong>Shell脚本的基本概念是命令列表，按执行顺序列出命令。&lt;/strong>
Shell 脚本文件以 &lt;strong>.sh&lt;/strong> 结尾，例如 &lt;strong>test.sh&lt;/strong> 。Shell 脚本的内容以 &lt;strong>&lt;code>#!&lt;/code>&lt;/strong> 开头，告诉系统接下来的命令将会被 Bourne Shell 执行。我们来创建一个Shell脚本，并往脚本中添加一点注释，注释以 &lt;strong>&lt;code>#&lt;/code>&lt;/strong> 开头：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="c1"># Author: xueqiang.chen&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="c1"># Script follows here:&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nb">pwd&lt;/span>
&lt;span class="ln">6&lt;/span>ls
&lt;/code>&lt;/pre>&lt;/div>&lt;p>保存命令并执行脚本，可以看到以下输出内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ chmod +x test.sh
&lt;span class="ln">2&lt;/span>
&lt;span class="ln">3&lt;/span>$ ./test.sh
&lt;span class="ln">4&lt;/span>/home/centos
&lt;span class="ln">5&lt;/span>go.sh test.sh
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Shell 脚本可以有很复杂的结构，毕竟，shell是一种真正的编程语言，它包括变量，控制结构等。无论脚本变得多么复杂，它仍然只是顺序执行的命令的列表。&lt;/p>
&lt;h2 id="2-shell-变量">2. Shell 变量&lt;/h2>
&lt;p>变量是我们为其分配值的字符串，变量的值包括数字，文本，文件名，设备，或是任意的数据类型。变量只是实际数据的一个指针，我们可以创建，赋值，删除变量。&lt;/p>
&lt;h3 id="21-变量类型">2.1 变量类型&lt;/h3>
&lt;p>当Shell运行时，存在三种主要类型的变量：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>局部变量&lt;/strong>：局部变量是存在于Shell当前实例中的变量。它不适用于由 Shell 启动的程序。它们在命令提示符下设置。&lt;/li>
&lt;li>&lt;strong>环境变量&lt;/strong>：环境变量可用于Shell的任何子进程。某些程序需要环境变量才能正常运行。通常，shell脚本仅定义其运行的程序所需的那些环境变量。&lt;/li>
&lt;li>&lt;strong>Shell变量&lt;/strong>：Shell变量是Shell设置的特殊变量，shell要求Shell变量才能正常运行。这些变量中的一些是环境变量，而另一些是局部变量。&lt;/li>
&lt;/ul>
&lt;h3 id="22-变量名">2.2 变量名&lt;/h3>
&lt;p>变量名称只能包含字母（a到z或A到Z），数字（0到9）或下划线字符（_）。按照约定，Unix shell变量将以大写字母命名。
下面的例子是一些有效和无效的变量名：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="c1"># valid variable names&lt;/span>
&lt;span class="ln"> 4&lt;/span>_ALL
&lt;span class="ln"> 5&lt;/span>TOKEN_A
&lt;span class="ln"> 6&lt;/span>VAR_1
&lt;span class="ln"> 7&lt;/span>VAR_2
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="c1"># invaild variable names&lt;/span>
&lt;span class="ln">10&lt;/span>2_VAR
&lt;span class="ln">11&lt;/span>-VARIABLE
&lt;span class="ln">12&lt;/span>VAR1-VAR2
&lt;span class="ln">13&lt;/span>VAR_A!
&lt;span class="ln">14&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在shell 中，&lt;strong>&lt;code>!, *, -&lt;/code>&lt;/strong> 是含有特殊意义的，因此不能在变量名中使用。&lt;/p>
&lt;h3 id="23-定义变量">2.3 定义变量&lt;/h3>
&lt;p>变量的定义方式如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">variable_name&lt;/span>&lt;span class="o">=&lt;/span>variable_value
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>注意，&lt;strong>&lt;code>=&lt;/code>&lt;/strong> 号两边不能有空格。&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Zara Ali&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个例子中定义了一个变量，并给这个变量赋值，这种变量的类型称为&lt;strong>标量&lt;/strong>， 标量只一次只能有一个值。&lt;/p>
&lt;h3 id="24-使用变量">2.4 使用变量&lt;/h3>
&lt;p>Shell 中通过 &lt;strong>&lt;code>$&lt;/code>&lt;/strong> 符号获取变量的值。例如，下面的例子将获取变量&lt;code>NAME&lt;/code>的值并将其打印在标准输出中：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Zara Ali&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$NAME&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="25-只读变量">2.5 只读变量&lt;/h3>
&lt;p>Shell 允许通过 &lt;strong>&lt;code>readonly&lt;/code>&lt;/strong> 命令将一个变量变成只读变量。当变量成为只读变量后，它的值就不能更改了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Zara Ali&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">readonly&lt;/span> NAME
&lt;span class="ln">5&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Qadiri&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的脚本会发生错误。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>/bin/sh: NAME: This variable is &lt;span class="nb">read&lt;/span> only.
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="26-重置变量">2.6 重置变量&lt;/h3>
&lt;p>重置或删除变量将指示Shell程序从其跟踪的变量列表中删除该变量。重置变量后，将无法访问该变量中的存储值。
以下是使用 &lt;strong>&lt;code>unset&lt;/code>&lt;/strong> 命令取消定义的变量的语法：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">unset&lt;/span> variable_name
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的命令重置定义的变量的值，下面的这个例子简单说明这个命令是如何工作的：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Zara Ali&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">unset&lt;/span> NAME
&lt;span class="ln">5&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$NAME&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子不会打印出任何内容，你可以使用 &lt;strong>&lt;code>unset&lt;/code>&lt;/strong> 命令来重置被标记为 &lt;strong>&lt;code>readonly&lt;/code>&lt;/strong> 的变量。&lt;/p>
&lt;h2 id="3-特殊变量">3. 特殊变量&lt;/h2>
&lt;p>在上一节中，我们了解了在变量名称中使用某些非字母数字字符时应注意的事项。这是因为这些字符用在特殊的Unix变量的名称中。这些变量保留用于特定功能。&lt;/p>
&lt;p>下面的表格列出了可以在我们的脚本中使用的特殊变量：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>变量&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>$0&lt;/code>&lt;/strong>&lt;/td>
&lt;td>当前脚本的文件名&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>$n&lt;/code>&lt;/strong>&lt;/td>
&lt;td>这个变量对应于调用脚本的参数。其中参数 &lt;strong>n&lt;/strong> 是正整数，代表参数的位置。例如第一个参数就是 &lt;code>$1&lt;/code> ， 第二个参数就是 &lt;code>$2&lt;/code>， 以此类推。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>$#&lt;/code>&lt;/strong>&lt;/td>
&lt;td>脚本参数的数量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>$*&lt;/code>&lt;/strong>&lt;/td>
&lt;td>输出整个参数列表，将整个列表作为一个参数，且之间使用空格隔开。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>$@&lt;/code>&lt;/strong>&lt;/td>
&lt;td>与&lt;code>$*&lt;/code> 的作用是一致的，不同的是该变量输出时会将参数列表分成单独的参数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>$$&lt;/code>&lt;/strong>&lt;/td>
&lt;td>当前shell的进程号。对于Shell脚本，这是它们执行时的进程ID。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>$!&lt;/code>&lt;/strong>&lt;/td>
&lt;td>最后一个后台命令的进程号。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>以下脚本使用与命令行相关的各种特殊变量:&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/sh
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;File Name: &lt;/span>&lt;span class="nv">$0&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;First Parameter : &lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Second Parameter : &lt;/span>&lt;span class="nv">$2&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Quoted Values: &lt;/span>&lt;span class="nv">$@&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Quoted Values: &lt;/span>&lt;span class="nv">$*&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">8&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Total Number of Parameters : &lt;/span>&lt;span class="nv">$#&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$./test.sh Zara Ali
&lt;span class="ln">2&lt;/span>File Name : ./test.sh
&lt;span class="ln">3&lt;/span>First Parameter : Zara
&lt;span class="ln">4&lt;/span>Second Parameter : Ali
&lt;span class="ln">5&lt;/span>Quoted Values: Zara Ali
&lt;span class="ln">6&lt;/span>Quoted Values: Zara Ali
&lt;span class="ln">7&lt;/span>Total Number of Parameters : &lt;span class="m">2&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="31-错误状态">3.1 错误状态&lt;/h3>
&lt;p>&lt;strong>&lt;code>$?&lt;/code>&lt;/strong> 变量表示上一个命令的退出状态。
退出状态是每个命令完成后返回的数值。通常，如果大多数命令成功，则返回退出状态0；如果不成功，则返回1。
某些命令出于特殊原因会返回其他退出状态。例如，某些命令区分错误的种类，并将根据故障的特定类型返回各种退出值。&lt;/p>
&lt;p>下面的这个例子返回的是成功命令的状态：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$./test.sh Zara Ali
&lt;span class="ln"> 2&lt;/span>File Name : ./test.sh
&lt;span class="ln"> 3&lt;/span>First Parameter : Zara
&lt;span class="ln"> 4&lt;/span>Second Parameter : Ali
&lt;span class="ln"> 5&lt;/span>Quoted Values: Zara Ali
&lt;span class="ln"> 6&lt;/span>Quoted Values: Zara Ali
&lt;span class="ln"> 7&lt;/span>Total Number of Parameters : &lt;span class="m">2&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="nv">$echo&lt;/span> &lt;span class="nv">$?&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="m">0&lt;/span>
&lt;span class="ln">11&lt;/span>$
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-数组">4. 数组&lt;/h2>
&lt;p>Shell变量足以容纳单个值。这些变量称为标量变量。&lt;/p>
&lt;p>Shell支持另一种类型的变量，称为&lt;strong>数组变量&lt;/strong>。它可以同时保存多个值。数组提供了一种对一组变量进行分组的方法。数组的命名参考变量的命名规则。&lt;/p>
&lt;h3 id="41-定义数组">4.1 定义数组&lt;/h3>
&lt;p>数组变量和标量变量之间的差异可以解释如下。
假设您尝试将各个学生的姓名表示为一组变量。每个单独的变量都是标量变量，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="nv">NAME01&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Zara&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">NAME02&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Qadir&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nv">NAME03&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Mahnaz&amp;#34;&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nv">NAME04&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Ayan&amp;#34;&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="nv">NAME05&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Daisy&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以使用单个数组来存储所有上述名称。以下是创建数组变量的最简单方法。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>array_name&lt;span class="o">[&lt;/span>index&lt;span class="o">]=&lt;/span>value
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里 &lt;em>array_name&lt;/em> 是数组的名字，&lt;em>index&lt;/em> 是要设置的数组中的索引， &lt;em>value&lt;/em> 就是你要为该元素设置的值。如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln">3&lt;/span>NAME&lt;span class="o">[&lt;/span>0&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Zara&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>NAME&lt;span class="o">[&lt;/span>1&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Qadir&amp;#34;&lt;/span>
&lt;span class="ln">5&lt;/span>NAME&lt;span class="o">[&lt;/span>2&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Mahnaz&amp;#34;&lt;/span>
&lt;span class="ln">6&lt;/span>NAME&lt;span class="o">[&lt;/span>3&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Ayan&amp;#34;&lt;/span>
&lt;span class="ln">7&lt;/span>NAME&lt;span class="o">[&lt;/span>4&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Daisy&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果使用的是 &lt;strong>bash shell&lt;/strong> ，也可以通过以下这种方法进行数组初始化：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">array_name&lt;/span>&lt;span class="o">=(&lt;/span>value1 ... valuen&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="42-使用数组">4.2 使用数组&lt;/h3>
&lt;p>为变量赋值之后，访问变量可以使用以下方式：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">array_name&lt;/span>&lt;span class="p">[index]&lt;/span>&lt;span class="si">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里 &lt;em>array_name&lt;/em> 是数组名， &lt;em>index&lt;/em> 是要访问那个数组项的索引。具体的例子如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">&lt;/span>NAME&lt;span class="o">[&lt;/span>0&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Zara&amp;#34;&lt;/span>
&lt;span class="ln"> 3&lt;/span>NAME&lt;span class="o">[&lt;/span>1&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Qadir&amp;#34;&lt;/span>
&lt;span class="ln"> 4&lt;/span>NAME&lt;span class="o">[&lt;/span>2&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Mahnaz&amp;#34;&lt;/span>
&lt;span class="ln"> 5&lt;/span>NAME&lt;span class="o">[&lt;/span>3&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Ayan&amp;#34;&lt;/span>
&lt;span class="ln"> 6&lt;/span>NAME&lt;span class="o">[&lt;/span>4&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Daisy&amp;#34;&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;First Index: &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="p">[0]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Second Index: &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="p">[1]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;First Method: &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="p">[*]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Second Method: &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$./test.sh
&lt;span class="ln">2&lt;/span>First Index: Zara
&lt;span class="ln">3&lt;/span>Second Index: Qadir
&lt;span class="ln">4&lt;/span>First Method: Zara Qadir Mahnaz Ayan Daisy
&lt;span class="ln">5&lt;/span>Second Method: Zara Qadir Mahnaz Ayan Daisy
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的示例中通过 &lt;strong>&lt;code>*&lt;/code>&lt;/strong> 和 &lt;strong>&lt;code>@&lt;/code>&lt;/strong> 来获取整个数组的值。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">array_name&lt;/span>&lt;span class="p">[*]&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">array_name&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5-运算符">5. 运算符&lt;/h2>
&lt;p>每个Shell都支持不同的运算符，这里我们主要讨论的是 bash shell 的运算符。&lt;/p>
&lt;h3 id="51-算术运算符">5.1 算术运算符&lt;/h3>
&lt;p>&lt;strong>Bourne shell&lt;/strong> 最初没有任何执行简单算术运算的机制，它使用 &lt;em>awk&lt;/em> 或 &lt;em>expr&lt;/em> 来进行计算。如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/sh
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">val&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="sb">`&lt;/span>expr &lt;span class="m">2&lt;/span> + 2&lt;span class="sb">`&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Total value : &lt;/span>&lt;span class="nv">$val&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>Total value : &lt;span class="m">4&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子我们需要注意的有两点：&lt;/p>
&lt;ul>
&lt;li>表达式和运算符之间必须用空格隔开，例如 &lt;code>2+2&lt;/code> 是错误的，应该写成 &lt;code>2 + 2&lt;/code>&lt;/li>
&lt;li>整个表达式要用反引号 `` 来包起来。&lt;/li>
&lt;/ul>
&lt;p>假设变量 &lt;strong>a&lt;/strong> 等于 10， 变量 &lt;strong>b&lt;/strong> 等于 20， 我们来看一下 &lt;strong>bash shell&lt;/strong> 支持的算术运算符是如何计算这两个值得：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>+&lt;/strong>&lt;/td>
&lt;td>&lt;code>expr $a + $b&lt;/code> = 30&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>-&lt;/strong>&lt;/td>
&lt;td>&lt;code>expr $a - $b&lt;/code> = -10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>*&lt;/code>&lt;/strong>&lt;/td>
&lt;td>&lt;code>expr $a \* $b&lt;/code> = 200&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>/&lt;/strong>&lt;/td>
&lt;td>&lt;code>expr $b / $a&lt;/code> = 2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>%&lt;/strong>&lt;/td>
&lt;td>&lt;code>expr $b % $a&lt;/code> = 0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>=&lt;/strong>&lt;/td>
&lt;td>&lt;code>a = $b&lt;/code> 将b的值赋给a&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>==&lt;/strong>&lt;/td>
&lt;td>&lt;code>[ $a == $b ]&lt;/code> 将会返回 false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>！=&lt;/strong>&lt;/td>
&lt;td>&lt;code>[ $a != $b ]&lt;/code>将会返回 true&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>注意：&lt;code>[ $a == $b ]&lt;/code> 不能写成&lt;code> [$a==$b]&lt;/code>。&lt;/em>&lt;/p>
&lt;h3 id="52-关系运算符">5.2 关系运算符&lt;/h3>
&lt;p>Bash 支持以下特定于数值的关系运算符。
假设变量a = 10，变量b = 20,&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>例子&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>-eq&lt;/strong>&lt;/td>
&lt;td>检查运算符两边的值是否相等，相等返回 true&lt;/td>
&lt;td>&lt;code>[ $a -eq $b ] is not true.&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>-ne&lt;/strong>&lt;/td>
&lt;td>检查运算符两边的值是否相等，不相等返回 true&lt;/td>
&lt;td>&lt;code>[ $a -ne $b ] is true&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>-gt&lt;/strong>&lt;/td>
&lt;td>&lt;strong>gt&lt;/strong> 是 &lt;strong>greater than&lt;/strong> 的缩写，检查运算符左边的值是否大于右边，是的话返回 true&lt;/td>
&lt;td>&lt;code>[ $a -gt $b ] is not true&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>-lt&lt;/strong>&lt;/td>
&lt;td>&lt;strong>lt&lt;/strong> 是 &lt;strong>less than&lt;/strong> 的缩写，检查运算符左边的值是否小于右边，是的话返回true&lt;/td>
&lt;td>&lt;code>[ $a -lt $b ] is true&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>-ge&lt;/strong>&lt;/td>
&lt;td>&lt;strong>ge&lt;/strong> 是 &lt;strong>greater than or equal&lt;/strong> 的缩写，检查运算符左边的值是否大于或等于右边的值，是的话返回true&lt;/td>
&lt;td>&lt;code>[ $a -ge $b ] is not true&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>-le&lt;/strong>&lt;/td>
&lt;td>&lt;strong>le&lt;/strong> 是 &lt;strong>less than or equal&lt;/strong> 的缩写，检查运算符左边的值是否小于或等于右边的值，是的话返回true&lt;/td>
&lt;td>&lt;code>[ $a -le $b ] is true&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>注意：所有条件表达式应放在方括号内并在其周围留有空格。&lt;/em>&lt;/p>
&lt;h3 id="53-布尔运算符">5.3 布尔运算符&lt;/h3>
&lt;p>Bash 支持以下布尔运算符。假设变量 &lt;strong>a&lt;/strong> 的值是 10， 变量 &lt;strong>b&lt;/strong> 的值是20：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>！&lt;/strong>&lt;/td>
&lt;td>逻辑否。这会将真实条件转换为错误条件，反之亦然。&lt;/td>
&lt;td>&lt;code>[ ! false ] is true.&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>-o&lt;/strong>&lt;/td>
&lt;td>逻辑或。如果运算符两边之一为真，则条件为真。&lt;/td>
&lt;td>&lt;code>[ $a -lt 20 -o $b -gt 100 ] is true.&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>-a&lt;/strong>&lt;/td>
&lt;td>逻辑与。如果运算符两边都是真的，则条件为真。&lt;/td>
&lt;td>&lt;code>[ $a -lt 20 -a $b -gt 100 ] is false.&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="54-字符串运算符">5.4 字符串运算符&lt;/h3>
&lt;p>Bash 运算符支持以下操作。
假设变量 &lt;strong>a&lt;/strong> 的值为 &amp;quot;abc&amp;quot;，变量&lt;strong>b&lt;/strong>的值为 &amp;quot;efg&amp;quot;：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>=&lt;/strong>&lt;/td>
&lt;td>检查运算符两边的值是否相等；如果是，则条件变为真。&lt;/td>
&lt;td>&lt;code>[ $a = $b ] is not true.&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>!=&lt;/strong>&lt;/td>
&lt;td>检查运算符两边的值是否相等；如果值不相等，则条件为真&lt;/td>
&lt;td>&lt;code>[ $a != $b ] is true.&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>-z&lt;/strong>&lt;/td>
&lt;td>检查给定的字符串操作数大小是否为零；如果长度为零，则返回true。&lt;/td>
&lt;td>&lt;code>[ -z $a ] is not true.&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>-n&lt;/strong>&lt;/td>
&lt;td>检查给定的字符串操作数大小是否为非零；如果长度非零，则返回true。&lt;/td>
&lt;td>&lt;code>[ -n $a ] is not false.&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>str&lt;/strong>&lt;/td>
&lt;td>Checks if str is not the empty string; if it is empty, then it returns false.&lt;/td>
&lt;td>&lt;code>[ $a ] is not false.&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="55-文件测试运算符">5.5 文件测试运算符&lt;/h3>
&lt;p>我们有一些运算符可用于测试与文件相关的各种属性。
假设有个文件变量 &lt;strong>file&lt;/strong> 的值为一个存在的名为 &amp;quot;test&amp;quot; 的文件，该文件的大小为100bytes，并且有读写和执行的权限。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">运算符&lt;/th>
&lt;th style="text-align:center">描述&lt;/th>
&lt;th style="text-align:right">示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-b file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检查文件是否是一个块文件，如果是就返回true。&lt;/td>
&lt;td style="text-align:right">[ -b $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-c file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件是否是字符设备文件，如果是，则返回 true。&lt;/td>
&lt;td style="text-align:right">[ -c $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-d file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件是否是目录，如果是，则返回 true。&lt;/td>
&lt;td style="text-align:right">[ -d $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-f file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。&lt;/td>
&lt;td style="text-align:right">[ -f $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-g file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件是否设置了 SGID 位，如果是，则返回 true。&lt;/td>
&lt;td style="text-align:right">[ -g $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-k file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。&lt;/td>
&lt;td style="text-align:right">[ -k $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-p file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件是否是有名管道，如果是，则返回 true。&lt;/td>
&lt;td style="text-align:right">[ -p $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-t file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检查文件描述符是否打开并与终端关联；如果是，则条件变为真。&lt;/td>
&lt;td style="text-align:right">[ -t $file ] is false.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-u file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件是否设置了 SUID 位，如果是，则返回 true。&lt;/td>
&lt;td style="text-align:right">[ -u $file ] 返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-r file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件是否可读，如果是，则返回 true。&lt;/td>
&lt;td style="text-align:right">[ -r $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-w file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件是否可写，如果是，则返回 true。&lt;/td>
&lt;td style="text-align:right">[ -w $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-x file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件是否可执行，如果是，则返回 true。&lt;/td>
&lt;td style="text-align:right">[ -x $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-s file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件是否为空（文件大小是否大于0），不为空返回 true。&lt;/td>
&lt;td style="text-align:right">[ -s $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>-e file&lt;/strong>&lt;/td>
&lt;td style="text-align:center">检测文件（包括目录）是否存在，如果是，则返回 true。&lt;/td>
&lt;td style="text-align:right">[ -e $file ] 返回 true。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="56-其他shell的运算符">5.6 其他shell的运算符&lt;/h3>
&lt;ul>
&lt;li>C Shell 运算符：&lt;a href="https://www.tutorialspoint.com/unix/unix-c-shell-operators.htm">C Shell Operators&lt;/a>&lt;/li>
&lt;li>Korn Shell 运算符：&lt;a href="https://www.tutorialspoint.com/unix/unix-korn-shell-operators.htm">Korn Shell Operators&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="6-条件表达式">6. 条件表达式&lt;/h2>
&lt;p>在编写shell脚本时，可能需要从给定的两个路径中采用一个路径。因此，您需要使用条件语句，这些条件语句允许您的程序做出正确的决定并执行正确的操作。&lt;/p>
&lt;h2 id="7-循环">7. 循环&lt;/h2>
&lt;p>循环是功能强大的编程工具，使您能够重复执行一组命令。在本章中，我们将研究以下可供Shell程序员使用的循环类型-&lt;/p>
&lt;ul>
&lt;li>while 循环&lt;/li>
&lt;li>for 循环&lt;/li>
&lt;li>until 循环&lt;/li>
&lt;li>select 循环&lt;/li>
&lt;/ul>
&lt;p>您将根据情况使用不同的循环。&lt;/p>
&lt;h3 id="71-嵌套循环">7.1 嵌套循环&lt;/h3>
&lt;p>所有循环都支持嵌套概念，这意味着您可以将一个循环放入另一个类似的或不同的循环中。根据您的要求，此嵌套最多可以无限次。&lt;/p>
&lt;p>这是嵌套while循环的示例。其他循环可以根据编程要求以类似的方式嵌套-&lt;/p>
&lt;p>可以将while循环用作另一个while循环主体的一部分。
语法：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="k">while&lt;/span> command1 &lt;span class="p">;&lt;/span> &lt;span class="c1"># this is loop1, the outer loop&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="k">do&lt;/span>
&lt;span class="ln"> 3&lt;/span> Statement&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span> to be executed &lt;span class="k">if&lt;/span> command1 is &lt;span class="nb">true&lt;/span>
&lt;span class="ln"> 4&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">while&lt;/span> command2 &lt;span class="p">;&lt;/span> &lt;span class="c1"># this is loop2, the inner loop&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln"> 7&lt;/span> Statement&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span> to be executed &lt;span class="k">if&lt;/span> command2 is &lt;span class="nb">true&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">done&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span> Statement&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span> to be executed &lt;span class="k">if&lt;/span> command1 is &lt;span class="nb">true&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>示例：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#!/bin/sh
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$a&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> -lt &lt;span class="m">10&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="c1"># this is loop1&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="k">do&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="nv">b&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$a&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$b&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> -ge &lt;span class="m">0&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="c1"># this is loop2&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="nb">echo&lt;/span> -n &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$b&lt;/span>&lt;span class="s2"> &amp;#34;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nv">b&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="sb">`&lt;/span>expr &lt;span class="nv">$b&lt;/span> - 1&lt;span class="sb">`&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">done&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="nb">echo&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="sb">`&lt;/span>expr &lt;span class="nv">$a&lt;/span> + 1&lt;span class="sb">`&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="m">0&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="m">2&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="m">3&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="m">4&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="m">5&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="m">6&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="m">7&lt;/span> &lt;span class="m">6&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="m">8&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">6&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="m">9&lt;/span> &lt;span class="m">8&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">6&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>20 常用的 RPM 命令</title><link>https://ahamoment.cn/post/linux-20-rpm-command/</link><pubDate>Tue, 02 Jun 2020 18:51:23 +0800</pubDate><guid>https://ahamoment.cn/post/linux-20-rpm-command/</guid><description>
&lt;blockquote>
&lt;p>本文翻译自&lt;a href="https://www.tecmint.com/20-practical-examples-of-rpm-commands-in-linux/">20 Practical Examples of RPM Commands in Linux&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>RMP (Red Hat Package Manager) 是一款 Red Hat 系统的开源包管理工具，支持安装、更新、卸载、查询、验证和管理系统软件包。RPM以前称为 .rpm 文件，文件内包含编译好的软件和包所需要的库。&lt;/p>
&lt;p>这篇文章主要介绍了 20 个常用的 RPM 命令。&lt;/p>
&lt;h3 id="关于-rpm-的一些常识">关于 RPM 的一些常识&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>RPM 是免费的，并且遵循 GPL 开源协议&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RPM 将所有已安装软件包的信息保存在 &lt;code>/var/lib/rpm&lt;/code> 数据库中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RPM 是在 Linux 系统下安装软件包的唯一方法，如果您使用源代码安装了软件包，则 rpm 将无法对其进行管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RPM 处理 .rpm 文件，其中包含有关软件包的实际信息，例如：它是什么，它来自哪里，软件依赖信息，版本信息等。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="rpm命令的五个基本模式">RPM命令的五个基本模式&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Install&lt;/strong> : 使用于安装任意的 RPM 包。&lt;/li>
&lt;li>&lt;strong>Remove&lt;/strong> ：用于擦除，删除或卸载任何 RPM 软件包。&lt;/li>
&lt;li>&lt;strong>Upgrade&lt;/strong> : 用于更新已经存在的 RPM 软件包。&lt;/li>
&lt;li>&lt;strong>Verify&lt;/strong> ：用来验证 RPM 软件包。&lt;/li>
&lt;li>&lt;strong>Query&lt;/strong>：用来查询 RPM 软件包。&lt;/li>
&lt;/ul>
&lt;h3 id="查找和下载-rpm-包">查找和下载 RPM 包&lt;/h3>
&lt;p>以下是rpm网站的列表，您可以在其中找到和下载所有RPM软件包。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://rpmfind.net/">http://rpmfind.net&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.redhat.com/">http://www.redhat.com&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://freshrpms.net/">http://freshrpms.net/&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://rpm.pbone.net/">http://rpm.pbone.net/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="1-检查-rpm-包的签名">1. 检查 RPM 包的签名&lt;/h3>
&lt;p>在将软件包安装在Linux系统上之前，先检查软件包的 PGP 签名，并确保其完整性和来源是正确的。使用 &lt;strong>–-checksig&lt;/strong> (&lt;strong>check signature&lt;/strong>) 命令检查 RPM 包的签名。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@tecmint&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm --checksig pidgin-2.7.9-5.el6.2.i686.rpm&lt;/span>
&lt;span class="ln">2&lt;/span>
&lt;span class="ln">3&lt;/span>pidgin-2.7.9-5.el6.2.i686.rpm: rsa sha1 &lt;span class="o">(&lt;/span>md5&lt;span class="o">)&lt;/span> pgp md5 OK
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-安装-rpm-包">2. 安装 RPM 包&lt;/h3>
&lt;p>使用 &lt;strong>-i&lt;/strong> 选项安装 RPM 包&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -ivh tree-1.6.0-10.el7.x86_64.rpm&lt;/span>
&lt;span class="ln">2&lt;/span>准备中... &lt;span class="c1">################################# [100%]&lt;/span>
&lt;span class="ln">3&lt;/span>正在升级/安装...
&lt;span class="ln">4&lt;/span> 1:tree-1.6.0-10.el7 &lt;span class="c1">################################# [100%]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>RPM 命令和选项&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>-i&lt;/strong> : 安装包&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>-v :&lt;/strong> 详细显示&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>-h&lt;/strong> 在打包归档文件解压缩时打印哈希标记。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="3-安装-rpm-包之前检查包依赖">3. 安装 RPM 包之前检查包依赖&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -qpR tree-1.6.0-10.el7.x86_64.rpm&lt;/span>
&lt;span class="ln"> 2&lt;/span>libc.so.6&lt;span class="o">()(&lt;/span>64bit&lt;span class="o">)&lt;/span>
&lt;span class="ln"> 3&lt;/span>libc.so.6&lt;span class="o">(&lt;/span>GLIBC_2.14&lt;span class="o">)(&lt;/span>64bit&lt;span class="o">)&lt;/span>
&lt;span class="ln"> 4&lt;/span>libc.so.6&lt;span class="o">(&lt;/span>GLIBC_2.2.5&lt;span class="o">)(&lt;/span>64bit&lt;span class="o">)&lt;/span>
&lt;span class="ln"> 5&lt;/span>libc.so.6&lt;span class="o">(&lt;/span>GLIBC_2.3&lt;span class="o">)(&lt;/span>64bit&lt;span class="o">)&lt;/span>
&lt;span class="ln"> 6&lt;/span>libc.so.6&lt;span class="o">(&lt;/span>GLIBC_2.3.4&lt;span class="o">)(&lt;/span>64bit&lt;span class="o">)&lt;/span>
&lt;span class="ln"> 7&lt;/span>libc.so.6&lt;span class="o">(&lt;/span>GLIBC_2.4&lt;span class="o">)(&lt;/span>64bit&lt;span class="o">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>rpmlib&lt;span class="o">(&lt;/span>CompressedFileNames&lt;span class="o">)&lt;/span> &amp;lt;&lt;span class="o">=&lt;/span> 3.0.4-1
&lt;span class="ln"> 9&lt;/span>rpmlib&lt;span class="o">(&lt;/span>FileDigests&lt;span class="o">)&lt;/span> &amp;lt;&lt;span class="o">=&lt;/span> 4.6.0-1
&lt;span class="ln">10&lt;/span>rpmlib&lt;span class="o">(&lt;/span>PayloadFilesHavePrefix&lt;span class="o">)&lt;/span> &amp;lt;&lt;span class="o">=&lt;/span> 4.0-1
&lt;span class="ln">11&lt;/span>rtld&lt;span class="o">(&lt;/span>GNU_HASH&lt;span class="o">)&lt;/span>
&lt;span class="ln">12&lt;/span>rpmlib&lt;span class="o">(&lt;/span>PayloadIsXz&lt;span class="o">)&lt;/span> &amp;lt;&lt;span class="o">=&lt;/span> 5.2-1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>命令和选项说明：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-q :&lt;/strong> 查询一个包&lt;/li>
&lt;li>&lt;strong>-p:&lt;/strong> 列出此软件包提供的功能。&lt;/li>
&lt;li>&lt;strong>-R:&lt;/strong> 列出此程序包所依赖的功能。&lt;/li>
&lt;/ul>
&lt;h3 id="4-忽略依赖安装-rpm-包">4. 忽略依赖安装 RPM 包&lt;/h3>
&lt;p>如果已经知道所有必需的软件包都已安装，那么可以在安装软件包之前使用 &lt;strong>-–nodeps(no dependencies check)&lt;/strong> 选项来忽略那些依赖项。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -ivh --nodeps tree-1.6.0-10.el7.x86_64.rpm&lt;/span>
&lt;span class="ln">2&lt;/span>准备中... &lt;span class="c1">################################# [100%]&lt;/span>
&lt;span class="ln">3&lt;/span> 软件包 tree-1.6.0-10.el7.x86_64 已经安装
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的命令通过忽略依赖项错误来强制安装rpm软件包，但是如果缺少那些依赖项文件会导致程序将无法运行。&lt;/p>
&lt;h3 id="5-查找一个已经安装的-rpm-包">5. 查找一个已经安装的 RPM 包&lt;/h3>
&lt;p>在软件包名称中使用 &lt;strong>-q&lt;/strong> 选项，将显示是否已安装 rpm 包。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -q tree&lt;/span>
&lt;span class="ln">2&lt;/span>tree-1.6.0-10.el7.x86_64
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="6-列出已安装的rpm软件包的所有文件">6. 列出已安装的RPM软件包的所有文件&lt;/h3>
&lt;p>要查看已安装的rpm软件包的所有文件，请使用 &lt;strong>-ql（query list）&lt;/strong> rpm 命令。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -ql tree&lt;/span>
&lt;span class="ln">2&lt;/span>/usr/bin/tree
&lt;span class="ln">3&lt;/span>/usr/share/doc/tree-1.6.0
&lt;span class="ln">4&lt;/span>/usr/share/doc/tree-1.6.0/LICENSE
&lt;span class="ln">5&lt;/span>/usr/share/doc/tree-1.6.0/README
&lt;span class="ln">6&lt;/span>/usr/share/man/man1/tree.1.gz
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="7-列出最近安装的-rpm-包">7. 列出最近安装的 RPM 包&lt;/h3>
&lt;p>使用 &lt;strong>-qa(query all)&lt;/strong> 命令，会列出最近安装的所有 RPM 包&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -qa --last&lt;/span>
&lt;span class="ln"> 2&lt;/span>tree-1.6.0-10.el7.x86_64 2020年06月01日 星期一 19时04分28秒
&lt;span class="ln"> 3&lt;/span>perl-Git-1.8.3.1-22.el7_8.noarch 2020年06月01日 星期一 14时18分37秒
&lt;span class="ln"> 4&lt;/span>git-1.8.3.1-22.el7_8.x86_64 2020年06月01日 星期一 14时18分36秒
&lt;span class="ln"> 5&lt;/span>perl-TermReadKey-2.30-20.el7.x86_64 2020年06月01日 星期一 14时18分34秒
&lt;span class="ln"> 6&lt;/span>rsync-3.1.2-10.el7.x86_64 2020年06月01日 星期一 14时18分33秒
&lt;span class="ln"> 7&lt;/span>perl-Error-0.17020-2.el7.noarch 2020年06月01日 星期一 14时18分33秒
&lt;span class="ln"> 8&lt;/span>nux-dextop-release-0-5.el7.nux.noarch 2020年05月22日 星期五 19时40分35秒
&lt;span class="ln"> 9&lt;/span>gpg-pubkey-85c6cd8a-4e060c35 2020年05月22日 星期五 19时40分19秒
&lt;span class="ln">10&lt;/span>epel-release-7-11.noarch 2020年05月22日 星期五 19时39分27秒
&lt;span class="ln">11&lt;/span>libtirpc-0.2.4-0.16.el7.x86_64 2020年05月22日 星期五 18时58分40秒
&lt;span class="ln">12&lt;/span>vim-enhanced-7.4.629-6.el7.x86_64 2020年05月22日 星期五 17时48分48秒
&lt;span class="ln">13&lt;/span>vim-common-7.4.629-6.el7.x86_64 2020年05月22日 星期五 17时48分48秒
&lt;span class="ln">14&lt;/span>vim-filesystem-7.4.629-6.el7.x86_64 2020年05月22日 星期五 17时48分44秒
&lt;span class="ln">15&lt;/span>...
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="8-列出所有已安装的-rpm-包">8. 列出所有已安装的 RPM 包&lt;/h3>
&lt;p>键入以下命令以打印Linux系统上已安装软件包的所有名称。该命令和 grep 一起使用，即可搜索到我们是否安装过某个包，例如 &lt;code>rpm -qa | grep git&lt;/code>，查看我们是否安装过 git 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -qa&lt;/span>
&lt;span class="ln"> 2&lt;/span>kexec-tools-2.0.15-43.el7.x86_64
&lt;span class="ln"> 3&lt;/span>grub2-common-2.02-0.81.el7.centos.noarch
&lt;span class="ln"> 4&lt;/span>openssh-clients-7.4p1-21.el7.x86_64
&lt;span class="ln"> 5&lt;/span>setup-2.8.71-11.el7.noarch
&lt;span class="ln"> 6&lt;/span>authconfig-6.2.8-30.el7.x86_64
&lt;span class="ln"> 7&lt;/span>basesystem-10.0-7.el7.centos.noarch
&lt;span class="ln"> 8&lt;/span>postfix-2.10.1-9.el7.x86_64
&lt;span class="ln"> 9&lt;/span>ncurses-base-5.9-14.20130511.el7_4.noarch
&lt;span class="ln">10&lt;/span>kbd-1.15.5-15.el7.x86_64
&lt;span class="ln">11&lt;/span>kbd-misc-1.15.5-15.el7.noarch
&lt;span class="ln">12&lt;/span>qemu-guest-agent-2.12.0-3.el7.x86_64
&lt;span class="ln">13&lt;/span>...
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="9-更新-rpm-包">9. 更新 RPM 包&lt;/h3>
&lt;p>使用 &lt;strong>-U(upgrade)&lt;/strong> 选项来升级 RPM 包。该命令不仅会将某个 rpm 包升级到最新版本，而且还会维护旧软件包的备份，以便在新的升级软件包不能使用的时候还能使用旧的 RPM 包。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -Uvh tree-1.6.0-10.el7.x86_64.rpm&lt;/span>
&lt;span class="ln">2&lt;/span>准备中... &lt;span class="c1">################################# [100%]&lt;/span>
&lt;span class="ln">3&lt;/span> 软件包 tree-1.6.0-10.el7.x86_64 已经安装
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="10-删除-rpm-包">10. 删除 RPM 包&lt;/h3>
&lt;p>使用 &lt;strong>-e (erase)&lt;/strong> 命令来移除已安装的 rpm 包。如果要移除的 RPM 包不存在，就会有错误提示。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -evv tree&lt;/span>
&lt;span class="ln"> 2&lt;/span>D: loading keyring from pubkeys in /var/lib/rpm/pubkeys/*.key
&lt;span class="ln"> 3&lt;/span>D: couldn&lt;span class="err">&amp;#39;&lt;/span>t find any keys in /var/lib/rpm/pubkeys/*.key
&lt;span class="ln"> 4&lt;/span>D: loading keyring from rpmdb
&lt;span class="ln"> 5&lt;/span>D: opening db environment /var/lib/rpm cdb:0x401
&lt;span class="ln"> 6&lt;/span>D: opening db index /var/lib/rpm/Packages 0x400 &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x0
&lt;span class="ln"> 7&lt;/span>D: locked db index /var/lib/rpm/Packages
&lt;span class="ln"> 8&lt;/span>D: opening db index /var/lib/rpm/Name 0x400 &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x0
&lt;span class="ln"> 9&lt;/span>D: &lt;span class="nb">read&lt;/span> h# &lt;span class="m">302&lt;/span> 头 SHA1 摘要： OK &lt;span class="o">(&lt;/span>489efff35e604042709daf46fb78611fe90a75aa&lt;span class="o">)&lt;/span>
&lt;span class="ln">10&lt;/span>D: added key gpg-pubkey-f4a80eb5-53a7ff4b to keyring
&lt;span class="ln">11&lt;/span>D: &lt;span class="nb">read&lt;/span> h# &lt;span class="m">371&lt;/span> 头 SHA1 摘要： OK &lt;span class="o">(&lt;/span>052c9c3b53cea0014763d9f82c173a87dc743eea&lt;span class="o">)&lt;/span>
&lt;span class="ln">12&lt;/span>D: added key gpg-pubkey-85c6cd8a-4e060c35 to keyring
&lt;span class="ln">13&lt;/span>D: Using legacy gpg-pubkey&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span> from rpmdb
&lt;span class="ln">14&lt;/span>D: &lt;span class="nb">read&lt;/span> h# &lt;span class="m">380&lt;/span> 头V3 RSA/SHA256 Signature, 密钥 ID f4a80eb5: OK
&lt;span class="ln">15&lt;/span>D: opening db index /var/lib/rpm/Conflictname 0x400 &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x0
&lt;span class="ln">16&lt;/span>D: &lt;span class="o">==========&lt;/span> --- tree-1.6.0-10.el7 x86_64/linux 0x2
&lt;span class="ln">17&lt;/span>D: opening db index /var/lib/rpm/Requirename 0x400 &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x0
&lt;span class="ln">18&lt;/span>D: &lt;span class="o">==========&lt;/span> recording tsort relations
&lt;span class="ln">19&lt;/span>D: &lt;span class="o">==========&lt;/span> tsorting packages &lt;span class="o">(&lt;/span>order, &lt;span class="c1">#predecessors, #succesors, depth)&lt;/span>
&lt;span class="ln">20&lt;/span>D: &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">1&lt;/span> -tree-1.6.0-10.el7.x86_64
&lt;span class="ln">21&lt;/span>D: erasing packages
&lt;span class="ln">22&lt;/span>D: closed db index /var/lib/rpm/Conflictname
&lt;span class="ln">23&lt;/span>D: closed db index /var/lib/rpm/Requirename
&lt;span class="ln">24&lt;/span>D: closed db index /var/lib/rpm/Name
&lt;span class="ln">25&lt;/span>D: closed db index /var/lib/rpm/Packages
&lt;span class="ln">26&lt;/span>D: closed db environment /var/lib/rpm
&lt;span class="ln">27&lt;/span>D: opening db environment /var/lib/rpm cdb:0x401
&lt;span class="ln">28&lt;/span>D: opening db index /var/lib/rpm/Packages &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">29&lt;/span>D: sanity checking &lt;span class="m">1&lt;/span> elements
&lt;span class="ln">30&lt;/span>D: running pre-transaction scripts
&lt;span class="ln">31&lt;/span>D: computing &lt;span class="m">5&lt;/span> file fingerprints
&lt;span class="ln">32&lt;/span>D: opening db index /var/lib/rpm/Name &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">33&lt;/span>D: opening db index /var/lib/rpm/Basenames &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">34&lt;/span>D: opening db index /var/lib/rpm/Group &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">35&lt;/span>D: opening db index /var/lib/rpm/Requirename &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">36&lt;/span>D: opening db index /var/lib/rpm/Providename &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">37&lt;/span>D: opening db index /var/lib/rpm/Conflictname &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">38&lt;/span>D: opening db index /var/lib/rpm/Obsoletename &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">39&lt;/span>D: opening db index /var/lib/rpm/Triggername &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">40&lt;/span>D: opening db index /var/lib/rpm/Dirnames &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">41&lt;/span>D: opening db index /var/lib/rpm/Installtid &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">42&lt;/span>D: opening db index /var/lib/rpm/Sigmd5 &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">43&lt;/span>D: opening db index /var/lib/rpm/Sha1header &lt;span class="o">(&lt;/span>none&lt;span class="o">)&lt;/span> &lt;span class="nv">mode&lt;/span>&lt;span class="o">=&lt;/span>0x42
&lt;span class="ln">44&lt;/span>软件包准备中...
&lt;span class="ln">45&lt;/span>D: computing file dispositions
&lt;span class="ln">46&lt;/span>D: 0x0000fd00 &lt;span class="m">4096&lt;/span> &lt;span class="m">9228841&lt;/span> &lt;span class="m">19356493&lt;/span> /
&lt;span class="ln">47&lt;/span>D: &lt;span class="o">==========&lt;/span> +++ tree-1.6.0-10.el7 x86_64-linux 0x2
&lt;span class="ln">48&lt;/span>D: &lt;span class="nb">read&lt;/span> h# &lt;span class="m">380&lt;/span> 头V3 RSA/SHA256 Signature, 密钥 ID f4a80eb5: OK
&lt;span class="ln">49&lt;/span>D: erase: tree-1.6.0-10.el7 has &lt;span class="m">5&lt;/span> files
&lt;span class="ln">50&lt;/span>tree-1.6.0-10.el7.x86_64
&lt;span class="ln">51&lt;/span>D: erase &lt;span class="m">100644&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="o">(&lt;/span> 0, 0&lt;span class="o">)&lt;/span> &lt;span class="m">4100&lt;/span> /usr/share/man/man1/tree.1.gz
&lt;span class="ln">52&lt;/span>D: erase &lt;span class="m">100644&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="o">(&lt;/span> 0, 0&lt;span class="o">)&lt;/span> &lt;span class="m">4628&lt;/span> /usr/share/doc/tree-1.6.0/README
&lt;span class="ln">53&lt;/span>D: erase &lt;span class="m">100644&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="o">(&lt;/span> 0, 0&lt;span class="o">)&lt;/span> &lt;span class="m">18009&lt;/span> /usr/share/doc/tree-1.6.0/LICENSE
&lt;span class="ln">54&lt;/span>D: erase &lt;span class="m">040755&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="o">(&lt;/span> 0, 0&lt;span class="o">)&lt;/span> &lt;span class="m">6&lt;/span> /usr/share/doc/tree-1.6.0
&lt;span class="ln">55&lt;/span>D: erase &lt;span class="m">100755&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="o">(&lt;/span> 0, 0&lt;span class="o">)&lt;/span> &lt;span class="m">62768&lt;/span> /usr/bin/tree
&lt;span class="ln">56&lt;/span>D: --- h# &lt;span class="m">380&lt;/span> tree-1.6.0-10.el7.x86_64
&lt;span class="ln">57&lt;/span>D: removing &lt;span class="s2">&amp;#34;tree&amp;#34;&lt;/span> from Name index.
&lt;span class="ln">58&lt;/span>D: removing &lt;span class="m">5&lt;/span> entries from Basenames index.
&lt;span class="ln">59&lt;/span>D: removing &lt;span class="s2">&amp;#34;Applications/File&amp;#34;&lt;/span> from Group index.
&lt;span class="ln">60&lt;/span>D: removing &lt;span class="m">11&lt;/span> entries from Requirename index.
&lt;span class="ln">61&lt;/span>D: removing &lt;span class="m">2&lt;/span> entries from Providename index.
&lt;span class="ln">62&lt;/span>D: removing &lt;span class="m">4&lt;/span> entries from Dirnames index.
&lt;span class="ln">63&lt;/span>D: removing &lt;span class="m">1&lt;/span> entries from Installtid index.
&lt;span class="ln">64&lt;/span>D: removing &lt;span class="m">1&lt;/span> entries from Sigmd5 index.
&lt;span class="ln">65&lt;/span>D: removing &lt;span class="s2">&amp;#34;a09f99f73ee3fe352489e734c63c32fa41b1be56&amp;#34;&lt;/span> from Sha1header index.
&lt;span class="ln">66&lt;/span>D: running post-transaction scripts
&lt;span class="ln">67&lt;/span>D: closed db index /var/lib/rpm/Sha1header
&lt;span class="ln">68&lt;/span>D: closed db index /var/lib/rpm/Sigmd5
&lt;span class="ln">69&lt;/span>D: closed db index /var/lib/rpm/Installtid
&lt;span class="ln">70&lt;/span>D: closed db index /var/lib/rpm/Dirnames
&lt;span class="ln">71&lt;/span>D: closed db index /var/lib/rpm/Triggername
&lt;span class="ln">72&lt;/span>D: closed db index /var/lib/rpm/Obsoletename
&lt;span class="ln">73&lt;/span>D: closed db index /var/lib/rpm/Conflictname
&lt;span class="ln">74&lt;/span>D: closed db index /var/lib/rpm/Providename
&lt;span class="ln">75&lt;/span>D: closed db index /var/lib/rpm/Requirename
&lt;span class="ln">76&lt;/span>D: closed db index /var/lib/rpm/Group
&lt;span class="ln">77&lt;/span>D: closed db index /var/lib/rpm/Basenames
&lt;span class="ln">78&lt;/span>D: closed db index /var/lib/rpm/Name
&lt;span class="ln">79&lt;/span>D: closed db index /var/lib/rpm/Packages
&lt;span class="ln">80&lt;/span>D: closed db environment /var/lib/rpm
&lt;span class="ln">81&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># echo $?&lt;/span>
&lt;span class="ln">82&lt;/span>&lt;span class="m">0&lt;/span>
&lt;span class="ln">83&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -e tree&lt;/span>
&lt;span class="ln">84&lt;/span>错误：未安装软件包 tree
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="11-忽略依赖地删除rpm-包">11. 忽略依赖地删除RPM 包&lt;/h3>
&lt;p>使用 &lt;strong>--nodeps (Do not check dependencies)&lt;/strong> 命令项强制从系统中删除 RPM 包。需要注意的是，删除特定的软件包可能会破坏其他正在运行的应用程序。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -ev --nodeps tree&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12-查看一个文件属于哪个-rpm-包">12. 查看一个文件属于哪个 RPM 包&lt;/h3>
&lt;p>假设有一个文件列表，并且想找出这些文件属于哪个 RPM 包的，那么可以使用 &lt;strong>-qf (query file)&lt;/strong> 命令。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -qf /usr/bin/tree&lt;/span>
&lt;span class="ln">2&lt;/span>tree-1.6.0-10.el7.x86_64
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="13-查看已安装的-rpm-包的信息">13. 查看已安装的 RPM 包的信息&lt;/h3>
&lt;p>使用 &lt;strong>-qi (query info)&lt;/strong> 命令查询想要知道的 rpm 包的信息。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -qi tree&lt;/span>
&lt;span class="ln"> 2&lt;/span>Name : tree
&lt;span class="ln"> 3&lt;/span>Version : 1.6.0
&lt;span class="ln"> 4&lt;/span>Release : 10.el7
&lt;span class="ln"> 5&lt;/span>Architecture: x86_64
&lt;span class="ln"> 6&lt;/span>Install Date: 2020年06月02日 星期二 19时05分24秒
&lt;span class="ln"> 7&lt;/span>Group : Applications/File
&lt;span class="ln"> 8&lt;/span>Size : &lt;span class="m">89505&lt;/span>
&lt;span class="ln"> 9&lt;/span>License : GPLv2+
&lt;span class="ln">10&lt;/span>Signature : RSA/SHA256, 2014年07月04日 星期五 13时36分46秒, Key ID 24c6a8a7f4a80eb5
&lt;span class="ln">11&lt;/span>Source RPM : tree-1.6.0-10.el7.src.rpm
&lt;span class="ln">12&lt;/span>Build Date : 2014年06月10日 星期二 03时28分53秒
&lt;span class="ln">13&lt;/span>Build Host : worker1.bsys.centos.org
&lt;span class="ln">14&lt;/span>Relocations : &lt;span class="o">(&lt;/span>not relocatable&lt;span class="o">)&lt;/span>
&lt;span class="ln">15&lt;/span>Packager : CentOS BuildSystem &amp;lt;http://bugs.centos.org&amp;gt;
&lt;span class="ln">16&lt;/span>Vendor : CentOS
&lt;span class="ln">17&lt;/span>URL : http://mama.indstate.edu/users/ice/tree/
&lt;span class="ln">18&lt;/span>Summary : File system tree viewer
&lt;span class="ln">19&lt;/span>Description :
&lt;span class="ln">20&lt;/span>The tree utility recursively displays the contents of directories in a
&lt;span class="ln">21&lt;/span>tree-like format. Tree is basically a UNIX port of the DOS tree
&lt;span class="ln">22&lt;/span>utility.
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="14-在安装之前获取-rpm-包的信息">14. 在安装之前获取 RPM 包的信息&lt;/h3>
&lt;p>假设你从网上下载了一个 rpm 包，并且想要在安装之前知道这个 rpm 包的信息，那么可以使用 &lt;strong>-qip (query info package)&lt;/strong> 这个命令来打印软件包的信息。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -qip python3-3.6.8-13.el7.x86_64.rpm&lt;/span>
&lt;span class="ln"> 2&lt;/span>Name : python3
&lt;span class="ln"> 3&lt;/span>Version : 3.6.8
&lt;span class="ln"> 4&lt;/span>Release : 13.el7
&lt;span class="ln"> 5&lt;/span>Architecture: x86_64
&lt;span class="ln"> 6&lt;/span>Install Date: &lt;span class="o">(&lt;/span>not installed&lt;span class="o">)&lt;/span>
&lt;span class="ln"> 7&lt;/span>Group : Unspecified
&lt;span class="ln"> 8&lt;/span>Size : &lt;span class="m">39904&lt;/span>
&lt;span class="ln"> 9&lt;/span>License : Python
&lt;span class="ln">10&lt;/span>Signature : RSA/SHA256, 2020年04月04日 星期六 05时06分11秒, Key ID 24c6a8a7f4a80eb5
&lt;span class="ln">11&lt;/span>Source RPM : python3-3.6.8-13.el7.src.rpm
&lt;span class="ln">12&lt;/span>Build Date : 2020年04月02日 星期四 22时17分47秒
&lt;span class="ln">13&lt;/span>Build Host : x86-01.bsys.centos.org
&lt;span class="ln">14&lt;/span>Relocations : &lt;span class="o">(&lt;/span>not relocatable&lt;span class="o">)&lt;/span>
&lt;span class="ln">15&lt;/span>Packager : CentOS BuildSystem &amp;lt;http://bugs.centos.org&amp;gt;
&lt;span class="ln">16&lt;/span>Vendor : CentOS
&lt;span class="ln">17&lt;/span>URL : https://www.python.org/
&lt;span class="ln">18&lt;/span>Summary : Interpreter of the Python programming language
&lt;span class="ln">19&lt;/span>Description :
&lt;span class="ln">20&lt;/span>Python is an accessible, high-level, dynamically typed, interpreted programming
&lt;span class="ln">21&lt;/span>language, designed with an emphasis on code readability.
&lt;span class="ln">22&lt;/span>It includes an extensive standard library, and has a vast ecosystem of
&lt;span class="ln">23&lt;/span>third-party libraries.
&lt;span class="ln">24&lt;/span>
&lt;span class="ln">25&lt;/span>The python3 package provides the &lt;span class="s2">&amp;#34;python3&amp;#34;&lt;/span> executable: the reference
&lt;span class="ln">26&lt;/span>interpreter &lt;span class="k">for&lt;/span> the Python language, version 3.
&lt;span class="ln">27&lt;/span>The majority of its standard library is provided in the python3-libs package,
&lt;span class="ln">28&lt;/span>which should be installed automatically along with python3.
&lt;span class="ln">29&lt;/span>The remaining parts of the Python standard library are broken out into the
&lt;span class="ln">30&lt;/span>python3-tkinter and python3-test packages, which may need to be installed
&lt;span class="ln">31&lt;/span>separately.
&lt;span class="ln">32&lt;/span>
&lt;span class="ln">33&lt;/span>Documentation &lt;span class="k">for&lt;/span> Python is provided in the python3-docs package.
&lt;span class="ln">34&lt;/span>
&lt;span class="ln">35&lt;/span>Packages containing additional libraries &lt;span class="k">for&lt;/span> Python are generally named with
&lt;span class="ln">36&lt;/span>the &lt;span class="s2">&amp;#34;python3-&amp;#34;&lt;/span> prefix.
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="15-查看-rpm-包安装了哪些目录">15. 查看 RPM 包安装了哪些目录&lt;/h3>
&lt;p>要获取已安装软件包的文件列表，使用选项 &lt;strong>-qdf（query document file)&lt;/strong> 的命令。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -qdf /usr/bin/tree&lt;/span>
&lt;span class="ln">2&lt;/span>/usr/share/doc/tree-1.6.0/LICENSE
&lt;span class="ln">3&lt;/span>/usr/share/doc/tree-1.6.0/README
&lt;span class="ln">4&lt;/span>/usr/share/man/man1/tree.1.gz
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="16-验证一个-rpm-包">16. 验证一个 RPM 包&lt;/h3>
&lt;p>验证软件包会将软件包已安装文件的信息与rpm数据库进行比较。使用 &lt;strong>-Vp (verify package)&lt;/strong> 命令来验证一个软件包。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -Vp python3-3.6.8-13.el7.x86_64.rpm&lt;/span>
&lt;span class="ln"> 2&lt;/span>未满足的依赖关系 python3-3.6.8-13.el7.x86_64：
&lt;span class="ln"> 3&lt;/span> libpython3.6m.so.1.0&lt;span class="o">()(&lt;/span>64bit&lt;span class="o">)&lt;/span> 被 python3-3.6.8-13.el7.x86_64 需要
&lt;span class="ln"> 4&lt;/span> python3-libs&lt;span class="o">(&lt;/span>x86-64&lt;span class="o">)&lt;/span> &lt;span class="o">=&lt;/span> 3.6.8-13.el7 被 python3-3.6.8-13.el7.x86_64 需要
&lt;span class="ln"> 5&lt;/span> python3-pip 被 python3-3.6.8-13.el7.x86_64 需要
&lt;span class="ln"> 6&lt;/span> python3-setuptools 被 python3-3.6.8-13.el7.x86_64 需要
&lt;span class="ln"> 7&lt;/span>遗漏 /usr/bin/pydoc3
&lt;span class="ln"> 8&lt;/span>遗漏 /usr/bin/pydoc3.6
&lt;span class="ln"> 9&lt;/span>遗漏 /usr/bin/python3
&lt;span class="ln">10&lt;/span>遗漏 /usr/bin/python3.6
&lt;span class="ln">11&lt;/span>遗漏 /usr/bin/python3.6m
&lt;span class="ln">12&lt;/span>遗漏 /usr/bin/pyvenv
&lt;span class="ln">13&lt;/span>遗漏 /usr/bin/pyvenv-3.6
&lt;span class="ln">14&lt;/span>遗漏 /usr/share/doc/python3-3.6.8
&lt;span class="ln">15&lt;/span>遗漏 d /usr/share/doc/python3-3.6.8/README.rst
&lt;span class="ln">16&lt;/span>遗漏 /usr/share/licenses/python3-3.6.8
&lt;span class="ln">17&lt;/span>遗漏 l /usr/share/licenses/python3-3.6.8/LICENSE
&lt;span class="ln">18&lt;/span>遗漏 d /usr/share/man/man1/python3.1.gz
&lt;span class="ln">19&lt;/span>遗漏 d /usr/share/man/man1/python3.6.1.gz
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="17-验证所有的-rpm-包">17. 验证所有的 RPM 包&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@tecmint&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm -Va&lt;/span>
&lt;span class="ln">2&lt;/span>
&lt;span class="ln">3&lt;/span>S.5....T. c /etc/rc.d/rc.local
&lt;span class="ln">4&lt;/span>.......T. c /etc/dnsmasq.conf
&lt;span class="ln">5&lt;/span>.......T. /etc/ld.so.conf.d/kernel-2.6.32-279.5.2.el6.i686.conf
&lt;span class="ln">6&lt;/span>S.5....T. c /etc/yum.conf
&lt;span class="ln">7&lt;/span>S.5....T. c /etc/yum.repos.d/epel.repo
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="18-导入-gpg-key">18. 导入 GPG key&lt;/h3>
&lt;p>要验证 RHEL / CentOS / Fedora 软件包，必须导入 GPG 密钥。为此，执行以下命令，它将导入CentOS 6 GPG密钥。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="19-列出所有导入的-rpm-gpg-key">19. 列出所有导入的 RPM GPG key&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>[root@localhost ~]# rpm -qa gpg-pubkey*
&lt;span class="ln">2&lt;/span>gpg-pubkey-85c6cd8a-4e060c35
&lt;span class="ln">3&lt;/span>gpg-pubkey-f4a80eb5-53a7ff4b
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="20-重建损坏的rpm数据库">20. 重建损坏的RPM数据库&lt;/h3>
&lt;p>有时rpm数据库损坏并停止rpm和系统上其他应用程序的所有功能。因此，当时我们需要重建rpm数据库并在以下命令的帮助下将其还原。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@tecmint&lt;span class="o">]&lt;/span>&lt;span class="c1"># cd /var/lib&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="o">[&lt;/span>root@tecmint&lt;span class="o">]&lt;/span>&lt;span class="c1"># rm __db*&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">[&lt;/span>root@tecmint&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpm --rebuilddb&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="o">[&lt;/span>root@tecmint&lt;span class="o">]&lt;/span>&lt;span class="c1"># rpmdb_verify Packages&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="21-查看-rpm-的脚本">21. 查看 RPM 的脚本&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>rpm -qp --scripts &amp;lt;rpm file name&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>export LD_LIBRARY_PATH=/apps/svr/python3/lib:$LD_LIBRARY_PATH；&lt;/p></description></item><item><title>Linux Shell 输入/输出重定向</title><link>https://ahamoment.cn/post/linux-shell-input-output-redirect/</link><pubDate>Tue, 26 Nov 2019 19:54:15 +0800</pubDate><guid>https://ahamoment.cn/post/linux-shell-input-output-redirect/</guid><description>
&lt;p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。&lt;/p>
&lt;p>重定向命令列表如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>命令&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>command &amp;gt; file&lt;/td>
&lt;td>将输出重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>command &amp;lt; file&lt;/td>
&lt;td>将输入重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>command &amp;gt;&amp;gt; file&lt;/td>
&lt;td>将输出以追加的方式重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;gt; file&lt;/td>
&lt;td>将文件描述符为 n 的文件重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;gt;&amp;gt; file&lt;/td>
&lt;td>将文件描述符为 n 的文件以追加的方式重定向到 file。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;gt;&amp;amp; m&lt;/td>
&lt;td>将输出文件 m 和 n 合并。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>n &amp;lt;&amp;amp; m&lt;/td>
&lt;td>将输入文件 m 和 n 合并。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;&amp;lt; tag&lt;/td>
&lt;td>将开始标记 tag 和结束标记 tag 之间的内容作为输入。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。&lt;/p>
&lt;/blockquote>
&lt;h2 id="输出重定向">输出重定向&lt;/h2>
&lt;p>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:&lt;/p>
&lt;p>&lt;code>command1 &amp;gt; file1&lt;/code>&lt;/p>
&lt;p>上面这个命令执行command1然后将输出的内容存入file1。&lt;/p>
&lt;p>注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&amp;gt;&amp;gt;操作符。&lt;/p>
&lt;h3 id="实例">实例&lt;/h3>
&lt;p>执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ who &amp;gt; users
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。&lt;/p>
&lt;p>你可以使用 cat 命令查看文件内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ cat users
&lt;span class="ln">2&lt;/span>_mbsetupuser console Oct &lt;span class="m">31&lt;/span> 17:35
&lt;span class="ln">3&lt;/span>laolan console Oct &lt;span class="m">31&lt;/span> 17:35
&lt;span class="ln">4&lt;/span>laolan ttys000 Dec &lt;span class="m">1&lt;/span> 11:33
&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出重定向会覆盖文件内容，请看下面的例子：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;W3Cschool教程：www.w3cschool.cn&amp;#34;&lt;/span> &amp;gt; users
&lt;span class="ln">2&lt;/span>$ cat users
&lt;span class="ln">3&lt;/span>W3Cschool教程：www.w3cschool.cn
&lt;span class="ln">4&lt;/span>$
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果不希望文件内容被覆盖，可以使用 &amp;gt;&amp;gt; 追加到文件末尾，例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;W3Cschool教程：www.w3cschool.cn&amp;#34;&lt;/span> &amp;gt;&amp;gt; users
&lt;span class="ln">2&lt;/span>$ cat users
&lt;span class="ln">3&lt;/span>W3Cschool教程：www.w3cschool.cn
&lt;span class="ln">4&lt;/span>W3Cschool教程：www.w3cschool.cn
&lt;span class="ln">5&lt;/span>$
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="输入重定向">输入重定向&lt;/h2>
&lt;p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：&lt;/p>
&lt;p>&lt;code>command1 &amp;lt; file1&lt;/code>&lt;/p>
&lt;p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。&lt;/p>
&lt;p>注意：输出重定向是大于号(&amp;gt;)，输入重定向是小于号(&amp;lt;)。&lt;/p>
&lt;h3 id="实例-1">实例&lt;/h3>
&lt;p>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ wc -l users
&lt;span class="ln">2&lt;/span> &lt;span class="m">2&lt;/span> users
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以将输入重定向到 users 文件：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ wc -l &amp;lt; users
&lt;span class="ln">2&lt;/span> &lt;span class="m">2&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。&lt;/p>
&lt;p>&lt;code>command1 &amp;lt; infile &amp;gt; outfile&lt;/code>&lt;/p>
&lt;p>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。&lt;/p>
&lt;h2 id="重定向深入讲解">重定向深入讲解&lt;/h2>
&lt;p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：&lt;/p>
&lt;ul>
&lt;li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。&lt;/li>
&lt;li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。&lt;/li>
&lt;li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。&lt;/li>
&lt;/ul>
&lt;p>默认情况下，command &amp;gt; file 将 stdout 重定向到 file，command &amp;lt; file 将stdin 重定向到 file。&lt;/p>
&lt;p>如果希望 stderr 重定向到 file，可以这样写：&lt;/p>
&lt;p>&lt;code>$ command 2 &amp;gt; file&lt;/code>&lt;/p>
&lt;p>如果希望 stderr 追加到 file 文件末尾，可以这样写：&lt;/p>
&lt;p>&lt;code>$ command 2 &amp;gt;&amp;gt; file&lt;/code>&lt;/p>
&lt;p>2 表示标准错误文件(stderr)。&lt;/p>
&lt;p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：&lt;/p>
&lt;p>&lt;code>$ command &amp;gt; file 2&amp;gt;&amp;amp;1&lt;/code>&lt;/p>
&lt;p>或者&lt;/p>
&lt;p>&lt;code>$ command &amp;gt;&amp;gt; file 2&amp;gt;&amp;amp;1&lt;/code>&lt;/p>
&lt;p>如果希望对 stdin 和 stdout 都重定向，可以这样写：&lt;/p>
&lt;p>&lt;code>$ command &amp;lt; file1 &amp;gt;file2&lt;/code>&lt;/p>
&lt;p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。&lt;/p>
&lt;h2 id="here-document">Here Document&lt;/h2>
&lt;p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。&lt;/p>
&lt;p>它的基本的形式如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">command&lt;/span> &lt;span class="s">&amp;lt;&amp;lt; delimiter
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="s"> document
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="s">delimiter&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;p>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。
开始的delimiter前后的空格会被忽略掉。&lt;/p>
&lt;h3 id="实例-2">实例&lt;/h3>
&lt;p>在命令行中通过 wc -l 命令计算 Here Document 的行数：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ wc -l &lt;span class="s">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="s"> 欢迎来到
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="s"> W3Cschool教程
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="s"> www.w3cschool.cn
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="m">3&lt;/span> &lt;span class="c1"># 输出结果为 3 行&lt;/span>
&lt;span class="ln">7&lt;/span>$
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以将 Here Document 用在脚本中，例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1"># author:W3Cschool教程&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="c1"># url:www.w3cschool.cn&lt;/span>
&lt;span class="ln">4&lt;/span>
&lt;span class="ln">5&lt;/span>cat &lt;span class="s">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="s">欢迎来到
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="s">W3Cschool教程
&lt;/span>&lt;span class="ln">8&lt;/span>&lt;span class="s">www.w3cschool.cn
&lt;/span>&lt;span class="ln">9&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行以上脚本，输出结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>欢迎来到
&lt;span class="ln">2&lt;/span>W3Cschool教程
&lt;span class="ln">3&lt;/span>www.w3cschool.cn
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="devnull-文件">/dev/null 文件&lt;/h2>
&lt;p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：&lt;/p>
&lt;p>&lt;code>$ command &amp;gt; /dev/null&lt;/code>&lt;/p>
&lt;p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&amp;quot;禁止输出&amp;quot;的效果。&lt;/p>
&lt;p>如果希望屏蔽 stdout 和 stderr，可以这样写：&lt;/p>
&lt;p>&lt;code>$ command &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。&lt;/p>
&lt;/blockquote></description></item></channel></rss>