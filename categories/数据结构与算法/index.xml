<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据结构与算法 on Ahamoment</title><link>https://ahamoment.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link><description>Recent content in 数据结构与算法 on Ahamoment</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Thu, 15 Apr 2021 10:03:48 +0800</lastBuildDate><atom:link href="https://ahamoment.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>二叉树的中序遍历</title><link>https://ahamoment.cn/post/algorithm-tree-inorder/</link><pubDate>Thu, 15 Apr 2021 10:03:48 +0800</pubDate><guid>https://ahamoment.cn/post/algorithm-tree-inorder/</guid><description>
&lt;p>二叉树的遍历方法分为先序遍历，中序遍历，后序遍历以及层序遍历这四种，其中先序，中序以及后序又可以用递归和非递归的方式来实现，层序遍历一般则是用一个队列来实现。关于这几种遍历方式和代码可以参考本博客的之前的一篇文章---&amp;gt;&lt;a href="https://chenxq.xyz/post/algorithm-binary-tree/#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">传送门&lt;/a>&lt;/p>
&lt;p>这里我们通过一道 leetcode 题目来对二叉树的中序遍历法展开讨论。这道题的描述如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln"> 1&lt;/span>leetcode 94 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/]
&lt;span class="ln"> 2&lt;/span>给定一个二叉树的根节点 root ，返回它的 中序 遍历。
&lt;span class="ln"> 3&lt;/span>
&lt;span class="ln"> 4&lt;/span>示例1：
&lt;span class="ln"> 5&lt;/span> 1
&lt;span class="ln"> 6&lt;/span> \
&lt;span class="ln"> 7&lt;/span> 2
&lt;span class="ln"> 8&lt;/span> /
&lt;span class="ln"> 9&lt;/span> 3
&lt;span class="ln">10&lt;/span>输入：root = [1,null,2,3]
&lt;span class="ln">11&lt;/span>输出：[1,3,2]
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="1-递归">1. 递归&lt;/h2>
&lt;p>首先我们需要了解什么是二叉树的中序遍历：按照访问&lt;strong>左子树——根节点——右子树&lt;/strong>的方式遍历这棵树，而在访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。&lt;/p>
&lt;p>定义 &lt;code>inorder(root)&lt;/code> 表示当前遍历到&lt;code>root&lt;/code>节点的答案，那么按照定义，我们只要递归调用 &lt;code>inorder(root.left)&lt;/code> 来遍历 &lt;code>root&lt;/code> 节点的左子树，然后将 &lt;code>root&lt;/code> 节点的值加入答案，再递归调用 &lt;code>inorder(root.right)&lt;/code> 来遍历 &lt;code>root&lt;/code> 节点的右子树即可，递归终止的条件为碰到空节点。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">inorderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;();&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">inorder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 7&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">inorder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">inorder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">inorder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-迭代">2. 迭代&lt;/h2>
&lt;p>方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">inorderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;();&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="c1">// 定义一个栈
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Deque&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">stk&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;gt;();&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="c1">// 节点不为空，并且栈不为空
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">stk&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="c1">// 一直走到最左的节点，边走边压栈
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">stk&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="c1">// 从最左的节点开始弹栈,并且判断右节点是否为空
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">stk&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3-morris-中序遍历">3. Morris 中序遍历&lt;/h2>
&lt;p>Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 &lt;code>O(1)&lt;/code>。&lt;/p>
&lt;p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 &lt;code>x&lt;/code>）：&lt;/p>
&lt;ol>
&lt;li>如果 x 无左孩子，先将 x 的值加入答案数组，再访问 x 的右孩子，即 &lt;code>x=x.right&lt;/code>。&lt;/li>
&lt;li>如果 x 有左孩子，则找到 x 左子树上最右的节点（即左子树中序遍历的最后一个节点，x 在中序遍历中的前驱节点），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。
如果 predecessor 的右孩子为空，则将其右孩子指向 x，然后访问 x 的左孩子，即 x=x.left。
如果 predecessor 的右孩子不为空，则此时其右孩子指向 x，说明我们已经遍历完 x 的左子树，我们将 predecessor 的右孩子置空，将 x 的值加入答案数组，然后访问 x 的右孩子，即 x=x.right。&lt;/li>
&lt;li>重复上述操作，直至访问完整棵树。&lt;/li>
&lt;/ol>
&lt;p>其实整个过程我们就多做一步：假设当前遍历到的节点为 x，将 x 的左子树中最右边的节点的右孩子指向 x，这样在左子树遍历完成后我们通过这个指向走回了 x，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">inorderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;();&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">TreeNode&lt;/span> &lt;span class="n">predecessor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="c1">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">predecessor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">predecessor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">predecessor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">predecessor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">predecessor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">13&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="c1">// 让 predecessor 的右指针指向 root，继续遍历左子树
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">predecessor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">predecessor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="c1">// 说明左子树已经访问完了，我们需要断开链接
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="n">predecessor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="c1">// 如果没有左孩子，则直接访问右孩子
&lt;/span>&lt;span class="ln">27&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">34&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>复杂度分析&lt;/strong>&lt;/p>
&lt;p>时间复杂度：O(n)，其中 n 为二叉搜索树的节点个数。Morris 遍历中每个节点会被访问两次，因此总时间复杂度为 O(2n)=O(n)。&lt;/p>
&lt;p>空间复杂度：O(1)。&lt;/p></description></item><item><title>散列表那些事</title><link>https://ahamoment.cn/post/algorithm-hashtable/</link><pubDate>Thu, 15 Oct 2020 10:04:54 +0800</pubDate><guid>https://ahamoment.cn/post/algorithm-hashtable/</guid><description>
&lt;h2 id="基本概念">基本概念&lt;/h2>
&lt;p>在登录QQ的时候，QQ服务器是如何核对你的身份？面对庞大的用户群，如何快速找到用户信息？&lt;/p>
&lt;p>我们已经知道的几种查找方法包括：顺序查找，二分查找（静态查找），二叉搜索树（动态查找）。在这个场景下，如果使用二分查找的话就会面对插入和删除一个新号码要移动大量数据的问题。&lt;/p>
&lt;p>这里我们要用到散列查找的方法，散列（Hashing）的基本思想是：&lt;/p>
&lt;ol>
&lt;li>以关键字 key 为自变量，通过一个确定的**函数 h （散列函数）**计算出对应的函数值h(key)，作为数据对象的存储地址&lt;/li>
&lt;li>可能不同的关键字会映射到同一个散列地址上，称为**“冲突”**，发生冲突后需要某种冲突解决策略来解决冲突。&lt;/li>
&lt;/ol>
&lt;p>散列查找的时间复杂度为 O(1)，即查找时间与问题规模无关。&lt;/p>
&lt;p>一般情况下，设散列表空间大小为m，填入表中的元素个数是n，则称α=n/m为散列表的”装填因子“(Loading Factor)。实用时，通常将散列表大小设计为 &lt;strong>0.5-0.8&lt;/strong> 为宜。&lt;/p>
&lt;p>散列映射法的关键问题有两个：&lt;/p>
&lt;ol>
&lt;li>如何设计散列函数，使得发生冲突的概率尽可能小；&lt;/li>
&lt;li>当冲突或溢出不可避免的时候，如何处理使得表中没有空单元被浪费，同时插入、删除、查找等操作都正确完成。&lt;/li>
&lt;/ol>
&lt;h2 id="散列函数的构造方法">散列函数的构造方法&lt;/h2>
&lt;p>一个好的散列函数一般考虑下列两个因素：&lt;/p>
&lt;ol>
&lt;li>计算简单，以便提高转换速度&lt;/li>
&lt;li>关键字对应的地址空间分不均匀，以尽量减少冲突。即对于关键字集合中的任何一个关键字，经散列函数映射到地址集合中任何一个地址的概率是基本相等的。实际应用过程中，严格的均匀分布也是不可能的，只是不要过于聚集就行了。&lt;/li>
&lt;/ol>
&lt;p>关键字又分为数字关键字和字符串关键字两种类型，分别有不同的散列函数的构造方法：&lt;/p>
&lt;h3 id="数字关键字的散列函数构造">数字关键字的散列函数构造&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>直接定址法&lt;/p>
&lt;p>取关键字的某个线性函数值为散列地址，即&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>h(key) = a*key + b (a,b 为常数)
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>除留余数法&lt;/p>
&lt;p>散列函数为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>h(key)=key mod p
&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设散列表长为 TableSize （TableSize 的选取通常由关键字集合的大小 n 和允许最大的装填因子 α 决定，一般 TableSize=n/α），选择一个正整数 p &amp;lt;= TableSize。一般选取 p 为小于或者等于散列表表长 TableSize 的某个&lt;strong>最大素数&lt;/strong>比较好。用素数求得得余数作为散列地址，比较均匀地分布在整个地址空间上的可能性比较大，具体证明可以参考&lt;a href="https://blog.csdn.net/liuqiyao_01/article/details/14475159">为什么一般hashtable的桶数会取一个素数&lt;/a>。例如，TableSize=8，p=7;TableSize=16, p=13。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数字分析法&lt;/p>
&lt;p>分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址。散列函数可以取为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>h(key)=atoi(key+7)
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>折叠法&lt;/p>
&lt;p>把关键字分割成位数相同的几个部分，然后叠加取部分值。例如：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20201015112018138.png" alt="image-20201015112018138">&lt;/p>
&lt;p>折叠法是希望每一位对最后的结果都能产生影响。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>平方取中法&lt;/p>
&lt;p>如：56793542&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20201015112123029.png" alt="image-20201015112123029">&lt;/p>
&lt;p>平方取中法和折叠法的目的都是一样的，为了让关键字的每一位都对最后的结果产生影响。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="字符关键字的散列函数构造">字符关键字的散列函数构造&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>一个简单的散列函数：ASCII 码加和法。对字符型关键字key定义散列函数如下：&lt;/p>
&lt;p>$\sum key[i]$ mod TableSize&lt;/p>
&lt;p>这种方法会有严重的冲突&lt;/p>
&lt;/li>
&lt;li>
&lt;p>简单的改进 - 前3个字符移位法&lt;/p>
&lt;p>$h(key)=(key[0]*27^2+key[1]*27+key[2])$ mod TableSize&lt;/p>
&lt;p>这个方法会造成空间的浪费&lt;/p>
&lt;/li>
&lt;li>
&lt;p>好的散列函数：移位法&lt;/p>
&lt;p>涉及关键字所有n个字符，并且分布的很好：&lt;/p>
&lt;p>$h(key)=(\displaystyle \sum^{n-1}_{i=0}{key[n-i-1]*32^i})$ mod TableSize&lt;/p>
&lt;p>该函数用于处理长度位 n 的字符串关键字，每个字符占5位(即 $2^5=32$)，具体实现时并不需要做乘法运算，而是通过一次左移 5 位来完成。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">hashString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">tableSize&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//散列函数值，初始化为0
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">keyArrays&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toCharArray&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">keyArrays&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">keyArrays&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="sc">&amp;#39;\0&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">h&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">5&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">keyArrays&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">tableSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="冲突处理方法">冲突处理方法&lt;/h2>
&lt;p>常用处理冲突的思路：&lt;/p>
&lt;ul>
&lt;li>换个位置：开放地址法&lt;/li>
&lt;li>同一位置的冲突对象组织在一起：链地址法&lt;/li>
&lt;/ul>
&lt;h3 id="开放定址法">开放定址法&lt;/h3>
&lt;p>一旦产生了冲突（该地址已有其他元素），就按某种规则去寻找另一空地址。假设发生了第 i 次冲突，试探的下一个地址将增加 $d_i$ , 基本公式是：&lt;/p>
&lt;p>$d_i(key)=(h(key)+d_i)$ mod tableSize （1 &amp;lt;= i &amp;lt; tableSize）&lt;/p>
&lt;p>$d_i$决定了不同的解决冲突方案，包括：线性探测、平方探测、双散列。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>线性探测&lt;/p>
&lt;p>$d_i=i$&lt;/p>
&lt;p>以增量序列1,2,......,(tableSize-1) 循环试探下一个存储地址。做插入操作的时候，要找到一个空位置，或者直到散列表满为止；做查找操作时，探测一个比较依次一次关键字，直到找到特定的数据对象，或者探测到一个空位置表示查找失败为止。&lt;/p>
&lt;p>线性探测的缺点就是容易产生聚集的现象，因此引入了平方探测法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>平方探测法--二次探测&lt;/p>
&lt;p>平方探测的公式：$d_i=\pm i^2$，每次以增量序列$1^2,-1^2,2^2,-2^2......$循环试探下一个存储地址。&lt;/p>
&lt;p>平方探测法有可能出现散列表中有空间，但是无法探测到的情况。例如:&lt;/p>
&lt;p>散列表的长度为5，插入5,6,7,11这四个元素，散列函数设计为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>h(key)=key mod 5
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当插入11时，散列函数找到的位置为2，和6这个元素所在的位置产生冲突，使用平方探测法，探测序列为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>1+1=2
&lt;span class="ln">2&lt;/span>1-1=0
&lt;span class="ln">3&lt;/span>(1+2*2)%5=0
&lt;span class="ln">4&lt;/span>(1-2*2)%5=2
&lt;span class="ln">5&lt;/span>(1+3*3)%5=0
&lt;span class="ln">6&lt;/span>(1-3*3)%5=2
&lt;span class="ln">7&lt;/span>......
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以发现，探测序列一直在0和2这两个位置之间变动，一直找不到空的位置，但是散列表实际上还有空间。有定理显示：如果散列表长度tableSize是某个$4k+3$(k是正整数) 形式的素数时，平方探测法就可以探查到整个散列表空间。&lt;/p>
&lt;p>虽然平方探测法排除了一次聚集，但是散列到同一地址的那些数据对象将探测相同的备选单元，这称为“二次聚集”。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>双散列探测法&lt;/p>
&lt;p>双散列探测法: $d_i=i*h_2(key)$，$h_2(key)$是另一个散列函数，探测序列为：&lt;/p>
&lt;p>$h_2(key), 2h_2(key), 3h_2(key), ......$&lt;/p>
&lt;p>探测序列还应该保证所有的散列存储单元都能被探测到。选择以下形式有良好的效果：&lt;/p>
&lt;p>$h_2(key)=p$ - (key mod p)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>再散列&lt;/p>
&lt;p>当散列表元素太多（即装填因子α太大）时，查找效率会下降，实际使用的时候，装填因子一般取 0.5&amp;lt;=α&amp;lt;=0.85。&lt;/p>
&lt;p>当装填因子过大时，解决的方法时加倍扩大散列表，这个过程叫做“再散列”。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>在开放地址散列表中，删除操作要很小心，通常只能 “懒惰删除”，即需要增加一个删除标记(Deleted)，并不是真正删除它。这是因为插入的时候，为了解决冲突问题，这个位置已经被占用了，如果删除掉它，查找的时候就会出现“断链”的现象。&lt;/p>
&lt;h3 id="分离链接法">分离链接法&lt;/h3>
&lt;p>分离链接法时解决冲突的另一种方法，其做法是将所有关键字为同义词的数据对象通过节点链接存储到同一单向链表中。。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20201021114030859.png" alt="image-20201021114030859">&lt;/p>
&lt;p>如上图所示，分裂链接法实际上是用一个数组来组织散列表的数据结构，这个数组称为哈希桶，数组中的每个元素都指向一个链表，当元素冲突的时候，就在链表的头节点上插入冲突的元素。新元素插入到表头，这不仅仅为了方便，而且还因为新近插入的元素最有可能被最先访问，这样可以加快在单向链表中的顺序查找速度。&lt;/p>
&lt;h2 id="散列表的性能分析">散列表的性能分析&lt;/h2>
&lt;p>散列表的性能使用平均查找长度（ASL）来度量。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>线性探测法的查找性能满足下列公式&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20201021114435819.png" alt="image-20201021114435819">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>平方探测法和双散列探测法的查找性能满足下列公式&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20201021114511673.png" alt="image-20201021114511673">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分离链接法的查找性能满足下列公式&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20201021114554421.png" alt="image-20201021114554421">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>参考：浙江大学陈越老师的&lt;a href="https://www.icourse163.org/learn/ZJU-93001?tid=1207006212#/learn/announce">数据结构课程&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>堆</title><link>https://ahamoment.cn/post/algorithm-heap/</link><pubDate>Tue, 15 Sep 2020 11:44:06 +0800</pubDate><guid>https://ahamoment.cn/post/algorithm-heap/</guid><description>
&lt;h2 id="什么是堆">什么是堆&lt;/h2>
&lt;p>了解什么是堆之前，我们知道队列的概念，队列的特点是先进先出，但是有一种特殊的队列，取出元素的顺序是按照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序，这就是优先队列(Priority Queue)。&lt;/p>
&lt;p>若采用数组或者链表实现优先队列，总会有插入、删除或者查找中的一项操作的复杂度是$O(N)$ 的。&lt;/p>
&lt;p>若采用二叉搜索树实现，那么插入和删除都跟树的高度有关，也就是$O(log_2N)$ 的复杂度，但是删除的时候，由于每次都要删除最大的或者最小的，这样操作几次后，会造成搜索树失去平衡，所以不能简单的使用二叉搜索树。&lt;/p>
&lt;p>如果采用二叉树结构，我们更关注的应该是删除的操作，那么我们把最大的值放到根结点，左右两边也是最大值作为左右子树的根结点，每次删除只需要删除根结点。同时，为了保证树的平衡性，可以考虑使用完全二叉树来实现优先队列。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917105413123.png" alt="image-20200917105413123">&lt;/p>
&lt;p>优先队列使用完全二叉树表示如上图所示，数组的第 0 个元素空着，后面的按照层序遍历的顺序存放到数组中。使用完全二叉实现的优先队列，也可以称之为堆，堆的特性如下：&lt;/p>
&lt;ul>
&lt;li>结构性：用数组表示的完全二叉树。&lt;/li>
&lt;li>有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）
&lt;ul>
&lt;li>&amp;quot;最大堆&amp;quot;，也称 &amp;quot;大顶堆&amp;quot;：堆顶元素是整个树的最大值&lt;/li>
&lt;li>&amp;quot;最小堆&amp;quot;，也称&amp;quot;小顶堆&amp;quot;：堆顶元素是整个树的最小值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如下图所示的几个二叉树，不是堆。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917111328827.png" alt="image-20200917111328827">&lt;/p>
&lt;p>第一和第二棵二叉树虽然满足有序性，但是不是完全二叉树。第三和第四棵二叉树是完全二叉树，但是不满足有序性的特点。&lt;/p>
&lt;blockquote>
&lt;p>注意：堆从根结点到任意结点路径上的结点顺序都是有序的！&lt;/p>
&lt;/blockquote>
&lt;h2 id="最大堆的创建">最大堆的创建&lt;/h2>
&lt;p>堆的数据结构包括存储完全二叉树的数组 data，堆中当前元素个数 size，堆的最大容量 capacity。&lt;/p>
&lt;p>数组的元素从1开始，0的位置定义为哨兵，方便以后更快操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Heap&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="c1">// 堆的类型定义
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">protected&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//存储元素的数组
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">protected&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//堆中当前元素个数
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">protected&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//堆的最大容量
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Heap&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Heap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MAX_VALUE&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">18&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Heap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">maxSize&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">//最大元素从1开始
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MAX_VALUE&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 定义哨兵，为大于最大堆中所有可能元素的值
&lt;/span>&lt;span class="ln">24&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">25&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isFull&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">capacity&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">29&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">33&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">35&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最大堆的插入">最大堆的插入&lt;/h2>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917112957455.png" alt="image-20200917112957455">&lt;/p>
&lt;p>插入元素时，插入到数组的最后一个位置，这里插入的结点值为20，检查插入后仍然符合堆的两个特性，插入完成。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917113136023.png" alt="image-20200917113136023">&lt;/p>
&lt;p>当插入的值为35的时候，当前堆的有序性被破坏了，将35和31的位置调换后就可以了。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917113303675.png" alt="image-20200917113303675">&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917113324619.png" alt="image-20200917113324619">&lt;/p>
&lt;p>当插入的值为58的时候，58 &amp;gt; 31，跟31对调位置，58 &amp;gt; 44 继续跟根结点调换位置。调整后保证了有序性，同时，从58 -&amp;gt; 44 -&amp;gt; 31这条线也是按照从大到小的顺序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="c1">// 将元素X插入最大堆H，其中H-&amp;gt;Data[0]已经定义为哨兵
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 4&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;最大堆已满&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// i指向插入后堆中的最后一个元素的位置
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">/=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">];&lt;/span> &lt;span class="c1">// 向下过滤结点，对调父结点的位置
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 将X插入
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于我们将数组的第 0 个元素设置为哨兵，哨兵的值为一个非常大的整数值。如果没有哨兵结点，我们在循环中还需要判断 i &amp;gt; 1 这个条件，有了哨兵之后，循环在 i = 0 的时候就会停下来，可以少写一个条件，提高程序效率。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917114313272.png" alt="image-20200917114313272">&lt;/p>
&lt;h2 id="最大堆的删除">最大堆的删除&lt;/h2>
&lt;p>最大堆的删除过程就是取出根结点（最大值）元素，同时删除堆的一个结点。&lt;/p>
&lt;p>删除下图的这个堆的最大值：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917133516355.png" alt="image-20200917133516355">&lt;/p>
&lt;ol>
&lt;li>把 31 移至根&lt;/li>
&lt;li>找出 31 的较大的孩子&lt;/li>
&lt;/ol>
&lt;p>时间复杂度为： $T(N)=O(logN)$&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">deleteMax&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="c1">// 从最大堆中取出键值为最大的元素，并删除一个结点
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxItem&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//maxItem-堆顶元素，temp-临时变量
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;最大堆已经为空&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">maxItem&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">//取出根结点最大值
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 用最大堆中的最后一个元素从根结点开始向上过滤下层结点
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">--];&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 左儿子的位置
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">++;&lt;/span> &lt;span class="c1">//child 指向左右结点的较大者
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//找到位置了
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//将子结点与父节点对换
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">maxItem&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">26&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最大堆的建立">最大堆的建立&lt;/h2>
&lt;p>建立最大堆是将已经存在的N个元素按最大堆的要求存放在一个一维数组中。&lt;/p>
&lt;p>建堆的过程可以从树的从最后一个结点的父节点开始，到根结点1，将最后一个结点的父节点所在的小堆调整为最大堆，然后向左寻找有儿子的结点，每次调整一个最大堆，直到根结点。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">buildHeap&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="c1">//* 调整Data[]中的元素，使满足最大堆的有序性 *//*
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//* 这里假设所有Size个元素已经存在Data[]中 *//*
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="c1">//* 从最后一个结点的父节点开始，到根结点1 *//*
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">preDown&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">12&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">preDown&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="c1">//* 下滤：将H中以Data[p]为根的子堆调整为最大堆 *//*
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">];&lt;/span> &lt;span class="c1">//* 取出根结点存放的值 *//*
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="c1">//这个过程与删除的过程一样
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">]))&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">++;&lt;/span> &lt;span class="c1">//* Child指向左右子结点的较大者 *//*
&lt;/span>&lt;span class="ln">23&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//* 找到了合适位置 *//*
&lt;/span>&lt;span class="ln">24&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="c1">//* 下滤X *//*
&lt;/span>&lt;span class="ln">25&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">28&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">29&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最小堆">最小堆&lt;/h2>
&lt;p>最小堆的建立和操作与最大堆大致上是一样的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">MinHeap&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Heap&lt;/span>&lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">MinHeap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sentinalVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="kd">super&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">sentinalVal&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">MinHeap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sentinalVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//哨兵值
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">super&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">sentinalVal&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="c1">// 将元素X插入最小堆H，其中H-&amp;gt;Data[0]已经定义为哨兵
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">14&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;最大堆已满&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// i指向插入后堆中的最后一个元素的位置
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">/=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">];&lt;/span> &lt;span class="c1">// 向下过滤结点，对调父结点的位置
&lt;/span>&lt;span class="ln">22&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 将X插入
&lt;/span>&lt;span class="ln">24&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">26&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">deleteMin&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="c1">// 从最小堆中取出键值为最小的元素，并删除一个结点
&lt;/span>&lt;span class="ln">29&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">minItem&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//minItem-堆顶元素，temp-临时变量
&lt;/span>&lt;span class="ln">31&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;最大堆已经为空&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">35&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="n">minItem&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">//取出根结点最小值
&lt;/span>&lt;span class="ln">37&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 用最小堆中的最后一个元素从根结点开始向上过滤下层结点
&lt;/span>&lt;span class="ln">38&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">--];&lt;/span>
&lt;span class="ln">39&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">40&lt;/span> &lt;span class="n">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 左儿子的位置
&lt;/span>&lt;span class="ln">41&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">42&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">++;&lt;/span> &lt;span class="c1">//child 指向左右结点的较小者
&lt;/span>&lt;span class="ln">43&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">44&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//找到位置了
&lt;/span>&lt;span class="ln">45&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">46&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//将子结点与父节点对换
&lt;/span>&lt;span class="ln">47&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">48&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">49&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">50&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">51&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">minItem&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">52&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">53&lt;/span>
&lt;span class="ln">54&lt;/span> &lt;span class="c1">//*----------- 建造最小堆 -----------*//*
&lt;/span>&lt;span class="ln">55&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">preDown&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">56&lt;/span> &lt;span class="c1">//* 下滤：将H中以Data[p]为根的子堆调整为最小堆 *//*
&lt;/span>&lt;span class="ln">57&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">58&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">59&lt;/span>
&lt;span class="ln">60&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">];&lt;/span> &lt;span class="c1">//* 取出根结点存放的值 *//*
&lt;/span>&lt;span class="ln">61&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="c1">//这个过程与删除的过程一样
&lt;/span>&lt;span class="ln">62&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">63&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">]))&lt;/span>
&lt;span class="ln">64&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">++;&lt;/span> &lt;span class="c1">//* Child指向左右子结点的较小者 *//*
&lt;/span>&lt;span class="ln">65&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//* 找到了合适位置 *//*
&lt;/span>&lt;span class="ln">66&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="c1">//* 下滤X *//*
&lt;/span>&lt;span class="ln">67&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">68&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">69&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">70&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">71&lt;/span>
&lt;span class="ln">72&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">buildHeap&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">73&lt;/span> &lt;span class="c1">//* 调整Data[]中的元素，使满足最大堆的有序性 *//*
&lt;/span>&lt;span class="ln">74&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//* 这里假设所有Size个元素已经存在Data[]中 *//*
&lt;/span>&lt;span class="ln">75&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln">76&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">77&lt;/span>
&lt;span class="ln">78&lt;/span> &lt;span class="c1">//* 从最后一个结点的父节点开始，到根结点1 *//*
&lt;/span>&lt;span class="ln">79&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">80&lt;/span> &lt;span class="n">preDown&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">81&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">82&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">83&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>从堆的几种操作可以发现，删除和建堆的过程，就是从上往下调整堆的有序性的过程，插入元素的过程是从下往上调整堆的有序性的过程。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>【1】&lt;a href="https://www.icourse163.org/learn/ZJU-93001?tid=1207006212#/learn/content?type=detail&amp;amp;id=1212031639&amp;amp;cid=1215166239">数据结构-浙江大学&lt;/a>&lt;/p></description></item><item><title>平衡二叉树</title><link>https://ahamoment.cn/post/algorithm-balanced-binary-tree/</link><pubDate>Mon, 31 Aug 2020 18:11:54 +0800</pubDate><guid>https://ahamoment.cn/post/algorithm-balanced-binary-tree/</guid><description>
&lt;h2 id="平衡二叉树">平衡二叉树&lt;/h2>
&lt;p>平衡二叉树也是一种搜索树。&lt;/p>
&lt;p>搜索树节点不同插入次序，将导致不同的深度和平均查找长度 ASL。&lt;/p>
&lt;p>平衡因子（Balance Factor）:&lt;code>BF(T)=hL-hR&lt;/code>，其中hL和hR分别是T的左右子树的高度。平衡二叉树（Balanced Binary Tree) 又叫 AVL树，当树不为空时，在任一节点左，右子树高度差的绝对值不超过1，即 &lt;code>|BF(T)|&amp;lt;=1&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200910124943682.png" alt="image-20200910124943682">&lt;/p>
&lt;p>平衡二叉树的高度能够达到 &lt;em>$log_2n$&lt;/em>&lt;/p>
&lt;h2 id="平衡二叉树的调整">平衡二叉树的调整&lt;/h2>
&lt;p>任何情况都可以归结为四种模式。根据插入节点的位置不同使用不同的查找方法，同时记住平衡二叉树是搜索树，节点小于左边大于右边。平衡二叉树的四种调整方法为：右单旋，左单旋，右左双旋，左右双旋。&lt;/p>
&lt;h3 id="右单旋">右单旋&lt;/h3>
&lt;p>按照字母大小插入三个结点，Mar, May, Nov：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200915105728847.png" alt="image-20200915105728847">&lt;/p>
&lt;p>如上图左边所示，在插入 Nov 结点后，二叉树的平衡被破坏，结点Mar 的平衡因子为 -2，这个时候我们称 Mar 为不平衡的发现者，麻烦节点 Nov 在发现者右子树的右边，需要RR旋转（右单旋）。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200915110306417.png" alt="image-20200915110306417">&lt;/p>
&lt;p>右单旋的过程如上图所示，将 B 结点调整为跟结点，$B_L$ 调整为 A 的右结点。上图所示的是插入到右子树的右子树的右边时，当插入到右子树的右子树的位置不同时怎么处理？来看个例子：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200915111837036.png" alt="image-20200915111837036">&lt;/p>
&lt;p>结点插到左边和右边的时候，调整平衡后位置还是不变。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1">// 右单旋
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">singleRightRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="c1">// 注意：A 必须有一个右子节点B
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 将 A 与 B 做右单旋，更新A与B的高度，返回新的根结点B
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">),&lt;/span> &lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">),&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="左单旋">左单旋&lt;/h3>
&lt;p>左单旋与右单旋类似，麻烦结点在发现者的左子树的左边，因而叫LL插入，需要 LL 旋转（左单旋）。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200915112201005.png" alt="image-20200915112201005">&lt;/p>
&lt;p>上图是左单旋的调整过程。注意，对于调整，只需要从最下层的开始调整就行。下层平衡了，上层自然也会平衡。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1">// 左单旋(LL旋转)
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">singleLeftRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="c1">// 注意：A必须有一个左子结点B
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//将 A与B做左单旋，更新A与B的高度，返回新的根结点B
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">),&lt;/span> &lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">),&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="左右双旋">左右双旋&lt;/h3>
&lt;p>对于左右双旋，麻烦结点出现在左子树的右边，因而叫 LR 插入，需要做 LR 旋转。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200915112418342.png" alt="image-20200915112418342">&lt;/p>
&lt;p>当插入的结点在 C 的左子树或者右子树下边时，就需要左右双旋，左右双旋可以看成做了两次单旋，目的是调整 A,B,C 这三个结点的位置。先将B和C 做一次右单旋，再将 C 和 A 做一次左单旋。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">doubleLeftRightRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="c1">// 注意：A必须有一个左子节点B，且B必须有一个右子节点C
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 将A、B与C做两次单旋，返回新的根结点C
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="c1">// 将B与C做右单旋，C被返回
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">singleLeftRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">7&lt;/span> &lt;span class="c1">// 将A与C做左单旋，C被返回
&lt;/span>&lt;span class="ln">8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">singleLeftRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="右左双旋">右左双旋&lt;/h3>
&lt;p>右左双旋时，麻烦结点出现在右子树的左边，因而又叫 RL 插入。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200915112912024.png" alt="image-20200915112912024">&lt;/p>
&lt;p>同样的，我们也可将右左双旋看成是两次单旋，将 B 和 C 做左单旋，再将 A 与 C 做右单旋。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">doubleRightLeftRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="c1">// 注意：A必须有一个右子节点B，且B必须有一个左子节点C
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 将A、B与C做两次单旋，返回新的根结点C
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="c1">// 将B与C做左单旋，C被返回
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">singleRightRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="c1">// 将A与C做右单旋，C被返回
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">singleLeftRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意调整时，可能节点的位置不变，但是平衡因子需要更新。&lt;/p>
&lt;p>最后，我们来看一下平衡二叉树的插入，每一次的插入都要判断平衡是否被破坏，如果发现树的平衡被破坏，根据插入的位置做上面的四种旋转重新调整成平衡二叉树。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="cm">/* 将X插入AVL树T中，并且返回调整后的AVL树 */&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="cm">/* 若插入空树，则新建包含一个结点的树 */&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">AVLTree&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="cm">/* if (插入空树) 结束 */&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">compareTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="cm">/* 插入T的左子树 */&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="cm">/* 如果需要左旋 */&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">compareTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">singleLeftRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="cm">/* 左单旋 */&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">else&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">doubleLeftRightRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="cm">/* 左-右双旋 */&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="cm">/* else if (插入左子树) 结束 */&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">compareTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="cm">/* 插入T的右子树 */&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="cm">/* 如果需要右旋 */&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">compareTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">singleRightRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="cm">/* 右单旋 */&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="k">else&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">doubleRightLeftRotation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="cm">/* 右-左双旋 */&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="cm">/* else if (插入右子树) 结束 */&lt;/span>
&lt;span class="ln">25&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="cm">/* else X == T-&amp;gt;Data，无须插入 */&lt;/span>
&lt;span class="ln">27&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="cm">/* 别忘了更新树高 */&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">),&lt;/span> &lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">30&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">32&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;p>【1】浙江大学陈越老师的&lt;a href="https://www.icourse163.org/learn/ZJU-93001?tid=1207006212#/learn/announce">数据结构课程&lt;/a>&lt;/p></description></item><item><title>二叉搜索树</title><link>https://ahamoment.cn/post/algorithm-binary-search-tree/</link><pubDate>Wed, 19 Aug 2020 17:05:29 +0800</pubDate><guid>https://ahamoment.cn/post/algorithm-binary-search-tree/</guid><description>
&lt;h2 id="1-二叉搜索树的概念">1. 二叉搜索树的概念&lt;/h2>
&lt;p>二叉搜索树，也称为二叉排序树或二叉查找树。一棵不为空的二叉搜索树满足以下性质：&lt;/p>
&lt;ol>
&lt;li>非空左子树的所有键值小于其根结点的键值。&lt;/li>
&lt;li>非空右子树的所有键值大于其根结点的键值。&lt;/li>
&lt;li>左，右子树都是二叉搜索树。&lt;/li>
&lt;/ol>
&lt;h2 id="2-二叉搜索树的查找">2. 二叉搜索树的查找&lt;/h2>
&lt;p>从二叉搜索树BST中查找元素X，返回其所在结点的地址。二叉搜索树的查找过程可以描述为以下步骤：&lt;/p>
&lt;ol>
&lt;li>查找从根结点开始，如果树为空，直接返回 null&lt;/li>
&lt;li>若查找树非空，则根结点关键字与 X 进行比较，并进行不同的处理。
&lt;ol>
&lt;li>x 小于根结点的键值，在左子树中搜索；&lt;/li>
&lt;li>x 大于根结点的键值，在右子树中搜索；&lt;/li>
&lt;li>若两者比较的结果相等，搜索完成，直接返回指向结点的指针。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200820101124146.png" alt="image-20200820101124146">&lt;/p>
&lt;p>我们用递归来实现查找过程，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">find&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;树为空，查找失败！&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//查找失败
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">compareTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">result&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="c1">// x 大于根结点的值，向右子树递归查找
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">find&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">result&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="c1">// x 小于根结点的值，向左子树递归查找
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">find&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="c1">// 找到 x 的值，直接返回结点所在的指针
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">18&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个递归实现中，两个递归过程都是尾递归，可以改成用迭代函数来实现，提高执行效率。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">findNonRecursive&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">compareTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">result&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="c1">// 向右子树中移动，继续查找
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bst&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">result&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="c1">// 向左子树中移动，继续查找
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bst&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="c1">// x == bst.data
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 查找成功，返回结点的找到结点的地址
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="c1">// 查找失败
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">18&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了通用的查找外，二叉搜索树经常要使用到最大和最小元素的查找。对于一棵二叉搜索树来说，最大元素一定是在树的最右分支的端结点上，最小元素一定是在树的最左分支的端结点上。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200827114732562.png" alt="image-20200827114732562">&lt;/p>
&lt;p>最大元素和最小元素的递归和非递归实现为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1">// 查找树的最小值
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">findMin&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="c1">// 空的二叉搜索树，返回NULL
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="c1">// 找到最左叶结点并返回
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="c1">// 沿左分支继续查找
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">findMin&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">14&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="c1">// 查找树的最大值
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">findMax&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="c1">// 空的二叉搜索树
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="c1">// 找到最右的叶结点并返回
&lt;/span>&lt;span class="ln">22&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="c1">// 沿右分支继续查找
&lt;/span>&lt;span class="ln">25&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">findMax&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">27&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">28&lt;/span>
&lt;span class="ln">29&lt;/span>&lt;span class="c1">// 最小值非递归实现
&lt;/span>&lt;span class="ln">30&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">findMinNonRecursive&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="c1">// 沿左分支继续查找，直到最右叶结点
&lt;/span>&lt;span class="ln">34&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bst&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">35&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">37&lt;/span>
&lt;span class="ln">38&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">39&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">40&lt;/span>
&lt;span class="ln">41&lt;/span>&lt;span class="c1">// 查找最大值非递归实现
&lt;/span>&lt;span class="ln">42&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">findMaxNonRecursive&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">43&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">44&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">45&lt;/span> &lt;span class="c1">// 沿右分支继续查找，直到最右叶结点
&lt;/span>&lt;span class="ln">46&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bst&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">47&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">48&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">49&lt;/span>
&lt;span class="ln">50&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">51&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3-二叉搜索树的插入">3. 二叉搜索树的插入&lt;/h2>
&lt;p>插入指定结点到一棵二叉树中，这个过程我们关键要找到这个结点要插入的位置，可以采用与查找类似的方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1">// 插入操作
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="c1">// 若原树为空，生成并返回一个结点的二叉搜索树
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bst&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="c1">// 开始查找要插入元素的位置
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">compareTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">result&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="c1">// 递归插入左子树
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">result&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="c1">// 递归插入右子树
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="cm">/*else {
&lt;/span>&lt;span class="ln">18&lt;/span>&lt;span class="cm"> // x 元素已经存在, 不做任何操作
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="cm"> //
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="cm"> }*/&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">22&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">bst&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过递归左右子树，找到要插入的位置，然后插入结点。&lt;/p>
&lt;h2 id="4-二叉搜索树的删除">4. 二叉搜索树的删除&lt;/h2>
&lt;p>删除一棵二叉树，分为三种情况，分别来分析一下：&lt;/p>
&lt;p>第一种，要删除的结点是树的叶子结点，那么可以直接删除，并修改其父结点的指针为 null，例如，删除下面这棵二叉搜索树 35 这个结点：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200831180447446.png" alt="image-20200831180447446">&lt;/p>
&lt;p>第二种，要删除的结点有一个孩子结点，那么删除该结点后，要修改其父结点的指针到要删除结点的孩子结点上。例如，删除下面这棵二叉搜索树的33结点。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200831180648814.png" alt="image-20200831180648814">&lt;/p>
&lt;p>第三种，要删除的结点有左、右两个子树，用另一结点替代被删除结点：右子树的最小元素或者左子树的最大元素。例如，删除41 这个结点的时候。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200831180831521.png" alt="image-20200831180831521">&lt;/p>
&lt;p>实现如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln"> 1&lt;/span>public TreeNode&amp;lt;T&amp;gt; delete(T x, TreeNode&amp;lt;T&amp;gt; bst) {
&lt;span class="ln"> 2&lt;/span> TreeNode&amp;lt;T&amp;gt; tmp;
&lt;span class="ln"> 3&lt;/span> if (bst == null) {
&lt;span class="ln"> 4&lt;/span> System.out.println(&amp;#34;树为空，要删除的元素未找到！&amp;#34;);
&lt;span class="ln"> 5&lt;/span> return null;
&lt;span class="ln"> 6&lt;/span> } else if (x.compareTo(bst.data) &amp;lt; 0) { //左子树递归删除
&lt;span class="ln"> 7&lt;/span> bst.left = delete(x, bst.left);
&lt;span class="ln"> 8&lt;/span> } else if (x.compareTo(bst.data) &amp;gt; 0) {
&lt;span class="ln"> 9&lt;/span> bst.right = delete(x, bst.right); //右子树递归删除
&lt;span class="ln">10&lt;/span> } else { //找到要删除的节点
&lt;span class="ln">11&lt;/span> if (bst.left != null &amp;amp;&amp;amp; bst.right != null) { //被删除结点有左右两个子结点
&lt;span class="ln">12&lt;/span> tmp = findMin(bst.right);
&lt;span class="ln">13&lt;/span> // 在右子树中找最小的元素填充删除结点
&lt;span class="ln">14&lt;/span> bst.data = tmp.data;
&lt;span class="ln">15&lt;/span> bst.right = delete(bst.data, bst.right);
&lt;span class="ln">16&lt;/span> } else { // 被删除结点有一个或无子结点
&lt;span class="ln">17&lt;/span> if (bst.left == null) {
&lt;span class="ln">18&lt;/span> // 有右孩子或无子结点
&lt;span class="ln">19&lt;/span> bst = bst.right;
&lt;span class="ln">20&lt;/span> } else if (bst.right == null) {
&lt;span class="ln">21&lt;/span> bst = bst.left;
&lt;span class="ln">22&lt;/span> }
&lt;span class="ln">23&lt;/span> }
&lt;span class="ln">24&lt;/span> }
&lt;span class="ln">25&lt;/span>
&lt;span class="ln">26&lt;/span> return bst;
&lt;span class="ln">27&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>题目：是否是同一棵二叉搜索树&lt;/p>
&lt;p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然后，给定一棵二叉搜索树可以由多种不同的插入序列得到。&lt;/p>
&lt;p>例如，按照序列(2,1,3)和（2，3，1）插入初始为空的二叉搜索树，得到一样的结果。&lt;/p>
&lt;p>问题：对于输入的各种插入序列，你需要判断他们是否能生成一样的二叉搜索树。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>【1】浙江大学陈越老师的&lt;a href="https://www.icourse163.org/learn/ZJU-93001?tid=1207006212#/learn/announce">数据结构课程&lt;/a>&lt;/p></description></item><item><title>二叉树及存储结构</title><link>https://ahamoment.cn/post/algorithm-binary-tree/</link><pubDate>Tue, 11 Aug 2020 10:40:08 +0800</pubDate><guid>https://ahamoment.cn/post/algorithm-binary-tree/</guid><description>
&lt;p>摘要：二叉树的定义，遍历二叉树&lt;/p>
&lt;h2 id="1-二叉树的定义">1. 二叉树的定义&lt;/h2>
&lt;blockquote>
&lt;p>二叉树：一个有穷的结点集合。这个集合可以为空，若不为空，则它是由根结点和称为其左子树 T&lt;sub>L&lt;/sub> 和右子树 T&lt;sub>R&lt;/sub> 的两个不想交的二叉树组成。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>二叉树具体五种基本形态&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811104404571.png" alt="image-20200811104404571">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>二叉树的子树有左右顺序之分&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811104443804.png" alt="image-20200811104443804">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="特殊二叉树">特殊二叉树&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>斜二叉树（Skewed Binary Tree）&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811104827529.png" alt="image-20200811104827529">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>完美二叉树（Perfect Binary Tree），又称为满二叉树（Full Binary Tree）&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811104932580.png" alt="image-20200811104932580">&lt;/p>
&lt;p>一棵完美二叉树所有的结点都有左右两个子结点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>完全二叉树（Complete Binary Tree）&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811105230817.png" alt="image-20200811105230817">&lt;/p>
&lt;p>完全二叉树的最后一层可以却是部分结点，例如右半部分缺失了12-15号结点，但是这样的二叉树不是完全二叉树：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811105352607.png" alt="image-20200811105352607">&lt;/p>
&lt;h2 id="2-二叉树的几个重要性质">2. 二叉树的几个重要性质&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>一个二叉树第 i 层的最大结点数为：$2^{i-1},i\geq1$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>深度为 K 的二叉树有最大结点总数为：$2^{k}-1, k\geq1$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对任何非空的二叉树 T， 若 $n_0$ 表示叶结点的个数，$n_2$ 是度为2的非叶结点个数，那么两者满足关系 $n_0=n_2+1$&lt;/p>
&lt;p>这个关系很容易可以推导出来，从边的角度出发，我们知道每个二叉树的边是确定的，从最后一层往上看，除根结点外，每个结点都有一条边和上一个结点连接，总的边数为: $n_0+n_1+n_2-1$；从根结点往下，度为2的结点对有两条边跟其他结点连接，度为1的结点为一条，叶结点为0条，即：$2n_2+n_1+0n_0$。 这两个式子相等：
$$
n_0+n_1+n_2-1=2n_2+n_1
$$
化简后就可以得到上面那个式子。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="3-二叉树的抽象数据类型定义">3. 二叉树的抽象数据类型定义&lt;/h2>
&lt;p>二叉树的结构由数据，左子树，右子树组成，操作集包括：判空，遍历，创建一个二叉树。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="cm">/**
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cm"> * 二叉树树节点定义
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="cm"> * @param &amp;lt;T&amp;gt;
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//节点数据
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//指向左子树
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//指向右子树
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">TreeNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">13&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">TreeNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">Tree&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">22&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln">24&lt;/span>&lt;span class="cm"> * 判别二叉树是否为空
&lt;/span>&lt;span class="ln">25&lt;/span>&lt;span class="cm"> * @param treeNode
&lt;/span>&lt;span class="ln">26&lt;/span>&lt;span class="cm"> * @return
&lt;/span>&lt;span class="ln">27&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isEmpty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">treeNode&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">29&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln">31&lt;/span>&lt;span class="cm"> * 遍历，按某顺序访问每个结点
&lt;/span>&lt;span class="ln">32&lt;/span>&lt;span class="cm"> * 遍历方法有四种：
&lt;/span>&lt;span class="ln">33&lt;/span>&lt;span class="cm"> * 1. 先序遍历：preOrderTraversal
&lt;/span>&lt;span class="ln">34&lt;/span>&lt;span class="cm"> * 2. 中序遍历：inOrderTraversal
&lt;/span>&lt;span class="ln">35&lt;/span>&lt;span class="cm"> * 3. 后序遍历：postOrderTraversal
&lt;/span>&lt;span class="ln">36&lt;/span>&lt;span class="cm"> * 4. 层次遍历：levelOrderTraversal
&lt;/span>&lt;span class="ln">37&lt;/span>&lt;span class="cm"> * @param treeNode
&lt;/span>&lt;span class="ln">38&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">39&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">traversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">treeNode&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">40&lt;/span>
&lt;span class="ln">41&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln">42&lt;/span>&lt;span class="cm"> * 创建一个二叉树
&lt;/span>&lt;span class="ln">43&lt;/span>&lt;span class="cm"> * @return
&lt;/span>&lt;span class="ln">44&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">45&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">createBinTree&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">46&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，最重要的就是二叉树的遍历，包括先序，中序，后序和层次遍历四种，后面我们会详细讲一下。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="4-二叉树的存储结构">4. 二叉树的存储结构&lt;/h2>
&lt;h3 id="41-顺序存储结构">4.1 顺序存储结构&lt;/h3>
&lt;p>二叉树可以采用顺序存储结构来存储，对于一棵完全二叉树来说，按照从上到下，从左到右的顺序存储 n 个结点的完全二叉树的结点父子关系：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811112438176.png" alt="image-20200811112438176">&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811112453094.png" alt="image-20200811112453094">&lt;/p>
&lt;ul>
&lt;li>非根结点的父结点的序号是 $i/2$ 向下取整的值&lt;/li>
&lt;li>结点的左孩子结点的序号是 $2i$，（若$2i\leq n$，否则没有左孩子 ）&lt;/li>
&lt;li>结点的右孩子的序号为$2i+1$，（若 $2i+1 \leq n$, 否则没有右孩子）&lt;/li>
&lt;/ul>
&lt;p>一般的二叉树也可以采用这种结构，但是需要补充空的结点，会造成空间浪费。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811112833149.png" alt="image-20200811112833149">&lt;/p>
&lt;h3 id="42-链表存储">4.2. 链表存储&lt;/h3>
&lt;p>链表的存储结构，我们在前面已经展示过，这里不再过多赘述。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811112958981.png" alt="image-20200811112958981">&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811113009904.png" alt="image-20200811113009904">&lt;/p>
&lt;h2 id="5-二叉树的遍历">5. 二叉树的遍历&lt;/h2>
&lt;p>二叉树的遍历方式一共有四种，分别是：先序遍历，中序遍历，后序遍历和层序遍历。其中先序，中序和后序遍历的实现方式又有两种，分别是递归和非递归。下面，我们就来详细的介绍一下：&lt;/p>
&lt;h3 id="51-递归实现">5.1 递归实现&lt;/h3>
&lt;h5 id="511-先序遍历">5.1.1 先序遍历&lt;/h5>
&lt;p>先序遍历的过程可以描述为：&lt;/p>
&lt;ol>
&lt;li>访问根结点&lt;/li>
&lt;li>先序遍历其左子树&lt;/li>
&lt;li>先序遍历其右子树&lt;/li>
&lt;/ol>
&lt;p>例如，我们有这样一棵树：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200812202856032.png" alt="image-20200812202856032">&lt;/p>
&lt;p>按照先序遍历的顺序将结点打印出来，依此是：A B D F E C G H I，程序描述为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">preOrderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="n">preOrderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="n">preOrderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">6&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="512-中序遍历">5.1.2 中序遍历&lt;/h5>
&lt;p>中序遍历的过程可以描述为：&lt;/p>
&lt;ol>
&lt;li>中序遍历其左子树&lt;/li>
&lt;li>访问根结点&lt;/li>
&lt;li>中序遍历其右子树&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200812203317277.png" alt="image-20200812203317277">&lt;/p>
&lt;p>按照中序遍历的方式将上面这棵树的结果输出，依次是：D B E F A G H C I ,使用程序描述为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">inOrderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="n">inOrderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="n">inOrderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">6&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="513-后序遍历">5.1.3 后序遍历&lt;/h5>
&lt;p>后序遍历的过程为：&lt;/p>
&lt;ol>
&lt;li>后序遍历其左子树&lt;/li>
&lt;li>后序遍历其右子树&lt;/li>
&lt;li>访问根结点&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200812203613025.png" alt="image-20200812203613025">&lt;/p>
&lt;p>按照后序遍历的方式将上面这棵树的结点输出，依此是：D E F B H G I C A&lt;/p>
&lt;h3 id="52-非递归实现">5.2 非递归实现&lt;/h3>
&lt;p>递归的本质是利用堆栈来做的，那么我们直接使用堆栈来实现上面的三种方式。&lt;/p>
&lt;p>先从中序遍历开始，中序遍历的非递归实现过程可以描述为以下几个步骤：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>遇到一个结点，就把它压栈，并去遍历它的左子树；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当左子树遍历结束后，从栈顶弹出这个结点并访问它；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后按其右指针再去中序遍历该结点的右子树。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200813091042459.png" alt="image-20200813091042459">&lt;/p>
&lt;p>对于上面的这样一棵树，我们按照中序遍历的过程操作堆栈：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/inorder.png" alt="">&lt;/p>
&lt;p>入栈和出栈的过程如上图所示。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">nonRecursiveInOrderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="c1">// 一直向左并将沿途结点压入堆栈
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">tmpTree&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">tmpTree&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmpTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="c1">// 结点弹出堆栈
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="c1">// 访问结点
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">tmpTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="c1">// 转向右子树
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmpTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>先序遍历的过程跟中序遍历类似，只需要在第一次遍历到结点的时候把结点的值打印出来即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">nonRecursivePreOrderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="c1">// 一直向左并将沿途结点压入堆栈
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">tmpTree&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="c1">// 访问结点
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">tmpTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">tmpTree&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmpTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">12&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="c1">// 结点弹出堆栈
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="c1">// 转向右子树
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmpTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>后序遍历的方式略有不同， 后序遍历应该把数据两次压入堆栈，第二次pop出来再 print 鉴于没有记录访问次数的结构，第二次pop的时候要么右节点是空的，要么右节点刚刚被print。所以，需要另一个指针pt来记录被刚刚print的节点。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">nonRecursivepostOrderTraversal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">pt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">tmpTree&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">tmpTree&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmpTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="c1">// 结点弹出堆栈
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">tmpTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)||(&lt;/span>&lt;span class="n">tmpTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">pt&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//判断右节点为空或者右节点已经输出
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">tmpTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">pt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmpTree&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//记录下上一个被输出的
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">tmpTree&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">//第二次入栈（相当于T没有出栈）
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tmpTree&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmpTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//转向右子树
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="53-层序遍历">5.3 层序遍历&lt;/h3>
&lt;p>层序遍历即将树从上到下，从左到右输出，例如下面这样的一棵树，按照层序遍历输出的结果为：A B C D F G I E H.&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200813203404840.png" alt="image-20200813203404840">&lt;/p>
&lt;p>层序遍历可以通过队列来实现，遍历从根结点开始，首先将根结点入队，然后开始执行循环：结点入队，访问该结点、其左右儿子入队。&lt;/p>
&lt;p>层序基本过程：先根结点入队，然后：&lt;/p>
&lt;ol>
&lt;li>从队列中取出一个元素；&lt;/li>
&lt;li>访问该元素所指的结点；&lt;/li>
&lt;li>若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">levelOrderTraveral&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="n">SeqQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">queue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">SeqQueue&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;(&lt;/span>&lt;span class="n">20&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="c1">// 若是空树则直接返回
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">delete&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>&lt;span class="c1">//访问取出队列中的结点
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>&lt;span class="c1">//左结点不为空，则左节点入队
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">//右节点不为空，则右节点入队
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="6-二叉树应用的例子">6. 二叉树应用的例子&lt;/h2>
&lt;blockquote>
&lt;p>例：输出二叉树中的叶子结点&lt;/p>
&lt;/blockquote>
&lt;p>在二叉树的遍历算法中增加检测结点的判断：左右子树是否都为空&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">preOrderPrintLeaves&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="c1">//叶子结点的左右都为空
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">preOrderPrintLeaves&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">preOrderPrintLeaves&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>求二叉树的高度&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200814092320757.png" alt="image-20200814092320757">&lt;/p>
&lt;p>二叉树的高度是左子树和右子树两者中最大的一个再加上根结点的高度1.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">binTree&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">hl&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">hr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">maxH&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">hl&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">//求左子树的高度
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">hr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">postOrderGetHight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">binTree&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">//求右子树的高度
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">maxH&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">hl&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">hr&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">//取左右子树较大的深度
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">maxH&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>由两种遍历序列确定二叉树，已知三种遍历中的任意两种遍历序列，能否唯一确定一棵二叉树呢？&lt;/p>
&lt;/blockquote>
&lt;p>答案是：必须要有中序遍历才行。&lt;/p>
&lt;p>假如没有中序遍历，来看个例子：先序：A B，后序：B A，就会出现两种不同的结构。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200814093448865.png" alt="image-20200814093448865">&lt;/p>
&lt;p>在知道中序的情况下，可以利用中序序列分割出左右两个子序列。&lt;/p>
&lt;blockquote>
&lt;p>参考：浙江大学陈越老师的&lt;a href="https://www.icourse163.org/learn/ZJU-93001?tid=1207006212#/learn/announce">数据结构课程&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>树的定义及表示</title><link>https://ahamoment.cn/post/algorithm-tree/</link><pubDate>Tue, 11 Aug 2020 10:31:07 +0800</pubDate><guid>https://ahamoment.cn/post/algorithm-tree/</guid><description>
&lt;p>这一部分主要介绍一下数据结构中很重要的一个概念：树。那么什么是树呢？在说明这个概念之前，我们先来看看和它相关的一些内容。&lt;/p>
&lt;h2 id="1-查找">1. 查找&lt;/h2>
&lt;p>查找是根据某个给定关键字&lt;strong>K&lt;/strong> ，从集合R中找出关键字与K相同的记录。查找又分为静态查找和动态查找，静态查找的集合中记录是固定的，没有插入和删除操作，只有查找，而动态查找的集合中记录是动态变化的，除了查找外，还可能发生插入和删除操作。&lt;/p>
&lt;h3 id="11-静态查找">1.1 静态查找&lt;/h3>
&lt;h4 id="方法一顺序查找">方法一：顺序查找&lt;/h4>
&lt;p>顺序查找就是从数组中一个一个地找，直到找到我们想要的元素为止。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.png" alt="">&lt;/p>
&lt;p>如图所示，在长度为8的数组中查找元素K，如果我们从最后一个元素找起来，查找成功就返回所在单元下表，不成功返回0。查找过程中，在第一个几点建立哨兵，哨兵的作用可以让程序知道什么时候应该停下来，同时可以少些一个判断条件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">sequentialSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 建立哨兵
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="c1">// 查找成功返回所在单元下标，不成功返回0
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">Search&lt;/span> &lt;span class="n">search&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Search&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">array&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">9&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">target&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">7&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">search&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sequentialSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;search for &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">target&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; in array is &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="方法二二分查找binary-search">方法二：二分查找(Binary Search)&lt;/h4>
&lt;p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。 但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。&lt;/p>
&lt;p>注意，二分查找的前提是连续存放（数组）是有序的。&lt;/p>
&lt;p>二分查找示例：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/binserach.png" alt="">&lt;/p>
&lt;p>在一个按从小到大排序的数组中查找 &lt;code>444&lt;/code> 这个元素，用三个指针分别代表左边，右边和中间，每次查找都将中间为止的值和目标值对比，若大于目标值，则在左半部分做二分查找，若小于目标值，则在右半部分做二分查找。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">binarySearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="cm">/*在表Tbl中查找关键字为K的数据元素*/&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">NoFound&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/*初始左边界*/&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/*初始右边界*/&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/*计算中间元素坐标*/&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/*调整右边界*/&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">k&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/*调整左边界*/&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/*查找成功，返回数据元素的下标*/&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">NoFound&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/*查找不成功，返回-1*/&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>二分查找的时间复杂度为&lt;code>O(logN)&lt;/code>&lt;/strong>&lt;/p>
&lt;p>二分查找是一种效率比较高的查找算法，整个二分查找的过程可以描述为以下的这种树形结构：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/binsearchtree.png" alt="">&lt;/p>
&lt;p>结点表示的是数组的下标，这样的结构称为二分查找判定树，判定树上每个结点需要的查找次数刚好为该结点所在的层数。反过来讲，我们如果将数据按照树的这种形势存储起来，是不是也能达到二分查找这种效率呢？&lt;/p>
&lt;h2 id="2-树的定义">2. 树的定义&lt;/h2>
&lt;blockquote>
&lt;p>树是 n （n&amp;gt;=0）个结点构成的有限集合。当n=0时，称为空树。&lt;/p>
&lt;/blockquote>
&lt;p>对于任何一棵非空树，具备以下性质：&lt;/p>
&lt;ul>
&lt;li>树中有一个称为 &lt;strong>根（root）&lt;/strong> 的特殊结点&lt;/li>
&lt;li>其余结点可分为 m（m&amp;gt;0) 个互不相交的有限集， 其中每个集合本身又是一棵树，称为原来树的子树。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811095437831.png" alt="image-20200811095437831">&lt;/p>
&lt;h3 id="21-树的一些基本术语">2.1 树的一些基本术语&lt;/h3>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811095539158.png" alt="image-20200811095539158">&lt;/p>
&lt;ol>
&lt;li>结点的度（Degree）：结点的子树个数。&lt;/li>
&lt;li>树的度：树的所有结点中最大的度数。&lt;/li>
&lt;li>叶结点：度为 0 的结点。&lt;/li>
&lt;li>父结点：有子树的结点是其子树的根结点的父结点。&lt;/li>
&lt;li>子结点：若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点。&lt;/li>
&lt;li>兄弟结点（sibling）：具有同一父结点的各结点彼此是兄弟结点。&lt;/li>
&lt;li>路径和路径长度：从结点n1到nk的路径为一个结点序列n1, n2,… , nk , ni是ni+1的父结点。路径所包含边的个数为路径的长度。&lt;/li>
&lt;li>祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。&lt;/li>
&lt;li>子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙。&lt;/li>
&lt;li>结点的层次（Level）：规定根结点在1层，其它任一结点的层数是其父结点的层数加1。&lt;/li>
&lt;li>树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度。&lt;/li>
&lt;/ol>
&lt;h3 id="22-树的表示">2.2 树的表示&lt;/h3>
&lt;p>采用儿子-兄弟表示法来表示一个树的结点，其中左边的指针指向第一个子节点，右边的指针指向相邻的兄弟结点，兄弟结点或子结点为空则用Null表示。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200811100529997.png" alt="image-20200811100529997">&lt;/p>
&lt;blockquote>
&lt;p>参考：浙江大学-陈越老师的&lt;a href="https://www.icourse163.org/learn/ZJU-93001?tid=1207006212#/learn/announce">数据结构课程&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>队列及其实现</title><link>https://ahamoment.cn/post/algorithm-queue/</link><pubDate>Thu, 06 Aug 2020 20:04:38 +0800</pubDate><guid>https://ahamoment.cn/post/algorithm-queue/</guid><description>
&lt;h2 id="1-什么是队列">1. 什么是队列&lt;/h2>
&lt;blockquote>
&lt;p>具有一定操作约束的线性表。插入和删除操作，只能在一端插入，另一端删除。&lt;/p>
&lt;/blockquote>
&lt;p>数据插入称之为入队(addQ)，数据删除称之为出队(deleteQ)，队列最重要的特征就是先进先出(FIFO)。生活中有很多跟队列相关的例子，例如超市排队。&lt;/p>
&lt;h2 id="2-队列的抽象数据类型描述">2. 队列的抽象数据类型描述&lt;/h2>
&lt;p>与队列相关的操作主要包括以下几种：&lt;/p>
&lt;ul>
&lt;li>创建队列：生成长度为 size 的空队列。&lt;/li>
&lt;li>判断队列是否满了。&lt;/li>
&lt;li>判断队列是否为空。&lt;/li>
&lt;li>将数据元素插入到队列中。&lt;/li>
&lt;li>将数据元素从队列中删除。&lt;/li>
&lt;/ul>
&lt;h2 id="3-队列的顺序存储实现">3. 队列的顺序存储实现&lt;/h2>
&lt;p>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量&lt;strong>front&lt;/strong>以及一个记录队列尾元素位置的变量&lt;strong>rear&lt;/strong>组成。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SeqQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">elementData&lt;/span>&lt;span class="o">[];&lt;/span>
&lt;span class="ln">4&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">rear&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如下图所示，用顺序存储实现队列，由于数组的元素从 0 开始，所以 front 和 rear 同时指向 -1 这个位置，添加 Job1，rear 往后移动一个位置，删除 Job1 ，front 往后移动一个位置。当队列满了的时候，就无法添加元素了，但是很明显就能发现，此时之前删除的位置还是空的，队列中还有位置，只是无法添加而已，这样的结构会造成空间浪费，我们需要用循环结构来解决。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/seqqueue.png" alt="">&lt;/p>
&lt;p>循环队列的机构如下图所示。循环结构中，front 和 rear 开始时同时指向 0 这个位置，之后，每一次入队，rear 向着顺时针方向移动一个位置，每一次出队列，front 向顺时针方向移动一个位置。那么这里就有个问题：队列空和满的判别条件是什么？队列空和满的时候，&lt;code>front=rear&lt;/code>，那么就造成无法判断队列空还是满了。那么要如何解决呢？这里提供两个解决方法：&lt;/p>
&lt;ol>
&lt;li>使用额外标记： &lt;strong>Size&lt;/strong>或者&lt;strong>tag&lt;/strong> 。size 用来记录当前元素的个数，当你加入一个元素的时候，size 加 1，删除一个元素的时候，size减1，所以只要根据size是0还是n就知道是空还是满的。tag （0，1）标记，添加一个元素，tag=1，删除一个元素 tag=0，当我们想判断队列是满还是空时，只要判断 tag 的值就知道最后一次操作是添加还是删除。&lt;/li>
&lt;li>仅使用n-1个数组空间。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/circlequeue.png" alt="">&lt;/p>
&lt;p>我们采用第二种方案，使用求余函数来查看列队是否已满。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">rear&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">front&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>看看具体的实现代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kn">package&lt;/span> &lt;span class="nn">leetcode.editor.datastructure.queue&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.io.Serializable&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 4&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SeqQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;,&lt;/span> &lt;span class="n">Serializable&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">DEAFULT_SIZE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">10&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">elementData&lt;/span>&lt;span class="o">[];&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">rear&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">12&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">14&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">SeqQueue&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">elementData&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">[])&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">DEAFULT_SIZE&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="n">front&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="n">rear&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">SeqQueue&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="n">elementData&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">[])&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="n">front&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="n">rear&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">27&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">rear&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">elementData&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;队列已满&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="n">rear&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">rear&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">elementData&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="n">elementData&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">rear&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">35&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">36&lt;/span>
&lt;span class="ln">37&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">38&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">elementData&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">39&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">40&lt;/span>
&lt;span class="ln">41&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="nf">delete&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">42&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">front&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">rear&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">43&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;队列为空&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">44&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">45&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">46&lt;/span> &lt;span class="n">front&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">front&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">elementData&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">47&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">elementData&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">48&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">49&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">50&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">51&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="4-队列的链式存储实现">4. 队列的链式存储实现&lt;/h1>
&lt;blockquote>
&lt;p>队列的链式存储结构也可以用一个&lt;strong>单链表&lt;/strong>实现。插入和删除操作分别在链表的两头进行；队列指针&lt;strong>front&lt;/strong>和&lt;strong>rear&lt;/strong>应该分别指向链表的表头和表尾。&lt;/p>
&lt;/blockquote>
&lt;p>整个队列的结构如下图所示：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/linkqueue.png" alt="">&lt;/p>
&lt;p>与顺序结构不同的是，链式存储实现的队列，出队需要在表头进行，因为是单向链表，如果在表尾进行删除操作，我们无法知道前一个元素是多少。因此入队和出队操作为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">LinkedQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//指向队头节点
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">rear&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//指向队尾节点
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">LinkedQueue&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">front&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">rear&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">front&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//空队列插入
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">front&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//非空队列,尾部插入
&lt;/span>&lt;span class="ln">18&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">rear&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">rear&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">22&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">front&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">rear&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">27&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="nf">delete&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">frontCell&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">frontElem&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">32&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">front&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;队列为空&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">35&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">37&lt;/span> &lt;span class="n">frontCell&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">38&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">front&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">rear&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1">//若队列只有一个元素
&lt;/span>&lt;span class="ln">39&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">front&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rear&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//删除后队列置为空
&lt;/span>&lt;span class="ln">40&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span>
&lt;span class="ln">41&lt;/span> &lt;span class="n">front&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">();&lt;/span>&lt;span class="c1">//front移动到下一个元素
&lt;/span>&lt;span class="ln">42&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">frontElem&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">frontCell&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">43&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">frontElem&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">44&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">45&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">46&lt;/span>
&lt;span class="ln">47&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Node&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">48&lt;/span>
&lt;span class="ln">49&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">50&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">51&lt;/span>
&lt;span class="ln">52&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Node&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">53&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">54&lt;/span> &lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">55&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">56&lt;/span>
&lt;span class="ln">57&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Node&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">58&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">59&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">60&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">61&lt;/span>
&lt;span class="ln">62&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">next&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">63&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">64&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">65&lt;/span>
&lt;span class="ln">66&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>参考：浙江大学陈越老师的&lt;a href="https://www.icourse163.org/learn/ZJU-93001?tid=1207006212#/learn/announce">数据结构课程&lt;/a>&lt;/p>
&lt;/blockquote></description></item></channel></rss>