<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>java - Category - Aha Moment</title><link>https://ahamoment.cn/categories/java/</link><description>java - Category - Aha Moment</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xueqiang.chen@foxmail..com (xueqiang.chen)</managingEditor><webMaster>xueqiang.chen@foxmail..com (xueqiang.chen)</webMaster><lastBuildDate>Thu, 12 Nov 2020 10:22:13 +0800</lastBuildDate><atom:link href="https://ahamoment.cn/categories/java/" rel="self" type="application/rss+xml"/><item><title>Java 多线程 - 自定义线程池</title><link>https://ahamoment.cn/posts/java/java-multithread-thread-pool/</link><pubDate>Thu, 12 Nov 2020 10:22:13 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-thread-pool/</guid><description>1. 为什么要用线程池？ 池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减</description></item><item><title>Java 多线程 - 线程生命周期</title><link>https://ahamoment.cn/posts/java/java-multithread-thread-lifecycle/</link><pubDate>Wed, 11 Nov 2020 18:23:31 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-thread-lifecycle/</guid><description>线程的生命周期大体可以分为如下6个主要的阶段： NEW RUNNABLE WAITING TIMED_WAITING BLOCKED TERMINATED 从 JDK 的源代码中也能看到关于线程状态的描述： // Thread.State public enum State { /** * Thread state for a thread which has not yet started. */ NEW,</description></item><item><title>Java 多线程面试题总结</title><link>https://ahamoment.cn/posts/java/java-multithread-interview-questions/</link><pubDate>Wed, 11 Nov 2020 10:41:32 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-interview-questions/</guid><description></description></item><item><title>Java 多线程 - 深入理解synchronized关键字</title><link>https://ahamoment.cn/posts/java/java-multithread-synchronized2/</link><pubDate>Sun, 25 Oct 2020 07:20:03 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-synchronized2/</guid><description>synchronized关键字提供了一种互斥机制，也就是说在同一时刻，只能有一个线程访问同步资源，很多资料、书籍将synchronized（</description></item><item><title>Java 多线程 - 线程中断 Interrupt</title><link>https://ahamoment.cn/posts/java/java-multithread-interrupt/</link><pubDate>Sat, 24 Oct 2020 07:17:54 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-interrupt/</guid><description>&lt;p>线程interrupt，是一个非常重要的API，也是经常使用的方法，在本文中我们将Thread深入源码对其进行详细的剖析。&lt;/p></description></item><item><title>JVM 内存结构</title><link>https://ahamoment.cn/posts/java/java-jvm-jmm/</link><pubDate>Thu, 15 Oct 2020 19:55:31 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-jvm-jmm/</guid><description>http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf JVM在执行Java程序的时候会把对应的物理内存划分成不同的内存区域，每一个区域都存放着不同的数据，也有不同的创建与销毁时机，有些分区会在</description></item><item><title>Java 多线程 - 死锁问题</title><link>https://ahamoment.cn/posts/java/java-multithread-dead-lock/</link><pubDate>Wed, 10 Jun 2020 19:21:07 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-dead-lock/</guid><description>锁是非常有用的工具，运用场景非常多，因为它使用起来非常方便，而且易于理解。但同时它也会带来一些困扰，那就是可能引起死锁。 1. 什么是死锁 百度百科</description></item><item><title>Java 多线程 - 初识 Synchronized</title><link>https://ahamoment.cn/posts/java/java-multithread-synchronized/</link><pubDate>Wed, 10 Jun 2020 19:16:24 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-synchronized/</guid><description>Synchronized 简介 本文出自汪文君老师的《Java 并发编程》课程，如需转载，请注明源出处！ 先来看一个例子，这个例子是模拟银行叫号的，使用三个线程模拟三个柜</description></item><item><title>JDK1.8 源代码阅读环境搭建</title><link>https://ahamoment.cn/posts/java/java-source-code-learn/</link><pubDate>Mon, 11 May 2020 18:57:51 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-source-code-learn/</guid><description>一、准备 Itellj IDEA， jdk1.8 的源代码包(解压 jdk 目录下的 src.zip 包得到) 二、项目结构 IDEA 创建一个普通的 java 项目 把解压得到的 jdk1.8 的源代码复制到 source 目录下： test 目录用来</description></item><item><title>IntellJ IDEA 远程调试 Java 程序</title><link>https://ahamoment.cn/posts/java/java-remote-debug/</link><pubDate>Thu, 21 Nov 2019 20:04:16 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-remote-debug/</guid><description>1. 前言 当我们发现服务器上的应用发生某些故障，并且没有足够的日志来定位问题的时候，就会觉得非常头疼，尤其是在生产环境中想要对应用进行调试并非易</description></item></channel></rss>