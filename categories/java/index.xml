<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on Ahamoment</title><link>https://ahamoment.cn/categories/java/</link><description>Recent content in java on Ahamoment</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Thu, 12 Nov 2020 10:22:13 +0800</lastBuildDate><atom:link href="https://ahamoment.cn/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 多线程 - 自定义线程池</title><link>https://ahamoment.cn/post/java-multithread-thread-pool/</link><pubDate>Thu, 12 Nov 2020 10:22:13 +0800</pubDate><guid>https://ahamoment.cn/post/java-multithread-thread-pool/</guid><description>
&lt;h2 id="1-为什么要用线程池">1. 为什么要用线程池？&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>线程池&lt;/strong>提供了一种限制和管理资源（包括执行一个任务）。 每个&lt;strong>线程池&lt;/strong>还维护一些基本统计信息，例如已完成任务的数量。&lt;/p>
&lt;p>这里借用《Java 并发编程的艺术》提到的来说一下&lt;strong>使用线程池的好处&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>降低资源消耗&lt;/strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li>
&lt;li>&lt;strong>提高响应速度&lt;/strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。&lt;/li>
&lt;li>&lt;strong>提高线程的可管理性&lt;/strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。&lt;/li>
&lt;/ul>
&lt;h2 id="2-自定义一个简单的线程池">2. 自定义一个简单的线程池&lt;/h2>
&lt;p>一个线程池应该具备以下要素：&lt;/p>
&lt;ul>
&lt;li>任务队列：用于缓存提交的任务。&lt;/li>
&lt;li>任务线程管理功能：一个线程池必须能够很好地管理和控制线程数量，可通过如下三个参数来实现，比如创建线程池时初始的线程数量init；线程池自动扩充时最大的线程数量max；在线程池空闲时需要释放线程但是也要维护一定数量的活跃数量或者核心数量core。有了这三个参数，就能够很好地控制线程池中的线程数量，将其维护在一个合理的范围之内，三者之间的关系是init＜=core＜=max。&lt;/li>
&lt;li>任务拒绝策略：如果线程数量已达到上限且任务队列已满，则需要有相应的拒绝策略来通知任务提交者。&lt;/li>
&lt;li>线程工厂：主要用于个性化定制线程，比如将线程设置为守护线程以及设置线程名称等。&lt;/li>
&lt;li>QueueSize：任务队列主要存放提交的Runnable，但是为了防止内存溢出，需要有limit数量对其进行控制。&lt;/li>
&lt;li>Keepedalive时间：该时间主要决定线程各个重要参数自动维护的时间间隔。&lt;/li>
&lt;/ul>
&lt;h3 id="21-线程池实现类图">2.1 线程池实现类图&lt;/h3>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/threadpool.png" alt="">&lt;/p>
&lt;p>上图为线程池实现类图，下面看具体的代码。&lt;/p>
&lt;h3 id="22-threadpool">2.2 ThreadPool&lt;/h3>
&lt;p>先定义一个线程池接口，定义常用的方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">ThreadPool&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="c1">//提交任务到线程池
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">execute&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Runnable&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="c1">// 关闭线程池
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">shutdown&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="c1">// 获取线程池的初始化大小
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getInitSize&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="c1">// 获取线程池的最大线程数
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getMaxSize&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">14&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="c1">// 获取线程池的核心线程数
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getCoreSize&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">17&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="c1">// 获取线程池中用于缓存任务队列的大小
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getQueueSize&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">20&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="c1">// 获取线程池中活跃线程的数量
&lt;/span>&lt;span class="ln">22&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getActiveCount&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">23&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="c1">// 查看线程池是否已经被shutdown
&lt;/span>&lt;span class="ln">25&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isShutdown&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">26&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="23-runnablequeue">2.3 RunnableQueue&lt;/h3>
&lt;p>我们需要一个任务队列，用来存放提交的任务，该队列是一个BlockedQueue，并且有limit的限制。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">RunnableQueue&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="c1">// 当有新任务进来时首先会offer到队列中
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Runnable&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="c1">// 工作线程通过take方法获取Runnable
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Runnable&lt;/span> &lt;span class="nf">take&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">InterruptedException&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="c1">// 获取任务队列中任务的数量
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">size&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="24-threadfactory">2.4 ThreadFactory&lt;/h3>
&lt;p>ThreadFactory提供了创建线程的接口，以便于个性化地定制Thread，比如Thread应该被加到哪个Group中，优先级、线程名字以及是否为守护线程等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="nd">@FunctionalInterface&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">ThreadFactory&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">3&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="nf">createThread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Runnable&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="25-拒绝策略denypolicy">2.5 拒绝策略（DenyPolicy）&lt;/h3>
&lt;p>DenyPolicy主要用于当Queue中的runnable达到了limit上限时，决定采用何种策略通知提交者。该接口中定义了三种默认的实现。&lt;/p>
&lt;ol>
&lt;li>DiscardDenyPolicy：直接将任务丢弃。&lt;/li>
&lt;li>AbortDenyPolicy：向任务提交者抛出异常。&lt;/li>
&lt;li>RunnerDenyPolicy：使用提交者所在的线程执行任务。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">DenyPolicy&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">reject&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Runnable&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ThreadPool&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 4&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="cm"> * 该拒绝策略会直接将任务丢弃
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">DiscardDenyPolicy&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">DenyPolicy&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">reject&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Runnable&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ThreadPool&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="c1">//do nothing
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;task will be discard&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">16&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln">18&lt;/span>&lt;span class="cm"> * 该拒绝策略会向任务提交者抛出异常
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">AbortDenyPolicy&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">DenyPolicy&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">21&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">reject&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Runnable&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ThreadPool&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RunnableDenyException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;The Runnable &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">runnable&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; will be abort.&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">27&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln">29&lt;/span>&lt;span class="cm"> * 该拒绝策略会使任务在提交者所在的线程中执行任务
&lt;/span>&lt;span class="ln">30&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">RunnerDenyPolicy&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">DenyPolicy&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">32&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">reject&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Runnable&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ThreadPool&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">35&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">threadPool&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isShutdown&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">run&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">37&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">38&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">39&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">40&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里还定义了一个 RunnableDenyException ，主要用于通知任务提交者，任务队列已经无法再接收新的任务。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">RunnableDenyException&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">RunnableDenyException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="kd">super&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="26-internaltask">2.6 InternalTask&lt;/h3>
&lt;p>InternalTask是Runnable的一个实现，是实际任务存储的数据结构。主要用于线程池内部，该类会使用到RunnableQueue，然后不断地从queue中取出某个runnable，并运行runnable的run方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">InternalTask&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Runnable&lt;/span>&lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">RunnableQueue&lt;/span> &lt;span class="n">runnableQueue&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 4&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">volatile&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">InternalTask&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RunnableQueue&lt;/span> &lt;span class="n">runnableQueue&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">runnableQueue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">runnableQueue&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="c1">// 如果当前任务为running并且没有被中断，则其将不断地从queue中获取runnable，然后执行run方法
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 这是提交到线程池的任务最终运行的地方
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">running&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">isInterrupted&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="n">Runnable&lt;/span> &lt;span class="n">task&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">runnableQueue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">take&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="n">task&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">run&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">25&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="c1">// 停止当前任务，主要会在线程池的shutdown方法中使用
&lt;/span>&lt;span class="ln">27&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">stop&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">running&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">30&lt;/span>
&lt;span class="ln">31&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码还对该类增加了一个开关方法stop，主要用于停止当前线程，一般在线程池销毁和线程数量维护的时候会使用到。&lt;/p>
&lt;h3 id="27-线程池详细实现">2.7 线程池详细实现&lt;/h3>
&lt;p>在LinkedRunnableQueue中有几个重要的属性，第一个是limit，也就是Runnable队列的上限；当提交的Runnable数量达到limit上限时，则会调用DenyPolicy的reject方法；runnableList是一个双向循环列表，用于存放Runnable任务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">LinkedRunnableQueue&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">RunnableQueue&lt;/span>&lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="c1">// 任务队列的最大容量，在构造时传入
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">limit&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="c1">// 若任务队列已满，则执行拒绝策略
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">DenyPolicy&lt;/span> &lt;span class="n">denyPolicy&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="c1">// 存放任务的队列
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Runnable&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">runnableList&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">ThreadPool&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">13&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">LinkedRunnableQueue&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">limit&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">DenyPolicy&lt;/span> &lt;span class="n">denyPolicy&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ThreadPool&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">limit&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">denyPolicy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">denyPolicy&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">threadPool&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Runnable&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">runnableList&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">runnableList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">limit&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="c1">// 无法容纳新的任务，执行拒绝策略
&lt;/span>&lt;span class="ln">25&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">denyPolicy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">reject&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="c1">// 将任务加入队尾，并且唤醒阻塞中的线程
&lt;/span>&lt;span class="ln">28&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">runnableList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">addLast&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="n">runnableList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">notifyAll&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">33&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln">35&lt;/span>&lt;span class="cm"> * take方法也是同步方法，线程不断从队列中获取Runnable任务，当队列为空的时候工作线程会陷入阻塞，
&lt;/span>&lt;span class="ln">36&lt;/span>&lt;span class="cm"> * 有可能在阻塞的过程中被中断，为了传递中断信号需要在catch语句块中将异常抛出以通知上游（InternalTask）
&lt;/span>&lt;span class="ln">37&lt;/span>&lt;span class="cm"> * @return 任务
&lt;/span>&lt;span class="ln">38&lt;/span>&lt;span class="cm"> * @throws InterruptedException 中断异常，通知上游(InternalTask)
&lt;/span>&lt;span class="ln">39&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">40&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">41&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">Runnable&lt;/span> &lt;span class="nf">take&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">InterruptedException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">42&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">runnableList&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">43&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">runnableList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">44&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">45&lt;/span> &lt;span class="c1">// 如果任务队列中没有可执行任务，则当前线程挂起，进入runnableList关联的monitor waitset中等待唤醒
&lt;/span>&lt;span class="ln">46&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">runnableList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">wait&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">47&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">48&lt;/span> &lt;span class="c1">// 被中断时需要将异常抛出
&lt;/span>&lt;span class="ln">49&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">50&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">51&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">52&lt;/span> &lt;span class="c1">// 从任务队列头排除一个任务
&lt;/span>&lt;span class="ln">53&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">runnableList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">removeFirst&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">54&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">55&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">56&lt;/span>
&lt;span class="ln">57&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">58&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">size&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">59&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">runnableList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">60&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">61&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">62&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据前面的讲解，线程池需要有数量控制属性、创建线程工厂、任务队列策略等功能，线程池初始化代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">BasicThreadPool&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">ThreadPool&lt;/span>&lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="c1">// 初始化线程数量
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">initSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="c1">// 线程池最大数量
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="c1">// 线程池核心线程数量
&lt;/span>&lt;span class="ln"> 10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">coreSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 11&lt;/span>
&lt;span class="ln"> 12&lt;/span> &lt;span class="c1">// 当前活跃的线程数量
&lt;/span>&lt;span class="ln"> 13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">activeCount&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 14&lt;/span>
&lt;span class="ln"> 15&lt;/span> &lt;span class="c1">// 创建线程所需的工厂
&lt;/span>&lt;span class="ln"> 16&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">ThreadFactory&lt;/span> &lt;span class="n">threadFactory&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 17&lt;/span>
&lt;span class="ln"> 18&lt;/span> &lt;span class="c1">// 任务队列
&lt;/span>&lt;span class="ln"> 19&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">RunnableQueue&lt;/span> &lt;span class="n">runnableQueue&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 20&lt;/span>
&lt;span class="ln"> 21&lt;/span> &lt;span class="c1">// 线程池是否已经被shutdown
&lt;/span>&lt;span class="ln"> 22&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">volatile&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="n">isShutdown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 23&lt;/span>
&lt;span class="ln"> 24&lt;/span> &lt;span class="c1">// 工作线程队列
&lt;/span>&lt;span class="ln"> 25&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">ThreadTask&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">threadQueue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayDeque&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="ln"> 26&lt;/span>
&lt;span class="ln"> 27&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">DenyPolicy&lt;/span> &lt;span class="n">DEFAULT_DENY_POLICY&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">DenyPolicy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">DiscardDenyPolicy&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 28&lt;/span>
&lt;span class="ln"> 29&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">ThreadFactory&lt;/span> &lt;span class="n">DEFAULT_THREAD_FACTORY&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">DefaultThreadFactory&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 30&lt;/span>
&lt;span class="ln"> 31&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">keepAliveTime&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 32&lt;/span>
&lt;span class="ln"> 33&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">TimeUnit&lt;/span> &lt;span class="n">timeUnit&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 34&lt;/span>
&lt;span class="ln"> 35&lt;/span> &lt;span class="c1">// 构造时需要传递的参数：初始的线程数量，最大的线程数量，核心线程数量，任务队列的最大数量
&lt;/span>&lt;span class="ln"> 36&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">BasicThreadPool&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">initSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">coreSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">queueSize&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 37&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">initSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">coreSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">DEFAULT_THREAD_FACTORY&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">queueSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">DEFAULT_DENY_POLICY&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">10&lt;/span> &lt;span class="o">,&lt;/span>&lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">SECONDS&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 38&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 39&lt;/span>
&lt;span class="ln"> 40&lt;/span> &lt;span class="c1">// 构造线程池时需要传入的参数，该构造函数需要的参数比较多
&lt;/span>&lt;span class="ln"> 41&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">BasicThreadPool&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">initSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">coreSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ThreadFactory&lt;/span> &lt;span class="n">threadFactory&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">queueSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">DenyPolicy&lt;/span> &lt;span class="n">denyPolicy&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">keepAliveTime&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TimeUnit&lt;/span> &lt;span class="n">timeUnit&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 42&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">initSize&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">initSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 43&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">maxSize&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 44&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">coreSize&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">coreSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 45&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">threadFactory&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threadFactory&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 46&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">runnableQueue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">LinkedRunnableQueue&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">queueSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">denyPolicy&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 47&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">keepAliveTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">keepAliveTime&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 48&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">timeUnit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">timeUnit&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 49&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">init&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 50&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 51&lt;/span>
&lt;span class="ln"> 52&lt;/span> &lt;span class="c1">// 初始化时，先创建 initSize 个线程
&lt;/span>&lt;span class="ln"> 53&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 54&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 55&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">initSize&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 56&lt;/span> &lt;span class="n">newThread&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 57&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 58&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 59&lt;/span>
&lt;span class="ln"> 60&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">newThread&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 61&lt;/span> &lt;span class="c1">//创建任务线程，并且启动
&lt;/span>&lt;span class="ln"> 62&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">InternalTask&lt;/span> &lt;span class="n">internalTask&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">InternalTask&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">runnableQueue&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 63&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="n">thread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">threadFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">createThread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">internalTask&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 64&lt;/span> &lt;span class="n">ThreadTask&lt;/span> &lt;span class="n">threadTask&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ThreadTask&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">internalTask&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 65&lt;/span> &lt;span class="n">threadQueue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">threadTask&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 66&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">activeCount&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="ln"> 67&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 68&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 69&lt;/span>
&lt;span class="ln"> 70&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">removeThread&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 71&lt;/span> &lt;span class="c1">// 从线程池中移除某个线程
&lt;/span>&lt;span class="ln"> 72&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ThreadTask&lt;/span> &lt;span class="n">threadTask&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threadQueue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">remove&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 73&lt;/span> &lt;span class="n">threadTask&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">internalTask&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">stop&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 74&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">activeCount&lt;/span>&lt;span class="o">--;&lt;/span>
&lt;span class="ln"> 75&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 76&lt;/span>
&lt;span class="ln"> 77&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln"> 78&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">execute&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Runnable&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 79&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isShutdown&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 80&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">IllegalStateException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;The thread pool is destroy&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 81&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 82&lt;/span> &lt;span class="c1">// 提交任务只是简单地往任务队列中插入Runnable
&lt;/span>&lt;span class="ln"> 83&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">runnableQueue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 84&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 85&lt;/span>
&lt;span class="ln"> 86&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln"> 87&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 88&lt;/span> &lt;span class="c1">// run 方法继承自Thread，主要用于维护线程数量，比如扩容、回收工作
&lt;/span>&lt;span class="ln"> 89&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">isShutdown&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">isInterrupted&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 90&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 91&lt;/span> &lt;span class="n">timeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">keepAliveTime&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 92&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 93&lt;/span> &lt;span class="n">isShutdown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 94&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 95&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 96&lt;/span>
&lt;span class="ln"> 97&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 98&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isShutdown&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 99&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">100&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">101&lt;/span> &lt;span class="c1">//当前队列中有尚未处理，并且activeCount&amp;lt;coreSize则继续扩容
&lt;/span>&lt;span class="ln">102&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">runnableQueue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">activeCount&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">coreSize&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">103&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">initSize&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">coreSize&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">104&lt;/span> &lt;span class="n">newThread&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">105&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">106&lt;/span> &lt;span class="c1">// continue 的目的在于不想让线程的扩容直接达到maxsize
&lt;/span>&lt;span class="ln">107&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">continue&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">108&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">109&lt;/span> &lt;span class="c1">// 当前队列中有任务尚未处理，并且activeCount&amp;lt;maxSize则继续扩容
&lt;/span>&lt;span class="ln">110&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">runnableQueue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">activeCount&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">111&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">coreSize&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">112&lt;/span> &lt;span class="n">newThread&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">113&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">114&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">115&lt;/span>
&lt;span class="ln">116&lt;/span> &lt;span class="c1">// 如果任务队列中没有任务，则需要回收，回收至coreSize即可
&lt;/span>&lt;span class="ln">117&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">runnableQueue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">activeCount&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">coreSize&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">118&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">coreSize&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">activeCount&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">119&lt;/span> &lt;span class="n">removeThread&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">120&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">121&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">122&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">123&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">124&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">125&lt;/span>
&lt;span class="ln">126&lt;/span> &lt;span class="c1">//ThreadTask 只是InternalTask和Thread的一个组合
&lt;/span>&lt;span class="ln">127&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ThreadTask&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">128&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">129&lt;/span> &lt;span class="n">InternalTask&lt;/span> &lt;span class="n">internalTask&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">130&lt;/span>
&lt;span class="ln">131&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">ThreadTask&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Thread&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">InternalTask&lt;/span> &lt;span class="n">internalTask&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">132&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">thread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">133&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">internalTask&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">internalTask&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">134&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">135&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">136&lt;/span>
&lt;span class="ln">137&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln">138&lt;/span>&lt;span class="cm"> * 销毁线程池主要为了是停止BasicThreadPool线程，停止线程池中的活动线程并且将isShutdown开关变量更改为true。
&lt;/span>&lt;span class="ln">139&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">140&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">141&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">shutdown&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">142&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">143&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isShutdown&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">144&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">145&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">146&lt;/span>
&lt;span class="ln">147&lt;/span> &lt;span class="n">isShutdown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">148&lt;/span> &lt;span class="n">threadQueue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">forEach&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">threadTask&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">149&lt;/span> &lt;span class="n">threadTask&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">internalTask&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">stop&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">150&lt;/span> &lt;span class="n">threadTask&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">interrupt&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">151&lt;/span> &lt;span class="o">});&lt;/span>
&lt;span class="ln">152&lt;/span>
&lt;span class="ln">153&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">interrupt&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">154&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">155&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">156&lt;/span>
&lt;span class="ln">157&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">158&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getInitSize&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">159&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isShutdown&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">160&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">IllegalStateException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;The thread pool is destroy&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">161&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">162&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">initSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">163&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">164&lt;/span>
&lt;span class="ln">165&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">166&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getMaxSize&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">167&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isShutdown&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">168&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">IllegalStateException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;The thread pool is destroy&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">169&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">170&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">maxSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">171&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">172&lt;/span>
&lt;span class="ln">173&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">174&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getCoreSize&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">175&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isShutdown&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">176&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">IllegalStateException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;The thread pool is destroy&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">177&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">178&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">coreSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">179&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">180&lt;/span>
&lt;span class="ln">181&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">182&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getQueueSize&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">183&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isShutdown&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">184&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">IllegalStateException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;The thread pool is destroy&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">185&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">186&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">runnableQueue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">187&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">188&lt;/span>
&lt;span class="ln">189&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">190&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getActiveCount&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">191&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">192&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">activeCount&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">193&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">194&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">195&lt;/span>
&lt;span class="ln">196&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">197&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isShutdown&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">198&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isShutdown&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">199&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">200&lt;/span>
&lt;span class="ln">201&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">DefaultThreadFactory&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">ThreadFactory&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">202&lt;/span>
&lt;span class="ln">203&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">AtomicInteger&lt;/span> &lt;span class="n">GROUP_COUNTER&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">AtomicInteger&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">204&lt;/span>
&lt;span class="ln">205&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">ThreadGroup&lt;/span> &lt;span class="n">group&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ThreadGroup&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;MyThreadPool-&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">GROUP_COUNTER&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getAndIncrement&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">206&lt;/span>
&lt;span class="ln">207&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">AtomicInteger&lt;/span> &lt;span class="n">COUNTER&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">AtomicInteger&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">208&lt;/span>
&lt;span class="ln">209&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">210&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="nf">createThread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Runnable&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">211&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">group&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;thread-pool-&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">COUNTER&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getAndIncrement&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">212&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">213&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">214&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">215&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>自动维护线程的代码块是同步代码块，主要是为了阻止在线程维护过程中线程池销毁引起的数据不一致问题。&lt;/p>
&lt;p>任务队列中若存在积压任务，并且当前活动线程少于核心线程数，则新建 &lt;code>coreSize-initSize&lt;/code>数量的线程，并且将其加入到活动线程队列中，为了防止马上进行&lt;code>maxSize-coreSize&lt;/code>数量的扩充，建议使用&lt;code>continue&lt;/code>终止本次循环。&lt;/p>
&lt;p>任务队列中有积压任务，并且当前活动线程少于最大线程数，则新建&lt;code>maxSize-coreSize&lt;/code>数量的线程，并且将其加入到活动队列中。&lt;/p>
&lt;p>当前线程池不够繁忙时，则需要回收部分线程，回收到&lt;code>coreSize&lt;/code>数量即可，回收时调用&lt;code>removeThread()&lt;/code>方法，在该方法中需要考虑的一点是，如果被回收的线程恰巧从&lt;code>Runnable&lt;/code>任务取出了某个任务，则会继续保持该线程的运行，直到完成了任务的运行为止，详见&lt;code>InternalTask&lt;/code>的run方法。&lt;/p>
&lt;h2 id="3-线程池的应用">3. 线程池的应用&lt;/h2>
&lt;p>写一个简单的程序分别测试线程池的任务提交、线程池线程数量的动态扩展，以及线程池的销毁功能。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ThreadPoolTest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">InterruptedException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="c1">//定义线程池，初始化线程数为2，核心线程数为4，最大线程数位6，任务队列最多允许1000个任务
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">ThreadPool&lt;/span> &lt;span class="n">threadPool&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">BasicThreadPool&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">6&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">4&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">1000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="c1">// 定义20个任务并且提交给线程池
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">20&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">execute&lt;/span>&lt;span class="o">(()-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">SECONDS&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">10&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; is running and done.&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="o">});&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">17&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(;&lt;/span> &lt;span class="o">;)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="c1">//不断输出线程池的信息
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;getActiveCount: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getActiveCount&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;getQueueSize: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getQueueSize&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;getCoreSize: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getCoreSize&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;getMaxSize: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">threadPool&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getMaxSize&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;================================================&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">SECONDS&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">28&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述测试代码中，定义了一个Basic线程池，其中初始化线程数量为2，核心线程数量为4，最大线程数量为6，最大任务队列数量为1000，同时提交了20个任务到线程池中，然后在main线程中不断地输出线程池中的线程数量信息监控变化，运行上述代码，截取的部分输出信息如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">2&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">18&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">2&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">18&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">0&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">14&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">17&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln">18&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">14&lt;/span>
&lt;span class="ln">20&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">2&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">3&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">0&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">26&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">27&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">28&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">8&lt;/span>
&lt;span class="ln">29&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">30&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">31&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln">32&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">33&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">8&lt;/span>
&lt;span class="ln">34&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">35&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">36&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln">37&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">4&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">38&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">39&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">3&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">40&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">2&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">41&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">0&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">42&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">43&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">44&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">2&lt;/span>
&lt;span class="ln">45&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">46&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">47&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln">48&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">49&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">2&lt;/span>
&lt;span class="ln">50&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">51&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">52&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln">53&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">3&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">54&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">2&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">55&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">56&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">4&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">57&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">58&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">0&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">59&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">60&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">0&lt;/span>
&lt;span class="ln">61&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">62&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">63&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln">64&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">65&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">0&lt;/span>
&lt;span class="ln">66&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">67&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">68&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln">69&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">3&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">70&lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">2&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">running&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="o">.&lt;/span>
&lt;span class="ln">71&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">5&lt;/span>
&lt;span class="ln">72&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">0&lt;/span>
&lt;span class="ln">73&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">74&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">75&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln">76&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">5&lt;/span>
&lt;span class="ln">77&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">0&lt;/span>
&lt;span class="ln">78&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">79&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">80&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln">81&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">82&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">0&lt;/span>
&lt;span class="ln">83&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">84&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln">85&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过上述输出信息可以看出，线程池中线程的动态扩展状况以及任务执行情况，在输出的最后会发现active count停留在了core size的位置，这也符合我们的设计，最后为了确定线程池中的活跃线程数量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">0&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="o">================================================&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="nl">getActiveCount:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="nl">getQueueSize:&lt;/span> &lt;span class="n">0&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="nl">getCoreSize:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="nl">getMaxSize:&lt;/span> &lt;span class="n">6&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-参考">4. 参考&lt;/h2>
&lt;blockquote>
&lt;p>【1】&lt;a href="https://book.douban.com/subject/30255689/">《Java 高并发编程详解》-汪文君&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>Java 多线程 - 线程生命周期</title><link>https://ahamoment.cn/post/java-multithread-thread-lifecycle/</link><pubDate>Wed, 11 Nov 2020 18:23:31 +0800</pubDate><guid>https://ahamoment.cn/post/java-multithread-thread-lifecycle/</guid><description>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/thread-lifecycle.png" alt="">&lt;/p>
&lt;p>线程的生命周期大体可以分为如下6个主要的阶段：&lt;/p>
&lt;ul>
&lt;li>NEW&lt;/li>
&lt;li>RUNNABLE&lt;/li>
&lt;li>WAITING&lt;/li>
&lt;li>TIMED_WAITING&lt;/li>
&lt;li>BLOCKED&lt;/li>
&lt;li>TERMINATED&lt;/li>
&lt;/ul>
&lt;p>从 JDK 的源代码中也能看到关于线程状态的描述：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1">// Thread.State
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">enum&lt;/span> &lt;span class="n">State&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="cm"> * Thread state for a thread which has not yet started.
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">NEW&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="ln"> 7&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="cm"> * Thread state for a runnable thread. A thread in the runnable
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="cm"> * state is executing in the Java virtual machine but it may
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="cm"> * be waiting for other resources from the operating system
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="cm"> * such as processor.
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">RUNNABLE&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="ln">15&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="cm"> * Thread state for a thread blocked waiting for a monitor lock.
&lt;/span>&lt;span class="ln">18&lt;/span>&lt;span class="cm"> * A thread in the blocked state is waiting for a monitor lock
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="cm"> * to enter a synchronized block/method or
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="cm"> * reenter a synchronized block/method after calling
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="cm"> * {@link Object#wait() Object.wait}.
&lt;/span>&lt;span class="ln">22&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="n">BLOCKED&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="ln">24&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln">26&lt;/span>&lt;span class="cm"> * Thread state for a waiting thread.
&lt;/span>&lt;span class="ln">27&lt;/span>&lt;span class="cm"> * A thread is in the waiting state due to calling one of the
&lt;/span>&lt;span class="ln">28&lt;/span>&lt;span class="cm"> * following methods:
&lt;/span>&lt;span class="ln">29&lt;/span>&lt;span class="cm"> * &amp;lt;ul&amp;gt;
&lt;/span>&lt;span class="ln">30&lt;/span>&lt;span class="cm"> * &amp;lt;li&amp;gt;{@link Object#wait() Object.wait} with no timeout&amp;lt;/li&amp;gt;
&lt;/span>&lt;span class="ln">31&lt;/span>&lt;span class="cm"> * &amp;lt;li&amp;gt;{@link #join() Thread.join} with no timeout&amp;lt;/li&amp;gt;
&lt;/span>&lt;span class="ln">32&lt;/span>&lt;span class="cm"> * &amp;lt;li&amp;gt;{@link LockSupport#park() LockSupport.park}&amp;lt;/li&amp;gt;
&lt;/span>&lt;span class="ln">33&lt;/span>&lt;span class="cm"> * &amp;lt;/ul&amp;gt;
&lt;/span>&lt;span class="ln">34&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="ln">35&lt;/span>&lt;span class="cm"> * &amp;lt;p&amp;gt;A thread in the waiting state is waiting for another thread to
&lt;/span>&lt;span class="ln">36&lt;/span>&lt;span class="cm"> * perform a particular action.
&lt;/span>&lt;span class="ln">37&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="ln">38&lt;/span>&lt;span class="cm"> * For example, a thread that has called &amp;lt;tt&amp;gt;Object.wait()&amp;lt;/tt&amp;gt;
&lt;/span>&lt;span class="ln">39&lt;/span>&lt;span class="cm"> * on an object is waiting for another thread to call
&lt;/span>&lt;span class="ln">40&lt;/span>&lt;span class="cm"> * &amp;lt;tt&amp;gt;Object.notify()&amp;lt;/tt&amp;gt; or &amp;lt;tt&amp;gt;Object.notifyAll()&amp;lt;/tt&amp;gt; on
&lt;/span>&lt;span class="ln">41&lt;/span>&lt;span class="cm"> * that object. A thread that has called &amp;lt;tt&amp;gt;Thread.join()&amp;lt;/tt&amp;gt;
&lt;/span>&lt;span class="ln">42&lt;/span>&lt;span class="cm"> * is waiting for a specified thread to terminate.
&lt;/span>&lt;span class="ln">43&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">44&lt;/span> &lt;span class="n">WAITING&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="ln">45&lt;/span>
&lt;span class="ln">46&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln">47&lt;/span>&lt;span class="cm"> * Thread state for a waiting thread with a specified waiting time.
&lt;/span>&lt;span class="ln">48&lt;/span>&lt;span class="cm"> * A thread is in the timed waiting state due to calling one of
&lt;/span>&lt;span class="ln">49&lt;/span>&lt;span class="cm"> * the following methods with a specified positive waiting time:
&lt;/span>&lt;span class="ln">50&lt;/span>&lt;span class="cm"> * &amp;lt;ul&amp;gt;
&lt;/span>&lt;span class="ln">51&lt;/span>&lt;span class="cm"> * &amp;lt;li&amp;gt;{@link #sleep Thread.sleep}&amp;lt;/li&amp;gt;
&lt;/span>&lt;span class="ln">52&lt;/span>&lt;span class="cm"> * &amp;lt;li&amp;gt;{@link Object#wait(long) Object.wait} with timeout&amp;lt;/li&amp;gt;
&lt;/span>&lt;span class="ln">53&lt;/span>&lt;span class="cm"> * &amp;lt;li&amp;gt;{@link #join(long) Thread.join} with timeout&amp;lt;/li&amp;gt;
&lt;/span>&lt;span class="ln">54&lt;/span>&lt;span class="cm"> * &amp;lt;li&amp;gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&amp;lt;/li&amp;gt;
&lt;/span>&lt;span class="ln">55&lt;/span>&lt;span class="cm"> * &amp;lt;li&amp;gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&amp;lt;/li&amp;gt;
&lt;/span>&lt;span class="ln">56&lt;/span>&lt;span class="cm"> * &amp;lt;/ul&amp;gt;
&lt;/span>&lt;span class="ln">57&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">58&lt;/span> &lt;span class="n">TIMED_WAITING&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="ln">59&lt;/span>
&lt;span class="ln">60&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="ln">61&lt;/span>&lt;span class="cm"> * Thread state for a terminated thread.
&lt;/span>&lt;span class="ln">62&lt;/span>&lt;span class="cm"> * The thread has completed execution.
&lt;/span>&lt;span class="ln">63&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="ln">64&lt;/span> &lt;span class="n">TERMINATED&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">65&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="线程的new状态">线程的NEW状态&lt;/h2>
&lt;p>当我们用关键字new创建一个Thread对象时，此时它并不处于执行状态，因为没有调用start方法启动该线程，那么线程的状态为NEW状态，准确地说，它只是Thread对象的状态，因为在没有start之前，该线程根本不存在，与你用关键字new创建一个普通的Java对象没什么区别。&lt;/p>
&lt;p>NEW状态通过start方法进入RUNNABLE状态。&lt;/p>
&lt;h2 id="线程的runnable状态">线程的RUNNABLE状态&lt;/h2>
&lt;p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 &lt;strong>RUNNABLE（运行中）&lt;/strong> 状态 。&lt;/p>
&lt;p>线程调用 &lt;code>start()&lt;/code> 方法后开始运行，那么此时才是真正地在JVM进程中创建了一个线程，线程一经启动就可以立即得到执行吗？答案是否定的，线程的运行与否和进程一样都要听令于CPU的调度，线程这时候处于 &lt;strong>READY（可运行）&lt;/strong> 状态，也就是说它具备执行的资格，但是并没有真正地执行起来而是在等待CPU的调度。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 &lt;strong>RUNNING（运行）&lt;/strong> 状态。&lt;/p>
&lt;p>由于存在&lt;strong>RUNNING&lt;/strong>状态，所以不会直接进入&lt;strong>BLOCKED&lt;/strong>状态和&lt;strong>TERMINATED&lt;/strong>状态，即使是在线程的执行逻辑中调用wait、sleep或者其他block的IO操作等，也必须先获得CPU的调度执行权才可以，严格来讲，RUNNABLE的线程只能意外终止或者进入RUNNING状态。&lt;/p>
&lt;p>在该&lt;strong>RUNNING&lt;/strong>状态中，线程的状态可以发生如下的状态转换。&lt;/p>
&lt;ul>
&lt;li>直接进入TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者判断某个逻辑标识。&lt;/li>
&lt;li>进入WAITING状态，比如调用了sleep，或者wait方法而加入了waitSet中。&lt;/li>
&lt;li>进行某个阻塞的IO操作，比如因网络数据的读写而进入了BLOCKED状态。&lt;/li>
&lt;li>获取某个锁资源，从而加入到该锁的阻塞队列中而进入了BLOCKED状态。&lt;/li>
&lt;li>由于CPU的调度器轮询使该线程放弃执行，进入READY 状态。&lt;/li>
&lt;li>线程主动调用yield方法，放弃CPU执行权，进入READY状态。&lt;/li>
&lt;/ul>
&lt;h2 id="线程的blocked状态">线程的BLOCKED状态&lt;/h2>
&lt;p>线程在BLOCKED状态中可以切换至如下几个状态。&lt;/p>
&lt;ul>
&lt;li>直接进入TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者意外死亡（JVM Crash）。&lt;/li>
&lt;li>线程阻塞的操作结束，比如读取了想要的数据字节进入到RUNNABLE状态。&lt;/li>
&lt;li>线程完成了指定时间的休眠，进入到了RUNNABLE状态。&lt;/li>
&lt;li>线程获取到了某个锁资源，进入RUNNABLE状态。&lt;/li>
&lt;li>线程在阻塞过程中被打断，比如其他线程调用了interrupt方法，进入RUNNABLE状态。&lt;/li>
&lt;/ul>
&lt;h2 id="线程的-waiting-状态">线程的 WAITING 状态&lt;/h2>
&lt;p>线程进入&lt;strong>WAITING&lt;/strong>状态，可能是调用了wait/join/park方法使线程进入等待状态，处在&lt;strong>WAITING&lt;/strong> 状态的线程被其他线程调用 notify/notifyAll 唤醒之后，就会重新进入 RUNNABLE 状态。&lt;/p>
&lt;h2 id="线程的-timed_waiting-状态">线程的 TIMED_WAITING 状态&lt;/h2>
&lt;p>TIMED_WAITING 就是超时等待的意思，跟 WAITING 状态不同的是，TIMED_WAITING 会等待指定的超时时间后自动退出。&lt;/p>
&lt;h2 id="线程的terminated状态">线程的TERMINATED状态&lt;/h2>
&lt;p>TERMINATED是一个线程的最终状态，在该状态中线程将不会切换到其他任何状态，线程进入TERMINATED状态，意味着该线程的整个生命周期都结束了，下列这些情况将会使线程进入TERMINATED状态。&lt;/p>
&lt;ul>
&lt;li>线程运行正常结束，结束生命周期。&lt;/li>
&lt;li>线程运行出错意外结束。&lt;/li>
&lt;li>JVM Crash，导致所有的线程都结束。&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;blockquote>
&lt;p>【1】&lt;a href="https://book.douban.com/subject/30255689/">《Java 高并发编程详解》-汪文君&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>Java 多线程面试题总结</title><link>https://ahamoment.cn/post/java-multithread-interview-questions/</link><pubDate>Wed, 11 Nov 2020 10:41:32 +0800</pubDate><guid>https://ahamoment.cn/post/java-multithread-interview-questions/</guid><description>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/Snailclimb/JavaGuide#%E5%B9%B6%E5%8F%91">JavaGuide&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-请简要描述线程与进程的关系区别及优缺点">1. 请简要描述线程与进程的关系，区别及优缺点？&lt;/h2>
&lt;p>&lt;strong>从 JVM 角度说进程和线程之间的关系&lt;/strong>&lt;/p>
&lt;p>一个进程中可以有多个线程，多个线程共享进程的&lt;strong>堆&lt;/strong>和**方法区 (JDK1.8 之后的元空间)*&lt;em>资源，但是每个线程有自己的*&lt;em>程序计数器&lt;/em>&lt;/em>、&lt;strong>虚拟机栈&lt;/strong> 和 &lt;strong>本地方法栈&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>总结：&lt;/strong> &lt;strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。&lt;/strong>&lt;/p>
&lt;p>下面是该知识点的扩展内容！&lt;/p>
&lt;p>下面来思考这样一个问题：为什么&lt;strong>程序计数器&lt;/strong>、&lt;strong>虚拟机栈&lt;/strong>和&lt;strong>本地方法栈&lt;/strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？&lt;/p>
&lt;h3 id="11-程序计数器为什么是私有的">1.1. 程序计数器为什么是私有的?&lt;/h3>
&lt;p>程序计数器主要有下面两个作用：&lt;/p>
&lt;ol>
&lt;li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。&lt;/li>
&lt;li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。&lt;/li>
&lt;/ol>
&lt;p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。&lt;/p>
&lt;p>所以，程序计数器私有主要是为了&lt;strong>线程切换后能恢复到正确的执行位置&lt;/strong>。&lt;/p>
&lt;h3 id="12-虚拟机栈和本地方法栈为什么是私有的">1.2. 虚拟机栈和本地方法栈为什么是私有的?&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>虚拟机栈：&lt;/strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。&lt;/li>
&lt;li>&lt;strong>本地方法栈：&lt;/strong> 和虚拟机栈所发挥的作用非常相似，区别是： &lt;strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。&lt;/strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。&lt;/li>
&lt;/ul>
&lt;p>所以，为了&lt;strong>保证线程中的局部变量不被别的线程访问到&lt;/strong>，虚拟机栈和本地方法栈是线程私有的。&lt;/p>
&lt;h3 id="13-一句话简单了解堆和方法区">1.3. 一句话简单了解堆和方法区&lt;/h3>
&lt;p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/p>
&lt;h2 id="2-说说并发与并行的区别">2. 说说并发与并行的区别?&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>并发：&lt;/strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；&lt;/li>
&lt;li>&lt;strong>并行：&lt;/strong> 单位时间内，多个任务同时执行。&lt;/li>
&lt;/ul>
&lt;h2 id="3-说说线程的生命周期">3. 说说线程的生命周期&lt;/h2>
&lt;blockquote>
&lt;p>参考文章：&lt;a href="http://chenxq.xyz/post/java-lifecycle-of-thread/">Java 多线程 - 线程生命周期&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="4-什么是上下文切换">4. 什么是上下文切换?&lt;/h2>
&lt;p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。&lt;/p>
&lt;p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。&lt;strong>任务从保存到再加载的过程就是一次上下文切换&lt;/strong>。&lt;/p>
&lt;p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。&lt;/p>
&lt;p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。&lt;/p>
&lt;h2 id="5-什么是线程死锁如何避免死锁">5. 什么是线程死锁？如何避免死锁？&lt;/h2>
&lt;blockquote>
&lt;p>参考文章：https://chenxq.xyz/post/java-multithread-dead-lock/&lt;/p>
&lt;/blockquote>
&lt;h2 id="6-说说-sleep-方法和-wait-方法区别和共同点">6. 说说 sleep() 方法和 wait() 方法区别和共同点?&lt;/h2>
&lt;p>&lt;strong>共同点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>wait 和 sleep 方法都可以使线程进入阻塞状态&lt;/li>
&lt;li>wait 和 sleep 方法均是可中断方法，被中断后都会收到中断异常。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>区别：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>wait是Object的方法，而sleep是Thread特有的方法。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>&lt;strong>sleep 方法没有释放锁，而 wait 方法释放了锁&lt;/strong> 。&lt;/li>
&lt;li>wait方法的执行必须在同步方法中进行，而sleep则不需要。&lt;/li>
&lt;li>sleep方法短暂休眠之后会主动退出阻塞，而wait方法（没有指定wait时间）则需要被其他线程中断后才能退出阻塞。&lt;/li>
&lt;/ul>
&lt;h2 id="7-为什么我们调用-start-方法时会执行-run-方法为什么我们不能直接调用-run-方法">7. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？&lt;/h2>
&lt;p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！&lt;/p>
&lt;p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。&lt;/p>
&lt;p>&lt;strong>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。&lt;/strong>&lt;/p></description></item><item><title>Java 多线程 - 深入理解synchronized关键字</title><link>https://ahamoment.cn/post/java-multithread-synchronized2/</link><pubDate>Sun, 25 Oct 2020 07:20:03 +0800</pubDate><guid>https://ahamoment.cn/post/java-multithread-synchronized2/</guid><description>
&lt;p>synchronized关键字提供了一种互斥机制，也就是说在同一时刻，只能有一个线程访问同步资源，很多资料、书籍将synchronized（mutex）称为锁，其实这种说法是不严谨的，准确地讲应该是某线程获取了与mutex关联的monitor锁（当然写程序的时候知道它想要表达的语义即可）。&lt;/p>
&lt;p>使用JDK命令javap对Mutex class进行反汇编，输出了大量的JVM指令，在这些指令中，你将发现monitor enter和monitor exit是成对出现的（有些时候会出现一个monitor enter多个monitor exit，但是每一个monitor exit之前必有对应的monitor enter，这是肯定的）.&lt;/p>
&lt;ul>
&lt;li>Monitorenter
每个对象都与一个monitor相关联，一个monitor的lock的锁只能被一个线程在同一时间获得，在一个线程尝试获得与对象关联monitor的所有权时会发生如下的几件事情。
&lt;ul>
&lt;li>如果monitor的计数器为0，则意味着该monitor的lock还没有被获得，某个线程获得之后将立即对该计数器加一，从此该线程就是这个monitor的所有者了。&lt;/li>
&lt;li>如果一个已经拥有该monitor所有权的线程重入，则会导致monitor计数器再次累加。&lt;/li>
&lt;li>如果monitor已经被其他线程所拥有，则其他线程尝试获取该monitor的所有权时，会被陷入阻塞状态直到monitor计数器变为0，才能再次尝试获取对monitor的所有权。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Monitorexit
释放对monitor的所有权，想要释放对某个对象关联的monitor的所有权的前提是，你曾经获得了所有权。释放monitor所有权的过程比较简单，就是将monitor的计数器减一，如果计数器的结果为0，那就意味着该线程不再拥有对该monitor的所有权，通俗地讲就是解锁。与此同时被该monitor block的线程将再次尝试获得对该monitor的所有权。&lt;/li>
&lt;/ul>
&lt;p>使用synchronized方法需要注意几个问题：&lt;/p>
&lt;ol>
&lt;li>与monitor关联的对象不能为空&lt;/li>
&lt;li>synchronized作用域太大
由于synchronized关键字存在排他性，也就是说所有的线程必须串行地经过synchronized保护的共享区域，如果synchronized作用域越大，则代表着其效率越低，甚至还会丧失并发的优势。&lt;/li>
&lt;li>不同的monitor企图锁相同的方法&lt;/li>
&lt;li>多个锁的交叉导致死锁&lt;/li>
&lt;/ol></description></item><item><title>Java 多线程 - 线程中断 Interrupt</title><link>https://ahamoment.cn/post/java-multithread-interrupt/</link><pubDate>Sat, 24 Oct 2020 07:17:54 +0800</pubDate><guid>https://ahamoment.cn/post/java-multithread-interrupt/</guid><description>
&lt;p>线程interrupt，是一个非常重要的API，也是经常使用的方法，在本文中我们将Thread深入源码对其进行详细的剖析。&lt;/p>
&lt;p>首先来看一下与线程中断相关的几个API：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">interrupt&lt;/span>&lt;span class="o">()&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">interrupted&lt;/span>&lt;span class="o">()&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isInterrupted&lt;/span>&lt;span class="o">()&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="interrupt">interrupt&lt;/h2>
&lt;p>如下方法的调用会使得当前线程进入阻塞状态，而调用当前线程的interrupt方法，就可以打断阻塞。&lt;/p>
&lt;ul>
&lt;li>Object的wait方法。&lt;/li>
&lt;li>Object的wait（long）方法。&lt;/li>
&lt;li>Object的wait（long，int）方法。&lt;/li>
&lt;li>Thread的sleep（long）方法。&lt;/li>
&lt;li>Thread的sleep（long，int）方法。&lt;/li>
&lt;li>Thread的join方法。&lt;/li>
&lt;li>Thread的join（long）方法。&lt;/li>
&lt;li>Thread的join（long，int）方法。&lt;/li>
&lt;li>InterruptibleChannel的io操作。&lt;/li>
&lt;li>Selector的wakeup方法。&lt;/li>
&lt;/ul>
&lt;p>上述若干方法都会使得当前线程进入阻塞状态，若另外的一个线程调用被阻塞线程的interrupt方法，则会打断这种阻塞，因此这种方法有时会被称为可中断方法，记住，打断一个线程并不等于该线程的生命周期结束，仅仅是打断了当前线程的阻塞状态。&lt;/p>
&lt;p>一旦线程在阻塞的情况下被打断，都会抛出一个称为&lt;code>InterruptedException&lt;/code>的异常，这个异常就像一个signal（信号）一样通知当前线程被打断了，下面我们来看一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.concurrent.TimeUnit&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ThreadInterrupt&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">InterruptedException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="n">thread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MINUTES&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Oh, i am be interrupted.&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="o">});&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="c1">//short block and make sure thread is started.
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MILLISECONDS&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">interrupt&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码创建了一个线程，并且企图休眠1分钟的时长，不过很可惜，大约在2毫秒之后就被主线程调用interrupt方法打断，程序的执行结果就是“Oh，i am be interrupted.”&lt;/p>
&lt;p>interrupt这个方法到底做了什么样的事情呢？在一个线程内部存在着名为&lt;strong>interrupt flag&lt;/strong>的标识，&lt;strong>如果一个线程被interrupt，那么它的flag将被设置，但是如果当前线程正在执行可中断方法被阻塞时，调用interrupt方法将其中断，反而会导致flag被清除&lt;/strong>，关于这点我们在后面还会做详细的介绍。另外有一点需要注意的是，如果一个线程已经是死亡状态，那么尝试对其的interrupt会直接被忽略。&lt;/p>
&lt;h2 id="isinterrupted">isInterrupted&lt;/h2>
&lt;p>isInterrupted是Thread的一个成员方法，它主要判断当前线程是否被中断，该方法仅仅是对interrupt标识的一个判断，并不会影响标识发生任何改变，这个与我们即将学习到的interrupted是存在差别的，下面我们看一个简单的程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ThreadisInterrupted&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">InterruptedException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="n">thread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="c1">//do nothing, just empty loop.
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">};&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MILLISECONDS&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Thread is interrupted ? ％s\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isInterrupted&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">interrupt&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Thread is interrupted ? ％s\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isInterrupted&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">17&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码中定义了一个线程，并且在线程的执行单元中（run方法）写了一个空的死循环，为什么不写sleep呢？因为sleep是可中断方法，会捕获到中断信号，从而干扰我们程序的结果。下面是程序运行的结果，记得手动结束上面的程序运行，或者你也可以将上面定义的线程指定为守护线程，这样就会随着主线程的结束导致JVM中没有非守护线程而自动退出。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="n">Thread&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">interrupted&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">Thread&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">interrupted&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>可中断方法捕获到了中断信号（signal）之后，也就是捕获了InterruptedException异常之后会擦除掉interrupt的标识&lt;/strong>，对上面的程序稍作修改，你会发现程序的结果又会出现很大的不同，示例代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ThreadisInterrupted&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">InterruptedException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="n">thread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MINUTES&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="c1">//ignore the exception
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//here the interrupt flag will be clear.
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//由于可中断方法的异常被捕获后，会擦除掉interrup标记，所以调用
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//isInterrupted返回false
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;I am be interrupted ? ％s&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">isInterrupted&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">};&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MILLISECONDS&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Thread is interrupted ? ％s\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isInterrupted&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">interrupt&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Thread is interrupted ? ％s\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isInterrupted&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于在run方法中使用了sleep这个可中断方法，它会捕获到中断信号，并且会擦除interrupt标识，因此程序的执行结果都会是false，程序输出如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>Thread is interrupted ? false
&lt;span class="ln">2&lt;/span>I am be interrupted ? false
&lt;span class="ln">3&lt;/span>Thread is interrupted ? false
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实这也不难理解，可中断方法捕获到了中断信号之后，为了不影响线程中其他方法的执行，将线程的interrupt标识复位是一种很合理的设计。&lt;/p>
&lt;h2 id="interrupted">interrupted&lt;/h2>
&lt;p>interrupted是一个静态方法，虽然其也用于判断当前线程是否被中断，但是它和成员方法isInterrupted还是有很大的区别的，&lt;strong>调用该方法会直接擦除掉线程的interrupt标识&lt;/strong>，需要注意的是，&lt;strong>如果当前线程被打断了，那么第一次调用interrupted方法会返回true，并且立即擦除了interrupt标识；第二次包括以后的调用永远都会返回false，除非在此期间线程又一次地被打断&lt;/strong>，下面设计了一个简单的例子，来验证我们的说法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ThreadisInterrupted&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">InterruptedException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="n">thread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">interrupted&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">};&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setDaemon&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="c1">//shortly block make sure the thread is started.
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MILLISECONDS&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">interrupt&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">17&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样由于不想要受到可中断方法如sleep的影响，在Thread的run方法中没有进行任何短暂的休眠，所以运行上面的程序会出现非常多的输出，但是我们通过对输出的检查会发现如下所示的内容，其足以作为对该方法的解释。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>……
&lt;span class="ln">2&lt;/span>false
&lt;span class="ln">3&lt;/span>false
&lt;span class="ln">4&lt;/span>true
&lt;span class="ln">5&lt;/span>false
&lt;span class="ln">6&lt;/span>false
&lt;span class="ln">7&lt;/span>……
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在很多的false包围中发现了一个true，也就是interrupted方法判断到了其被中断，立即擦除了中断标识，并且只有这一次返回true，后面的都将会是false。&lt;/p>
&lt;h2 id="interrupt-注意事项">interrupt 注意事项&lt;/h2>
&lt;p>打开Thread的源码，不难发现，isInterrupted方法和interrupted方法都调用了同一个本地方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">private&lt;/span> &lt;span class="kd">native&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isInterrupted&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">boolean&lt;/span> &lt;span class="n">ClearInterrupted&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中参数ClearInterrupted主要用来控制是否擦除线程interrupt的标识。&lt;code>isInterrupted&lt;/code>方法的源码中该参数为false，表示不想擦除：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isInterrupted&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">isInterrupted&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而interrupted静态方法中该参数则为true，表示想要擦除：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">interrupted&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">isInterrupted&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在比较详细地学习了interrupt方法之后，大家思考一个问题，如果一个线程在没有执行可中断方法之前就被打断，那么其接下来将执行可中断方法，比如sleep会发生什么样的情况呢？下面我们通过一个简单的实验来回答这个疑问：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ThreadisInterrupted&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="c1">//① 判断当前线程是否被中断
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// flag=false,清除线程中断标志
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Main thread is interrupted? &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">interrupted&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="c1">//②中断当前线程
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// flag=true
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">interrupt&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="c1">//③判断当前线程是否已经被中断
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 这里不能再调用Thread.interrupted()，因为会将flag清除，达不到实验效果
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Main thread is interrupted? &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">isInterrupted&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="c1">//④ 当前线程执行可中断方法
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MINUTES&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="c1">//⑤捕获中断信号
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;I will be interrupted still.&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过运行上面的程序，你会发现，如果一个线程设置了interrupt标识，那么接下来的可中断方法会立即中断，因此注释⑤的信号捕获部分代码会被执行.&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>【1】&lt;a href="https://book.douban.com/subject/30255689/">《Java 高并发编程详解》-汪文君&lt;/a>&lt;/p></description></item><item><title>JVM 内存结构</title><link>https://ahamoment.cn/post/java-jvm-jmm/</link><pubDate>Thu, 15 Oct 2020 19:55:31 +0800</pubDate><guid>https://ahamoment.cn/post/java-jvm-jmm/</guid><description>
&lt;blockquote>
&lt;p>&lt;a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf">http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>JVM在执行Java程序的时候会把对应的物理内存划分成不同的内存区域，每一个区域都存放着不同的数据，也有不同的创建与销毁时机，有些分区会在JVM启动的时候就创建，有些则是在运行时才创建，比如虚拟机栈，根据虚拟机规范，JVM的内存结构如图所示。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20201015200212590.png" alt="image-20201015200212590">&lt;/p>
&lt;h2 id="程序计数器">程序计数器&lt;/h2>
&lt;p>无论任何语言，其实最终都是需要由操作系统通过控制总线向CPU发送机器指令，Java也不例外，程序计数器在JVM中所起的作用就是用于存放当前线程接下来将要执行的字节码指令、分支、循环、跳转、异常处理等信息。在任何时候，一个处理器只执行其中一个线程中的指令，为了能够在CPU时间片轮转切换上下文之后顺利回到正确的执行位置，每条线程都需要具有一个独立的程序计数器，各个线程之间互相不影响，因此JVM将此块内存区域设计成了&lt;strong>线程私有&lt;/strong>的。&lt;/p>
&lt;h2 id="java-虚拟机栈">Java 虚拟机栈&lt;/h2>
&lt;p>与程序计数器内存相类似，Java虚拟机栈也是线程私有的，它的生命周期与线程相同，是在JVM运行时所创建的，在线程中，方法在执行的时候都会创建一个名为栈帧（stack frame）的数据结构，主要用于存放&lt;strong>局部变量表、操作栈、动态链接、方法出口&lt;/strong>等信息，如图所示，&lt;strong>方法的调用对应着栈帧在虚拟机栈中的压栈和弹栈过程&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20201015200832748.png" alt="image-20201015200832748">&lt;/p>
&lt;p>每一个线程在创建的时候，JVM都会为其创建对应的虚拟机栈，虚拟机栈的大小可以通过-xss来配置，方法的调用是栈帧被压入和弹出的过程，通过上图可以看出，同等的虚拟机栈如果局部变量表等占用内存越小则可被压入的栈帧就会越多，反之则可被压入的栈帧就会越少，一般将栈帧内存的大小称为宽度，而栈帧的数量则称为虚拟机栈的深度。&lt;/p>
&lt;h2 id="本地方法栈">本地方法栈&lt;/h2>
&lt;p>Java中提供了调用本地方法的接口（Java Native Interface），也就是C/C++程序，在线程的执行过程中，经常会碰到调用JNI方法的情况，比如网络通信、文件操作的底层，甚至是String的intern等都是JNI方法，JVM为本地方法所划分的内存区域便是本地方法栈，这块内存区域其自由度非常高，完全靠不同的JVM厂商来实现，Java虚拟机规范并未给出强制的规定，同样它也是线程私有的内存区域。&lt;/p>
&lt;h2 id="堆内存">堆内存&lt;/h2>
&lt;p>堆内存是JVM中最大的一块内存区域，被所有的线程所共享，Java在运行期间创建的所有对象几乎都存放在该内存区域，该内存区域也是垃圾回收器重点照顾的区域，因此有些时候堆内存被称为“GC堆”。&lt;/p>
&lt;p>堆内存一般会被细分为新生代和老年代，更细致的划分为Eden区、From Survivor区和To Survivor区，如图所示。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20201015201006211.png" alt="image-20201015201006211">&lt;/p>
&lt;p>堆内存一般会被细分为新生代和老年代，更细致的划分为Eden区、From Survivor区和To Survivor区。&lt;/p>
&lt;h2 id="方法区">方法区&lt;/h2>
&lt;p>方法区也是被多个线程所共享的内存区域，他主要用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT）编译后的代码等数据，虽然在Java虚拟机规范中，将堆内存划分为堆内存的一个逻辑分区，但是它还是经常被称为“非堆”，有时候也被称为“持久代”，主要是站在垃圾回收器的角度进行划分，但是这种叫法比较欠妥，在HotSpot JVM中，方法区还会被细划分为持久代和代码缓存区，代码缓存区主要用于存储编译后的本地代码（和硬件相关）以及JIT（Just In Time）编译器生成的代码，当然不同的JVM会有不同的实现。&lt;/p></description></item><item><title>Java 多线程 - 死锁问题</title><link>https://ahamoment.cn/post/java-multithread-dead-lock/</link><pubDate>Wed, 10 Jun 2020 19:21:07 +0800</pubDate><guid>https://ahamoment.cn/post/java-multithread-dead-lock/</guid><description>
&lt;p>锁是非常有用的工具，运用场景非常多，因为它使用起来非常方便，而且易于理解。但同时它也会带来一些困扰，那就是可能引起死锁。&lt;/p>
&lt;!-- more -->
&lt;h2 id="1-什么是死锁">1. 什么是死锁&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://baike.baidu.com/item/%E6%AD%BB%E9%94%81/2196938?fr=aladdin">百度百科中对于死锁的定义：&lt;/a>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。&lt;/p>
&lt;/blockquote>
&lt;p>简而言之，当线程1持有资源A，线程2持有资源B。此时线程1想要获取资源B，线程2想要获取资源A。两个线程都想要获取对方手中的资源，自己又不肯让出已有资源，一直僵持不下就形成了死锁。&lt;/p>
&lt;h2 id="2-死锁产生的四个条件">2. 死锁产生的四个条件&lt;/h2>
&lt;ul>
&lt;li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。&lt;/li>
&lt;li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。&lt;/li>
&lt;li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。&lt;/li>
&lt;li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。&lt;/li>
&lt;/ul>
&lt;h2 id="3-案例">3. 案例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">DeadLock&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">OtherService&lt;/span> &lt;span class="n">otherService&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 3&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setOtherService&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">OtherService&lt;/span> &lt;span class="n">otherService&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">otherService&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">otherService&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 7&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="c1">// DeadLock的实例的锁-资源A
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="n">LOCK&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">m1&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">LOCK&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;********m1********&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">otherService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">s1&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">17&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">m2&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">LOCK&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;********m2********&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">24&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">OtherService&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">26&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">DeadLock&lt;/span> &lt;span class="n">deadLock&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">28&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setDeadLock&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">DeadLock&lt;/span> &lt;span class="n">deadLock&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">deadLock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">deadLock&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">32&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="c1">// OtherService的实例的锁-资源B
&lt;/span>&lt;span class="ln">34&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="n">LOCK&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">35&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">s1&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">37&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">LOCK&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">38&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;========s1========&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">39&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">40&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">41&lt;/span>
&lt;span class="ln">42&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">s2&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">43&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">LOCK&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">44&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;========s2========&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">45&lt;/span> &lt;span class="n">deadLock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">m2&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">46&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">47&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">48&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">49&lt;/span>
&lt;span class="ln">50&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">DeadLockTest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">51&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">52&lt;/span> &lt;span class="n">DeadLock&lt;/span> &lt;span class="n">deadLock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">DeadLock&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">53&lt;/span> &lt;span class="n">OtherService&lt;/span> &lt;span class="n">otherService&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">OtherService&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">54&lt;/span> &lt;span class="n">deadLock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setOtherService&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">otherService&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">55&lt;/span> &lt;span class="n">otherService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setDeadLock&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">deadLock&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">56&lt;/span>
&lt;span class="ln">57&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">58&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">59&lt;/span> &lt;span class="n">deadLock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">m1&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">60&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">61&lt;/span> &lt;span class="o">},&lt;/span> &lt;span class="s">&amp;#34;T1&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">62&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">63&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">64&lt;/span> &lt;span class="n">otherService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">s2&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">65&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">66&lt;/span> &lt;span class="o">},&lt;/span> &lt;span class="s">&amp;#34;T2&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">67&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">68&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的案例中，两个线程 T1 和 T2 , 其中 T1 线程调用 DeadLock 的 m1 方法，在 m1 方法内部又调用了 OtherService 的 s1 方法，s1 和 m1 这两个方法都含有用 synchronized 关键字修饰的同步代码块。 T2 线程调用 OtherService 的 s2 方法，在 s2 方法内又调用的 DeadLock 的 m2 方法，同样的，s2 和 m1 这两个方法都含有用 synchronized 关键字修饰的同步代码块。整个程序如图所示：&lt;/p>
&lt;p>&lt;img src="https://imgconvert.csdnimg.cn/aHR0cDovL3Fha2dsNmVueC5ia3QuY2xvdWRkbi5jb20vcGljZ28vaW1hZ2UtMjAyMDA2MTAxODAwMTQwNzAucG5n?x-oss-process=image/format,png" alt="image-20200610180014070">&lt;/p>
&lt;p>当 T1 线程执行的时候，m1 方法获取 DeadLock 的 LOCK 锁，并调用 OtherService 的 s1 方法，同时，T2 线程也开始执行，T2 线程获取到 OtherService 的 LOCK 锁，并调用 DeadLock 的 m2 方法，但是由于 m2 的方法的锁此时已经被 T1 线程占有，T2 线程只能等待 T1 线程释放锁，同理，T1 线程也在等待 T2 线程释放锁，于是就形成了死锁。&lt;/p>
&lt;p>我们使用 jstack 来观察一下死锁。&lt;/p>
&lt;p>&lt;img src="https://imgconvert.csdnimg.cn/aHR0cDovL3Fha2dsNmVueC5ia3QuY2xvdWRkbi5jb20vcGljZ28vaW1hZ2UtMjAyMDA2MTAxODA1MTM4NjkucG5n?x-oss-process=image/format,png" alt="image-20200610180513869">&lt;/p>
&lt;p>首先看到这两个线程互相持有对象的锁，在等待对方释放锁。&lt;/p>
&lt;p>&lt;img src="https://imgconvert.csdnimg.cn/aHR0cDovL3Fha2dsNmVueC5ia3QuY2xvdWRkbi5jb20vcGljZ28vaW1hZ2UtMjAyMDA2MTAxODA2MjA2NTUucG5n?x-oss-process=image/format,png" alt="image-20200610180620655">&lt;/p>
&lt;p>jstack 的信息最后也会告诉我们找到一个死锁。&lt;/p>
&lt;h2 id="4-如何避免死锁">4. 如何避免死锁&lt;/h2>
&lt;ul>
&lt;li>避免一个线程同时获取多个锁。&lt;/li>
&lt;li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。&lt;/li>
&lt;li>尝试使用定时锁，使用 lock.tryLock(timeout) 来替代使用内部锁机制。&lt;/li>
&lt;li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。&lt;/li>
&lt;/ul></description></item><item><title>Java 多线程 - 初识 Synchronized</title><link>https://ahamoment.cn/post/java-multithread-synchronized/</link><pubDate>Wed, 10 Jun 2020 19:16:24 +0800</pubDate><guid>https://ahamoment.cn/post/java-multithread-synchronized/</guid><description>
&lt;h2 id="synchronized-简介">Synchronized 简介&lt;/h2>
&lt;blockquote>
&lt;p>本文出自汪文君老师的《Java 并发编程》课程，如需转载，请注明源出处！&lt;/p>
&lt;/blockquote>
&lt;p>先来看一个例子，这个例子是模拟银行叫号的，使用三个线程模拟三个柜台一起叫号，总共50个号。在不加 synchronized 的关键字的情况下，很容易就会出现并发问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">BankRunnable&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="c1">// 一个runnable实例被多个线程共享
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">TicketWindowRunnable&lt;/span> &lt;span class="n">ticketWindow&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TicketWindowRunnable&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="n">windowThread1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ticketWindow&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;一号窗口&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="n">windowThread2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ticketWindow&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;二号窗口&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="n">windowThread3&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ticketWindow&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;三号窗口&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">windowThread1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">windowThread2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">windowThread3&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">14&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">TicketWindowRunnable&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Runnable&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">MAX&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">50&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">18&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">MAX&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//1
&lt;/span>&lt;span class="ln">23&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">30&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">()+&lt;/span>&lt;span class="s">&amp;#34; 的号码是：&amp;#34;&lt;/span>&lt;span class="o">+(&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">++));&lt;/span>&lt;span class="c1">//2
&lt;/span>&lt;span class="ln">32&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">34&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>多运行几遍程序，就会出现下面这个问题：&lt;/p>
&lt;p>&lt;img src="https://imgconvert.csdnimg.cn/aHR0cDovL3Fha2dsNmVueC5ia3QuY2xvdWRkbi5jb20vcGljZ28vaW1hZ2UtMjAyMDA2MDMxOTIyMjA1MTcucG5n?x-oss-process=image/format,png" alt="image-20200603192220517">&lt;/p>
&lt;p>在一号窗口拿完最后一个号码之后，二号窗口和三号窗口又后续拿到了 52 和 51 号。为什么会出现这种现象呢？&lt;/p>
&lt;p>首先当 &lt;code>index=499&lt;/code> 的时候，三个线程均不满足 &lt;code>index &amp;gt; MAX&lt;/code>，都会向下执行。三个线程都可以向下执行，将 index 加 1。&lt;/p>
&lt;p>为了解决这个问题，这里引入了 synchronized 。&lt;/p>
&lt;h2 id="什么是-synchronized">什么是 synchronized&lt;/h2>
&lt;blockquote>
&lt;p>synchronized关键字可以实现一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象对多个线程是可见的，那么对该对象的所有读或者写都将通过同步的方式来进行。&lt;/p>
&lt;/blockquote>
&lt;p>上面这段话是oracle官网对synchronized关键字的解释，具体表现如下：&lt;/p>
&lt;ul>
&lt;li>synchronized关键字提供了一种锁的机制，能够确保共享变量的互斥访问，从而防止数据不一致问题的出现。&lt;/li>
&lt;li>synchronized关键字包括monitor enter和monitor exit两个JVM指令，它能够保证在任何时候任何线程执行到monitor enter成功之前都必须从主内存中获取数据，而不是从缓存中，在monitor exit运行成功之后，共享变量被更新后的值必须刷入主内存（在本书的第三部分会重点介绍）。&lt;/li>
&lt;li>synchronized的指令严格遵守java happens-before规则，一个monitor exit指令之前必定要有一个monitor enter。&lt;/li>
&lt;/ul>
&lt;h2 id="synchronized关键字的用法">synchronized关键字的用法&lt;/h2>
&lt;p>Java通过 synchronized 对共享数据的线程访问提供了一种避免竞争条件的机制。synchronized 可以修饰方法或者代码块，被修饰的方法或者代码块同一时间只会允许一个线程执行，这条执行的线程持有同步部分的锁。synchronized 方法不能用于对class及其变量进行修饰。&lt;/p>
&lt;p>synchronized 关键字可以修饰方法或者代码块，那么这两者有什么区别呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1">// 同步代码块
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">TicketWindowRunnable&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Runnable&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">MAX&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">500&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="n">MONITOR&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 7&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">MONITOR&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">MAX&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; 的号码是：&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">++));&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>synchronized 方法修饰代码块的时候，使用的是 monitor 锁。再来用 synchronized 修饰一下同步方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="nd">@Override&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">MAX&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">12&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; 的号码是：&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">++));&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行之后发现都是同一个线程在跑，另外两个线程无法执行。这是因为 synchronized 在修饰方法的时候使用的是 this 锁，当其中一个线程拿到锁进到 while 循环之后，就一直去做事情，直到满足条件退出为止。将 while 里面的代码抽出来放到一个方法里，用 synchronized 来修饰该方法就可以解决这个问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="nd">@Override&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">ticket&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="kd">private&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">ticket&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">MAX&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; 的号码是：&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">++));&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>synchronized 修饰方法时默认是使用的 this 锁，修饰代码块时使用的是对象锁。synchronized 关键字还可以用来修饰静态方法和静态代码块。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SynchronizedStatic&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">m1&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;m1 &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">10_000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">m2&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;m2 &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">10_000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">21&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SynchronizedStaticTest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;T1&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="n">SynchronizedStatic&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">m1&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="o">}.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">30&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;T2&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="n">SynchronizedStatic&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">m2&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">35&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="o">}.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">37&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">38&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">39&lt;/span>
&lt;span class="ln">40&lt;/span>&lt;span class="c1">// output
&lt;/span>&lt;span class="ln">41&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">m1&lt;/span> &lt;span class="n">T1&lt;/span>
&lt;span class="ln">42&lt;/span>&lt;span class="n">m2&lt;/span> &lt;span class="n">T2&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>静态方法 m1 和 m2 同时被 synchronized 修饰，这个时候线程 T2 会等到线程 T1 执行完再执行，说明这两个方法使用的是同一把锁，这就是 Class 锁。我们把 sleep 的时间变长一点来观察一下是不是 Class 锁。&lt;/p>
&lt;p>&lt;img src="https://imgconvert.csdnimg.cn/aHR0cDovL3Fha2dsNmVueC5ia3QuY2xvdWRkbi5jb20vcGljZ28vaW1hZ2UtMjAyMDA2MDkxOTE1NTc0NTUucG5n?x-oss-process=image/format,png" alt="image-20200609191557455">&lt;/p>
&lt;p>&lt;img src="https://imgconvert.csdnimg.cn/aHR0cDovL3Fha2dsNmVueC5ia3QuY2xvdWRkbi5jb20vcGljZ28vaW1hZ2UtMjAyMDA2MDkxOTE2Mjk4NjcucG5n?x-oss-process=image/format,png" alt="image-20200609191629867">&lt;/p>
&lt;p>可以看到，线程 T1 执行的时候，持有的是 Class 锁，此时线程 T2 在等待 T1 执行完释放锁，当 T1 执行完之后，T2 拿到 Class 锁执行代码。&lt;/p>
&lt;p>&lt;img src="https://imgconvert.csdnimg.cn/aHR0cDovL3Fha2dsNmVueC5ia3QuY2xvdWRkbi5jb20vcGljZ28vaW1hZ2UtMjAyMDA2MDkxOTE4MTIwODYucG5n?x-oss-process=image/format,png" alt="image-20200609191812086">&lt;/p>
&lt;p>了解了 synchronized 修饰静态方法使用的是 Class 锁之后，我们再来验证一下当它修饰静态方法的时候是不是也是使用 Class 锁？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SynchronizedStatic&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">m1&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;m1 &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">100_000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">m3&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;m3 &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">10_000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SynchronizedStaticTest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;T1&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="n">SynchronizedStatic&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">m1&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="o">}.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">29&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;T3&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="n">SynchronizedStatic&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">m3&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">35&lt;/span> &lt;span class="o">}.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">37&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里加了一个没有 synchronized 修饰的静态方法 m3，运行之后很容易知道，这两个线程是同时运行的。我们在 SynchronizedStatic 开始的地方加一个静态代码块，静态代码块内部使用 synchronized 锁。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SynchronizedStatic&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">SynchronizedStatic&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;static &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">10_000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">12&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">m1&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;m1 &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">100_000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">21&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">m3&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;m3 &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">10_000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">30&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">31&lt;/span>
&lt;span class="ln">32&lt;/span>&lt;span class="c1">//output
&lt;/span>&lt;span class="ln">33&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">static&lt;/span> &lt;span class="n">T1&lt;/span>
&lt;span class="ln">34&lt;/span>&lt;span class="n">m1&lt;/span> &lt;span class="n">T1&lt;/span>
&lt;span class="ln">35&lt;/span>&lt;span class="n">m3&lt;/span> &lt;span class="n">T3&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以发现，T1 线程要先执行静态代码块才能往下走，说明静态代码块使用的锁和静态方法是一样的，另外这个时候没有用 synchronized 修饰的 m3 也要等静态代码块执行实例化才行。&lt;/p>
&lt;p>总结一下，synchronized 关键字能够避免多线程竞争导致的数据不一致，被 synchronized 修饰的方法或者代码块同一时间只会允许一个线程执行，这条执行的线程持有同步部分的锁。synchronized 关键字修饰普通方法时，使用的是 this 锁，修饰静态方法和静态代码块时，使用 Class 锁，修饰代码块时，使用 LOCK 锁。&lt;/p></description></item><item><title>JDK1.8 源代码阅读环境搭建</title><link>https://ahamoment.cn/post/java-source-code-learn/</link><pubDate>Mon, 11 May 2020 18:57:51 +0800</pubDate><guid>https://ahamoment.cn/post/java-source-code-learn/</guid><description>
&lt;h2 id="一准备">一、准备&lt;/h2>
&lt;p>Itellj IDEA， jdk1.8 的源代码包(解压 jdk 目录下的 src.zip 包得到)&lt;/p>
&lt;h2 id="二项目结构">二、项目结构&lt;/h2>
&lt;p>IDEA 创建一个普通的 java 项目
&lt;img src="https://img-blog.csdnimg.cn/20200511113652329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">
把解压得到的 jdk1.8 的源代码复制到 source 目录下：
&lt;img src="https://img-blog.csdnimg.cn/20200511113748267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">
test 目录用来写测试用例, 这里用不到 Main 方法。&lt;/p>
&lt;h2 id="三idea-设置">三、IDEA 设置&lt;/h2>
&lt;ol>
&lt;li>Project Structure -&amp;gt; Project 设置项目的 SDK (jdk8u221)，language level 选择 &lt;code>8 - Lambdas, type annotations etc.&lt;/code>
&lt;img src="https://img-blog.csdnimg.cn/20200511114245184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&lt;/li>
&lt;li>Project Structure -&amp;gt; Dependencies 选择 Modules，SDK 选择 1.8_221
&lt;img src="https://img-blog.csdnimg.cn/2020051111442075.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&lt;/li>
&lt;li>设置平台的 SDK 源代码路径为自己项目的 source 目录
&lt;img src="https://img-blog.csdnimg.cn/20200511114621171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&lt;/li>
&lt;li>调整编译线程的堆大小，避免内存不足，编译无法通过，调整到 1G 以上。
&lt;img src="https://img-blog.csdnimg.cn/20200511114759326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&lt;/li>
&lt;li>IDEA 默认调试是不会进入到 jdk 的源代码的，在 Debugger 设置中允许进入到 jdk 的包
&lt;img src="https://img-blog.csdnimg.cn/20200511115000586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">
到这里，我们完成了 idea 的设置，可以开始写个测试程序编译运行。&lt;/li>
&lt;/ol>
&lt;h2 id="四编译调式">四、编译调式&lt;/h2>
&lt;p>创建一个测试类进行调试：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.HashMap&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.Map&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 3&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Test&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">Map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Double&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">hashMap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HashMap&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">hashMap&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;k1&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">hashMap&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;k2&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">2&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">hashMap&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;k3&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">3&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">hashMap&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;k4&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">4&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>进入 debug 之后，就可以在源代码里写一些笔记了。
&lt;img src="https://img-blog.csdnimg.cn/20200511115402489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&lt;/p>
&lt;h2 id="五编译问题">五、编译问题&lt;/h2>
&lt;p>经常碰到的几个问题：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>缺少com.sun.tools包&lt;/li>
&lt;li>缺少sun.awt.UNIXToolkit 和 sun.font.FontConfigManager这两个类&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>解决办法可以参考这篇博客：&lt;a href="https://www.jianshu.com/p/c00db010265b">JDK1.8源码分析03之idea搭建源码阅读环境&lt;/a>&lt;/p></description></item><item><title>IntellJ IDEA 远程调试 Java 程序</title><link>https://ahamoment.cn/post/java-remote-debug/</link><pubDate>Thu, 21 Nov 2019 20:04:16 +0800</pubDate><guid>https://ahamoment.cn/post/java-remote-debug/</guid><description>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20191120184024931.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_20,color_FFFFFF,t_70" alt="java remote debug">&lt;/p>
&lt;h2 id="1-前言">1. 前言&lt;/h2>
&lt;p>当我们发现服务器上的应用发生某些故障，并且没有足够的日志来定位问题的时候，就会觉得非常头疼，尤其是在生产环境中想要对应用进行调试并非易事。在本文中，我们使用Java平台提供的标准功能来配置正在运行的Web服务器和调试应用程序。&lt;/p>
&lt;h2 id="2-配置">2. 配置&lt;/h2>
&lt;p>在开始之前，我们有必要介绍一下本文的示例工程所用的工具和环境：&lt;/p>
&lt;ul>
&lt;li>应用使用spring boot框架，部署在linux中，由于 spring boot 内置tomcat服务器，因此部署的时通过maven/gradle打包后，直接用 &lt;code>java -jar test.jar&lt;/code> 命令启动应用。&lt;/li>
&lt;li>调试工具用的是IntelliJ idea&lt;/li>
&lt;/ul>
&lt;h3 id="21-java-启动参数配置">2.1 Java 启动参数配置&lt;/h3>
&lt;p>Java Platform Debugging Architecture（JPDA）是一组可扩展的API，其中一部分是称为JDWP（Java Debug Wire Protocol）的特殊调试协议。&lt;/p>
&lt;p>JDWP是用于在应用程序和调试器进程之间进行通信的协议，可用于对正在运行的Java应用程序进行远程故障排除。&lt;/p>
&lt;p>要配置远程应用程序进行调试，您必须在Java应用的启动参数中为此协议指定参数。&lt;/p>
&lt;p>&lt;code>java -Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=y Test&lt;/code>&lt;/p>
&lt;p>这些参数要做的事情就是启用远程调试和配置有效的选项：&lt;/p>
&lt;ul>
&lt;li>&lt;code>-Xdebug&lt;/code>：参数启用debug调试特性&lt;/li>
&lt;li>&lt;code>-Xrunjdwp&lt;/code>：使用几个重要参数配置JDWP协议。&lt;/li>
&lt;/ul>
&lt;p>从 JDK5 开始，可以使用 &lt;code>-agentlib:jdwp&lt;/code> 选项，而不是 &lt;code>-Xdebug&lt;/code> 和 &lt;code>-Xrunjdwp&lt;/code>。但如果连接到 JDK5 以前的 VM，只能选择 &lt;code>-Xdebug&lt;/code> 和 &lt;code>-Xrunjdwp&lt;/code>。&lt;/p>
&lt;p>&lt;code>java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8001 Test&lt;/code>&lt;/p>
&lt;p>JDK 9 之后， 由于Java 9 JDWP代理默认情况下仅侦听本地网络接口，因此将拒绝远程连接。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://www.oracle.com/technetwork/java/javase/9-notes-3745703.html#JDK-8041435">JDK 9 Realease Notes&lt;/a>
core-svc/debugger
JDWP socket connector accept only local connections by default
The JDWP socket connector has been changed to bind to localhost only if no ip address or hostname is specified on the agent command line. A hostname of asterisk (*) may be used to achieve the old behavior which is to bind the JDWP socket connector to all available interfaces; this is not secure and not recommended.&lt;/p>
&lt;/blockquote>
&lt;p>因此对于 JDK 9 及更高的版本，启动debug的命令如下：&lt;/p>
&lt;p>&lt;code>java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8001 Test&lt;/code>&lt;/p>
&lt;p>下面介绍一下jdwp提供的一些子选项参数：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>transport&lt;/code>：指定运行的被调试应用和调试者之间的通信协议。这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>server&lt;/code>：如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>suspend&lt;/code>：如果值为 n 用来告知 JVM 立即执行，不要等待未来将要附着上/连上（attached）的调试者。如果设成 y, 则应用将暂停不运行，直到有调试者连接上&lt;/p>
&lt;blockquote>
&lt;p>suspend=y的一个比较适用的场景是，当debug一个会阻止应用成功启动的问题时， 通过suspend=y可以确保调试者连上来之后再启动应用，否则应用已经启动报错了再调试也没意义了。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;code>address&lt;/code>：远程被调试应用开通的端口，可定义其他端口。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>服务端使用jdwp的调试参数成功启动后，我们可以看到java进程如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@test&lt;span class="o">]&lt;/span>$ ps -ef &lt;span class="p">|&lt;/span> grep java
&lt;span class="ln">2&lt;/span>root &lt;span class="m">1323&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">99&lt;/span> 11:36 ? 00:00:30 java -Dspring.profiles.active&lt;span class="o">=&lt;/span>default -agentlib:jdwp&lt;span class="o">=&lt;/span>&lt;span class="nv">transport&lt;/span>&lt;span class="o">=&lt;/span>dt_socket,server&lt;span class="o">=&lt;/span>y,suspend&lt;span class="o">=&lt;/span>n,address&lt;span class="o">=&lt;/span>&lt;span class="m">2222&lt;/span> -jar ./test.jar
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="22-intellij-idea-配置">2.2 IntelliJ idea 配置&lt;/h3>
&lt;p>首先保证 IDEA 里面已经打开了需要远程调试的代码，注意代码要与线上的代码一致，这里也可以用war/jar包来调。
然后点击 Run ➝ Edit Configurations ➝ **+ **按钮 ➝ Remote
&lt;img src="https://img-blog.csdnimg.cn/20191121114403417.png" alt="在这里插入图片描述">
&lt;img src="https://img-blog.csdnimg.cn/20191121114516147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">
这里只需要填好服务器的地址和debug端口后，点击&amp;quot;debug&amp;quot;按钮启动即可。
&lt;img src="https://img-blog.csdnimg.cn/20191121114850859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">
当我们看到打印出这行信息时，就可以对需要调试的代码打断点调试了。&lt;/p>
&lt;h2 id="3-远程-jvm-调试的工作原理">3. 远程 JVM 调试的工作原理&lt;/h2>
&lt;p>一切源于被称作 Agents 的东西。&lt;/p>
&lt;p>运行着各种编译过的 .class 文件的JVM， 有一种特性，可以允许外部的库（Java或C++写的libraries）在运行时注入到 JVM 中。这些外部的库就称作 Agents, 他们有能力修改运行中 .class 文件的内容。&lt;/p>
&lt;p>这些 Agents 拥有的这些 JVM 的功能权限， 是在 JVM 内运行的 Java Code 所无法获取的， 他们能用来做一些有趣的事情，比如修改运行中的源码， 性能分析等。 像 JRebel 工具就是用了这些功能达到魔术般的效果。&lt;/p>
&lt;p>传递一个 Agent Lib 给 JVM, 通过添加 &lt;code>agentlib:libname[=options]&lt;/code> 格式的启动参数即可办到。像上面的远程调试我们用的就是
&lt;code>-agentlib:jdwp=transport=dt_socket,address=1043,server=y,suspend=n&lt;/code>来引入 jdwp 这个 Agent 的。&lt;/p>
&lt;p>jdwp 是一个 JVM 特定的 JDWP（Java Debug Wire Protocol） 可选实现，用来定义调试者与运行JVM之间的通讯，它的是通过 JVM 本地库的 jdwp.so 或者 jdwp.dll 支持实现的。&lt;/p>
&lt;p>JPDA 由两个接口（分别是 JVM Tool Interface 和 JDI）、一个协议（Java Debug Wire Protocol）和两个用于合并它们的软件组件（后端和前端）组成。
&lt;img src="https://img-blog.csdnimg.cn/20191121120557909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4cTIxMTE1MDQxMDQ=,size_16,color_FFFFFF,t_70" alt="Java 调试平台架构">&lt;/p>
&lt;ul>
&lt;li>JVM TI-Java VM工具接口。JVM TI是J2SE 5.0中引入的新接口，它替代了JVMDI。它定义了VM提供的调试服务。&lt;/li>
&lt;li>JDWP-Java调试线协议。定义调试对象和调试器进程之间的通信。&lt;/li>
&lt;li>JDI-Java调试接口。定义高级Java语言界面，工具开发人员可以轻松地使用该界面来编写远程调试器应用程序。&lt;/li>
&lt;/ul>
&lt;p>简单来说， jdwp agent 会建立运行应用的 JVM 和调试者（本地或者远程）之间的桥梁。既然他是一个Agent Library, 它就有能力拦截运行的代码。&lt;/p>
&lt;p>在 JVM 架构里， debugging 功能在 JVM 本身的内部是找不到的，它是一种抽象到外部工具的方式（也称作调试者 debugger）。这些调试工具或者运行在 JVM 的本地 或者在远程。这是一种解耦，模块化的架构。&lt;/p>
&lt;p>概述此模块化体系结构的所有规范都包含在Java平台中，调试器体系结构，JPDA，您可以在此处阅读其详细介绍： &lt;a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jpda/architecture.html">Java Platform Debugger Architecture Overview.&lt;/a>&lt;/p>
&lt;h2 id="4-总结">4. 总结&lt;/h2>
&lt;p>在本文中，我们简单介绍了如何配置Java服务器以进行远程调试，以及如何使用简单的控制台工具来调试应用程序。但是需要注意的是，调试模式会降低服务器的速度，因为它会禁用一些JVM优化。另外，调试模式可能会带来潜在的安全风险。您需要通过特定端口向调试器提供对服务器的访问权限，这对于用心不良的人来说是另一个潜在的安全漏洞。所以并不建议长期开着调试模式跑应用。&lt;/p>
&lt;h2 id="参考文档">参考文档&lt;/h2>
&lt;p>[1] &lt;a href="https://www.jianshu.com/p/d168ecdce022">Java远程调试（Remote Debugging）的那些事&lt;/a>&lt;/p>
&lt;p>[2] &lt;a href="https://blog.trifork.com/2014/07/14/how-to-remotely-debug-application-running-on-tomcat-from-within-intellij-idea/">How to Remotely Debug Application Running on Tomcat From Within Intellij IDEA&lt;/a>&lt;/p>
&lt;p>[3] &lt;a href="https://stackify.com/java-remote-debugging/">A Practical Guide to Java Remote Debugging&lt;/a>&lt;/p>
&lt;p>[4] &lt;a href="https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/index.html">使用 Eclipse 远程调试 Java 应用程序&lt;/a>&lt;/p>
&lt;p>[5] &lt;a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jpda/architecture.html">JPDA&lt;/a>&lt;/p>
&lt;p>[6] &lt;a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/index.html">深入 Java 调试体系&lt;/a>&lt;/p>
&lt;p>[7] &lt;a href="http://dev-aux.com/java/java-local-and-remote-jvm-debugging-jdk-8-and-later">Java: local and remote JVM debugging — JDK 8, 9 and later&lt;/a>&lt;/p></description></item></channel></rss>