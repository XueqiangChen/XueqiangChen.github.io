<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>线程池 on AhaMoment</title><link>https://ahamoment.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><description>Recent content in 线程池 on AhaMoment</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2021</copyright><lastBuildDate>Thu, 12 Nov 2020 10:22:13 +0800</lastBuildDate><atom:link href="https://ahamoment.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 多线程 - 自定义线程池</title><link>https://ahamoment.cn/posts/java/java-multithread-thread-pool/</link><pubDate>Thu, 12 Nov 2020 10:22:13 +0800</pubDate><guid>https://ahamoment.cn/posts/java/java-multithread-thread-pool/</guid><description>1. 为什么要用线程池？ 池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。
线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。
这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：
降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 2. 自定义一个简单的线程池 一个线程池应该具备以下要素：
任务队列：用于缓存提交的任务。 任务线程管理功能：一个线程池必须能够很好地管理和控制线程数量，可通过如下三个参数来实现，比如创建线程池时初始的线程数量init；线程池自动扩充时最大的线程数量max；在线程池空闲时需要释放线程但是也要维护一定数量的活跃数量或者核心数量core。有了这三个参数，就能够很好地控制线程池中的线程数量，将其维护在一个合理的范围之内，三者之间的关系是init＜=core＜=max。 任务拒绝策略：如果线程数量已达到上限且任务队列已满，则需要有相应的拒绝策略来通知任务提交者。 线程工厂：主要用于个性化定制线程，比如将线程设置为守护线程以及设置线程名称等。 QueueSize：任务队列主要存放提交的Runnable，但是为了防止内存溢出，需要有limit数量对其进行控制。 Keepedalive时间：该时间主要决定线程各个重要参数自动维护的时间间隔。 2.1 线程池实现类图 上图为线程池实现类图，下面看具体的代码。
2.2 ThreadPool 先定义一个线程池接口，定义常用的方法。
public interface ThreadPool { //提交任务到线程池 void execute(Runnable runnable); // 关闭线程池 void shutdown(); // 获取线程池的初始化大小 int getInitSize(); // 获取线程池的最大线程数 int getMaxSize(); // 获取线程池的核心线程数 int getCoreSize(); // 获取线程池中用于缓存任务队列的大小 int getQueueSize(); // 获取线程池中活跃线程的数量 int getActiveCount(); // 查看线程池是否已经被shutdown boolean isShutdown(); } 2.</description></item></channel></rss>