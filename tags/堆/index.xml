<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>堆 on Ahamoment</title><link>https://ahamoment.cn/tags/%E5%A0%86/</link><description>Recent content in 堆 on Ahamoment</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Tue, 15 Sep 2020 11:44:06 +0800</lastBuildDate><atom:link href="https://ahamoment.cn/tags/%E5%A0%86/index.xml" rel="self" type="application/rss+xml"/><item><title>堆</title><link>https://ahamoment.cn/post/algorithm-heap/</link><pubDate>Tue, 15 Sep 2020 11:44:06 +0800</pubDate><guid>https://ahamoment.cn/post/algorithm-heap/</guid><description>
&lt;h2 id="什么是堆">什么是堆&lt;/h2>
&lt;p>了解什么是堆之前，我们知道队列的概念，队列的特点是先进先出，但是有一种特殊的队列，取出元素的顺序是按照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序，这就是优先队列(Priority Queue)。&lt;/p>
&lt;p>若采用数组或者链表实现优先队列，总会有插入、删除或者查找中的一项操作的复杂度是$O(N)$ 的。&lt;/p>
&lt;p>若采用二叉搜索树实现，那么插入和删除都跟树的高度有关，也就是$O(log_2N)$ 的复杂度，但是删除的时候，由于每次都要删除最大的或者最小的，这样操作几次后，会造成搜索树失去平衡，所以不能简单的使用二叉搜索树。&lt;/p>
&lt;p>如果采用二叉树结构，我们更关注的应该是删除的操作，那么我们把最大的值放到根结点，左右两边也是最大值作为左右子树的根结点，每次删除只需要删除根结点。同时，为了保证树的平衡性，可以考虑使用完全二叉树来实现优先队列。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917105413123.png" alt="image-20200917105413123">&lt;/p>
&lt;p>优先队列使用完全二叉树表示如上图所示，数组的第 0 个元素空着，后面的按照层序遍历的顺序存放到数组中。使用完全二叉实现的优先队列，也可以称之为堆，堆的特性如下：&lt;/p>
&lt;ul>
&lt;li>结构性：用数组表示的完全二叉树。&lt;/li>
&lt;li>有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）
&lt;ul>
&lt;li>&amp;quot;最大堆&amp;quot;，也称 &amp;quot;大顶堆&amp;quot;：堆顶元素是整个树的最大值&lt;/li>
&lt;li>&amp;quot;最小堆&amp;quot;，也称&amp;quot;小顶堆&amp;quot;：堆顶元素是整个树的最小值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如下图所示的几个二叉树，不是堆。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917111328827.png" alt="image-20200917111328827">&lt;/p>
&lt;p>第一和第二棵二叉树虽然满足有序性，但是不是完全二叉树。第三和第四棵二叉树是完全二叉树，但是不满足有序性的特点。&lt;/p>
&lt;blockquote>
&lt;p>注意：堆从根结点到任意结点路径上的结点顺序都是有序的！&lt;/p>
&lt;/blockquote>
&lt;h2 id="最大堆的创建">最大堆的创建&lt;/h2>
&lt;p>堆的数据结构包括存储完全二叉树的数组 data，堆中当前元素个数 size，堆的最大容量 capacity。&lt;/p>
&lt;p>数组的元素从1开始，0的位置定义为哨兵，方便以后更快操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Heap&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="c1">// 堆的类型定义
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">protected&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//存储元素的数组
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">protected&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//堆中当前元素个数
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">protected&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//堆的最大容量
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Heap&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Heap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MAX_VALUE&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">18&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Heap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">maxSize&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">//最大元素从1开始
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MAX_VALUE&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 定义哨兵，为大于最大堆中所有可能元素的值
&lt;/span>&lt;span class="ln">24&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">25&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isFull&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">capacity&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">29&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">33&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">35&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最大堆的插入">最大堆的插入&lt;/h2>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917112957455.png" alt="image-20200917112957455">&lt;/p>
&lt;p>插入元素时，插入到数组的最后一个位置，这里插入的结点值为20，检查插入后仍然符合堆的两个特性，插入完成。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917113136023.png" alt="image-20200917113136023">&lt;/p>
&lt;p>当插入的值为35的时候，当前堆的有序性被破坏了，将35和31的位置调换后就可以了。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917113303675.png" alt="image-20200917113303675">&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917113324619.png" alt="image-20200917113324619">&lt;/p>
&lt;p>当插入的值为58的时候，58 &amp;gt; 31，跟31对调位置，58 &amp;gt; 44 继续跟根结点调换位置。调整后保证了有序性，同时，从58 -&amp;gt; 44 -&amp;gt; 31这条线也是按照从大到小的顺序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="c1">// 将元素X插入最大堆H，其中H-&amp;gt;Data[0]已经定义为哨兵
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 4&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;最大堆已满&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// i指向插入后堆中的最后一个元素的位置
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">/=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">];&lt;/span> &lt;span class="c1">// 向下过滤结点，对调父结点的位置
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 将X插入
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于我们将数组的第 0 个元素设置为哨兵，哨兵的值为一个非常大的整数值。如果没有哨兵结点，我们在循环中还需要判断 i &amp;gt; 1 这个条件，有了哨兵之后，循环在 i = 0 的时候就会停下来，可以少写一个条件，提高程序效率。&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917114313272.png" alt="image-20200917114313272">&lt;/p>
&lt;h2 id="最大堆的删除">最大堆的删除&lt;/h2>
&lt;p>最大堆的删除过程就是取出根结点（最大值）元素，同时删除堆的一个结点。&lt;/p>
&lt;p>删除下图的这个堆的最大值：&lt;/p>
&lt;p>&lt;img src="https://chenxqblog-1258795182.cos.ap-guangzhou.myqcloud.com/image-20200917133516355.png" alt="image-20200917133516355">&lt;/p>
&lt;ol>
&lt;li>把 31 移至根&lt;/li>
&lt;li>找出 31 的较大的孩子&lt;/li>
&lt;/ol>
&lt;p>时间复杂度为： $T(N)=O(logN)$&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">deleteMax&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="c1">// 从最大堆中取出键值为最大的元素，并删除一个结点
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxItem&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//maxItem-堆顶元素，temp-临时变量
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;最大堆已经为空&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">maxItem&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">//取出根结点最大值
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 用最大堆中的最后一个元素从根结点开始向上过滤下层结点
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">--];&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 左儿子的位置
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">++;&lt;/span> &lt;span class="c1">//child 指向左右结点的较大者
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//找到位置了
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//将子结点与父节点对换
&lt;/span>&lt;span class="ln">21&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">maxItem&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">26&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最大堆的建立">最大堆的建立&lt;/h2>
&lt;p>建立最大堆是将已经存在的N个元素按最大堆的要求存放在一个一维数组中。&lt;/p>
&lt;p>建堆的过程可以从树的从最后一个结点的父节点开始，到根结点1，将最后一个结点的父节点所在的小堆调整为最大堆，然后向左寻找有儿子的结点，每次调整一个最大堆，直到根结点。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">buildHeap&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="c1">//* 调整Data[]中的元素，使满足最大堆的有序性 *//*
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//* 这里假设所有Size个元素已经存在Data[]中 *//*
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="c1">//* 从最后一个结点的父节点开始，到根结点1 *//*
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">preDown&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">12&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">preDown&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="c1">//* 下滤：将H中以Data[p]为根的子堆调整为最大堆 *//*
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">17&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">];&lt;/span> &lt;span class="c1">//* 取出根结点存放的值 *//*
&lt;/span>&lt;span class="ln">19&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="c1">//这个过程与删除的过程一样
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">]))&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">++;&lt;/span> &lt;span class="c1">//* Child指向左右子结点的较大者 *//*
&lt;/span>&lt;span class="ln">23&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//* 找到了合适位置 *//*
&lt;/span>&lt;span class="ln">24&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="c1">//* 下滤X *//*
&lt;/span>&lt;span class="ln">25&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">28&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">29&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最小堆">最小堆&lt;/h2>
&lt;p>最小堆的建立和操作与最大堆大致上是一样的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">MinHeap&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Heap&lt;/span>&lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">MinHeap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sentinalVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="kd">super&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">sentinalVal&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">MinHeap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sentinalVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//哨兵值
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">super&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">sentinalVal&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">insert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="c1">// 将元素X插入最小堆H，其中H-&amp;gt;Data[0]已经定义为哨兵
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">14&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;最大堆已满&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// i指向插入后堆中的最后一个元素的位置
&lt;/span>&lt;span class="ln">20&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">/=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">];&lt;/span> &lt;span class="c1">// 向下过滤结点，对调父结点的位置
&lt;/span>&lt;span class="ln">22&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 将X插入
&lt;/span>&lt;span class="ln">24&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">26&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">deleteMin&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="c1">// 从最小堆中取出键值为最小的元素，并删除一个结点
&lt;/span>&lt;span class="ln">29&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">minItem&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//minItem-堆顶元素，temp-临时变量
&lt;/span>&lt;span class="ln">31&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;最大堆已经为空&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">35&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="n">minItem&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">//取出根结点最小值
&lt;/span>&lt;span class="ln">37&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 用最小堆中的最后一个元素从根结点开始向上过滤下层结点
&lt;/span>&lt;span class="ln">38&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">--];&lt;/span>
&lt;span class="ln">39&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">40&lt;/span> &lt;span class="n">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 左儿子的位置
&lt;/span>&lt;span class="ln">41&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">42&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">++;&lt;/span> &lt;span class="c1">//child 指向左右结点的较小者
&lt;/span>&lt;span class="ln">43&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">44&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//找到位置了
&lt;/span>&lt;span class="ln">45&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">46&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//将子结点与父节点对换
&lt;/span>&lt;span class="ln">47&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">48&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">49&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">50&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">51&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">minItem&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">52&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">53&lt;/span>
&lt;span class="ln">54&lt;/span> &lt;span class="c1">//*----------- 建造最小堆 -----------*//*
&lt;/span>&lt;span class="ln">55&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">preDown&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">56&lt;/span> &lt;span class="c1">//* 下滤：将H中以Data[p]为根的子堆调整为最小堆 *//*
&lt;/span>&lt;span class="ln">57&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">58&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">59&lt;/span>
&lt;span class="ln">60&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">];&lt;/span> &lt;span class="c1">//* 取出根结点存放的值 *//*
&lt;/span>&lt;span class="ln">61&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="c1">//这个过程与删除的过程一样
&lt;/span>&lt;span class="ln">62&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">63&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">]))&lt;/span>
&lt;span class="ln">64&lt;/span> &lt;span class="n">child&lt;/span>&lt;span class="o">++;&lt;/span> &lt;span class="c1">//* Child指向左右子结点的较小者 *//*
&lt;/span>&lt;span class="ln">65&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//* 找到了合适位置 *//*
&lt;/span>&lt;span class="ln">66&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="c1">//* 下滤X *//*
&lt;/span>&lt;span class="ln">67&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="ln">68&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">69&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">70&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">71&lt;/span>
&lt;span class="ln">72&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">buildHeap&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">73&lt;/span> &lt;span class="c1">//* 调整Data[]中的元素，使满足最大堆的有序性 *//*
&lt;/span>&lt;span class="ln">74&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//* 这里假设所有Size个元素已经存在Data[]中 *//*
&lt;/span>&lt;span class="ln">75&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="ln">76&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">77&lt;/span>
&lt;span class="ln">78&lt;/span> &lt;span class="c1">//* 从最后一个结点的父节点开始，到根结点1 *//*
&lt;/span>&lt;span class="ln">79&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">80&lt;/span> &lt;span class="n">preDown&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">81&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">82&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">83&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>从堆的几种操作可以发现，删除和建堆的过程，就是从上往下调整堆的有序性的过程，插入元素的过程是从下往上调整堆的有序性的过程。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>【1】&lt;a href="https://www.icourse163.org/learn/ZJU-93001?tid=1207006212#/learn/content?type=detail&amp;amp;id=1212031639&amp;amp;cid=1215166239">数据结构-浙江大学&lt;/a>&lt;/p></description></item></channel></rss>