<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on Ahamoment</title><link>https://ahamoment.cn/tags/java/</link><description>Recent content in java on Ahamoment</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Wed, 16 Dec 2020 09:44:34 +0800</lastBuildDate><atom:link href="https://ahamoment.cn/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 基础面试题</title><link>https://ahamoment.cn/post/interview-java/</link><pubDate>Wed, 16 Dec 2020 09:44:34 +0800</pubDate><guid>https://ahamoment.cn/post/interview-java/</guid><description>
&lt;blockquote>
&lt;p>本文收集Java基础知识点相关的面试题目&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-java-基础">1. Java 基础&lt;/h2>
&lt;h3 id="11-语法">1.1. 语法&lt;/h3>
&lt;h4 id="111-java-泛型了解么什么是类型擦除介绍一下常用的通配符">1.1.1 Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？&lt;/h4>
&lt;p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。&lt;/p>
&lt;p>&lt;strong>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。&lt;/strong> 更多关于类型擦除的问题，可以查看这篇文章：&lt;a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">《Java 泛型类型擦除以及类型擦除带来的问题》&lt;/a> 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">list&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">12&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">//这里直接添加会报错
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;a&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">clazz&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="n">Method&lt;/span> &lt;span class="n">add&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">clazz&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getDeclaredMethod&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;add&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">//但是通过反射添加，是可以的
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">invoke&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;kl&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。&lt;/p>
&lt;p>&lt;strong>1.泛型类&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="c1">//在实例化泛型类时，必须指定T的具体类型
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Generic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;{&lt;/span>
&lt;span class="ln"> 4&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Generic&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">10&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="nf">getKey&lt;/span>&lt;span class="o">(){&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如何实例化泛型类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="n">Generic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">genericInteger&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Generic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;(&lt;/span>&lt;span class="n">123456&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>2.泛型接口&lt;/strong> ：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">Generator&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="nf">method&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>实现泛型接口，不指定类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">GeneratorImpl&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Generator&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="nf">method&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>实现泛型接口，指定类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">GeneratorImpl&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Generator&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">method&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>3.泛型方法&lt;/strong> ：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">E&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">printArray&lt;/span>&lt;span class="o">(&lt;/span> &lt;span class="n">E&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">inputArray&lt;/span> &lt;span class="o">)&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span> &lt;span class="n">E&lt;/span> &lt;span class="n">element&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">inputArray&lt;/span> &lt;span class="o">){&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span> &lt;span class="s">&amp;#34;%s &amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">element&lt;/span> &lt;span class="o">);&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">6&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="ln">7&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="c1">// 创建不同类型数组： Integer, Double 和 Character
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">intArray&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">3&lt;/span> &lt;span class="o">};&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">stringArray&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="s">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;World&amp;#34;&lt;/span> &lt;span class="o">};&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="n">printArray&lt;/span>&lt;span class="o">(&lt;/span> &lt;span class="n">intArray&lt;/span> &lt;span class="o">);&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="n">printArray&lt;/span>&lt;span class="o">(&lt;/span> &lt;span class="n">stringArray&lt;/span> &lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>常用的通配符为： T，E，K，V，？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>？ 表示不确定的 java 类型&lt;/li>
&lt;li>T (type) 表示具体的一个 java 类型&lt;/li>
&lt;li>K V (key value) 分别代表 java 键值中的 Key Value&lt;/li>
&lt;li>E (element) 代表 Element&lt;/li>
&lt;/ul>
&lt;p>更多关于 Java 泛型中的通配符可以查看这篇文章：&lt;a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9">《聊一聊-JAVA 泛型中的通配符 T，E，K，V，？》&lt;/a>&lt;/p>
&lt;h4 id="112--和-equals-的区别">1.1.2. == 和 equals 的区别&lt;/h4>
&lt;p>&lt;strong>&lt;code>==&lt;/code>&lt;/strong> : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(&lt;strong>基本数据类型&lt;code>==&lt;/code>比较的是值，引用数据类型&lt;code>==&lt;/code>比较的是内存地址&lt;/strong>)&lt;/p>
&lt;blockquote>
&lt;p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>&lt;code>equals()&lt;/code>&lt;/strong> : 它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。&lt;code>equals()&lt;/code>方法存在于&lt;code>Object&lt;/code>类中，而&lt;code>Object&lt;/code>类是所有类的直接或间接父类。&lt;/p>
&lt;p>&lt;code>Object&lt;/code>类&lt;code>equals()&lt;/code>方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">equals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Object&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>equals()&lt;/code> 方法存在两种使用情况：&lt;/p>
&lt;ul>
&lt;li>情况 1：类没有覆盖 &lt;code>equals()&lt;/code>方法。则通过&lt;code>equals()&lt;/code>比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 &lt;code>Object&lt;/code>类&lt;code>equals()&lt;/code>方法。&lt;/li>
&lt;li>情况 2：类覆盖了 &lt;code>equals()&lt;/code>方法，是对对象内容的比较。一般，我们都覆盖 &lt;code>equals()&lt;/code>方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>举个例子：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">test1&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;ab&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// a 为一个引用
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;ab&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// b为另一个引用,对象的内容一样
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">aa&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;ab&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 放在常量池中
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">bb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;ab&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 从常量池中查找
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">aa&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">bb&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1">// true
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;aa==bb&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1">// false，非同一对象
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;a==b&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="c1">// true
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;aEQb&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">42&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">42&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="c1">// true
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">17&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>说明：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>String&lt;/code> 中的 &lt;code>equals&lt;/code> 方法是被重写过的，因为 &lt;code>Object&lt;/code> 的 &lt;code>equals&lt;/code> 方法是比较的对象的内存地址，而 &lt;code>String&lt;/code> 的 &lt;code>equals&lt;/code> 方法比较的是对象的值。&lt;/li>
&lt;li>当创建 &lt;code>String&lt;/code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 &lt;code>String&lt;/code> 对象。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>String&lt;/code>类&lt;code>equals()&lt;/code>方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln"> 1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">equals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Object&lt;/span> &lt;span class="n">anObject&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">anObject&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">anObject&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">anotherString&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="n">anObject&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">anotherString&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">v2&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">anotherString&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">v1&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">v2&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">])&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="113-hashcode-与-equals">1.1.3. hashCode() 与 equals()&lt;/h4>
&lt;p>面试官可能会问你：“你重写过 &lt;code>hashcode&lt;/code> 和 &lt;code>equals&lt;/code>么，为什么重写 &lt;code>equals&lt;/code> 时必须重写 &lt;code>hashCode&lt;/code> 方法？”&lt;/p>
&lt;p>&lt;strong>1)hashCode()介绍:&lt;/strong>&lt;/p>
&lt;p>&lt;code>hashCode()&lt;/code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。&lt;code>hashCode()&lt;/code>定义在 JDK 的 &lt;code>Object&lt;/code> 类中，这就意味着 Java 中的任何类都包含有 &lt;code>hashCode()&lt;/code> 函数。另外需要注意的是： &lt;code>Object&lt;/code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="ln">1&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">native&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">hashCode&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）&lt;/p>
&lt;p>&lt;strong>2)为什么要有 hashCode？&lt;/strong>&lt;/p>
&lt;p>我们以&lt;code>HashSet&lt;/code> 如何检查重复”为例子来说明为什么要有 hashCode？&lt;/p>
&lt;p>当你把对象加入 &lt;code>HashSet&lt;/code> 时，&lt;code>HashSet&lt;/code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，&lt;code>HashSet&lt;/code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 &lt;code>equals()&lt;/code> 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，&lt;code>HashSet&lt;/code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。&lt;/p>
&lt;p>&lt;strong>3) 为什么重写 &lt;code>equals&lt;/code> 时必须重写 &lt;code>hashCode&lt;/code> 方法？&lt;/strong>&lt;/p>
&lt;p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。&lt;strong>因此，equals 方法被覆盖过，则 &lt;code>hashCode&lt;/code> 方法也必须被覆盖。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>hashCode()&lt;/code>的默认行为是对堆上的对象产生独特值。如果没有重写 &lt;code>hashCode()&lt;/code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？&lt;/strong>&lt;/p>
&lt;p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。&lt;/p>
&lt;p>因为 &lt;code>hashCode()&lt;/code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 &lt;code>hashCode&lt;/code>。&lt;/p>
&lt;p>我们刚刚也提到了 &lt;code>HashSet&lt;/code>,如果 &lt;code>HashSet&lt;/code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 &lt;code>equals()&lt;/code> 来判断是否真的相同。也就是说 &lt;code>hashcode&lt;/code> 只是用来缩小查找成本。&lt;/p>
&lt;p>更多关于 &lt;code>hashcode()&lt;/code> 和 &lt;code>equals()&lt;/code> 的内容可以查看：&lt;a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答&lt;/a>&lt;/p>
&lt;h3 id="12-数据类型">1.2. 数据类型&lt;/h3>
&lt;h4 id="121-string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的">1.2.1 String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?&lt;/h4>
&lt;p>简单的来说：&lt;code>String&lt;/code> 类中使用 final 关键字修饰字符数组来保存字符串，&lt;code>private final char value[]&lt;/code>，所以&lt;code>String&lt;/code> 对象是不可变的。&lt;/p>
&lt;blockquote>
&lt;p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 &lt;code>private final byte[] value&lt;/code>;&lt;/p>
&lt;/blockquote>
&lt;p>而 &lt;code>StringBuilder&lt;/code> 与 &lt;code>StringBuffer&lt;/code> 都继承自 &lt;code>AbstractStringBuilder&lt;/code> 类，在 &lt;code>AbstractStringBuilder&lt;/code> 中也是使用字符数组保存字符串&lt;code>char[] value&lt;/code> 但是没有用 &lt;code>final&lt;/code> 关键字修饰，所以这两种对象都是可变的。&lt;/p>
&lt;p>&lt;strong>线程安全性&lt;/strong>&lt;/p>
&lt;p>&lt;code>String&lt;/code> 中的对象是不可变的，也就可以理解为常量，线程安全。&lt;/p>
&lt;p>&lt;code>StringBuffer&lt;/code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。&lt;/p>
&lt;p>&lt;code>StringBuilder&lt;/code> 并没有对方法进行加同步锁，所以是非线程安全的。&lt;/p>
&lt;p>&lt;strong>性能&lt;/strong>&lt;/p>
&lt;p>每次对 &lt;code>String&lt;/code> 类型进行改变的时候，都会生成一个新的 &lt;code>String&lt;/code> 对象，然后将指针指向新的 &lt;code>String&lt;/code> 对象。&lt;code>StringBuffer&lt;/code> 每次都会对 &lt;code>StringBuffer&lt;/code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 &lt;code>StringBuilder&lt;/code> 相比使用 &lt;code>StringBuffer&lt;/code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。&lt;/p>
&lt;p>&lt;strong>对于三者使用的总结：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>操作少量的数据: 适用 &lt;code>String&lt;/code>&lt;/li>
&lt;li>单线程操作字符串缓冲区下操作大量数据: 适用 &lt;code>StringBuilder&lt;/code>&lt;/li>
&lt;li>多线程操作字符串缓冲区下操作大量数据: 适用 &lt;code>StringBuffer&lt;/code>&lt;/li>
&lt;/ol>
&lt;h3 id="13-方法">1.3. 方法&lt;/h3>
&lt;h4 id="131-重载和重写的区别">1.3.1 重载和重写的区别&lt;/h4>
&lt;p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理。&lt;/p>
&lt;p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>区别点&lt;/th>
&lt;th>重载方法&lt;/th>
&lt;th>重写方法&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>发生范围&lt;/td>
&lt;td>同一个类&lt;/td>
&lt;td>子类&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>参数列表&lt;/td>
&lt;td>必须修改&lt;/td>
&lt;td>一定不能修改&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>返回类型&lt;/td>
&lt;td>可修改&lt;/td>
&lt;td>子类方法返回值类型应比父类方法返回值类型更小或相等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>异常&lt;/td>
&lt;td>可修改&lt;/td>
&lt;td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>访问修饰符&lt;/td>
&lt;td>可修改&lt;/td>
&lt;td>一定不能做更严格的限制（可以降低限制）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>发生阶段&lt;/td>
&lt;td>编译期&lt;/td>
&lt;td>运行期&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="14-面向对象">1.4 面向对象&lt;/h3>
&lt;h4 id="141-在-java-中定义一个不做事且没有参数的构造方法的作用">1.4.1. 在 Java 中定义一个不做事且没有参数的构造方法的作用&lt;/h4>
&lt;p>Java 程序在执行子类的构造方法之前，如果没有用 &lt;code>super()&lt;/code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 &lt;code>super()&lt;/code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。&lt;/p>
&lt;h4 id="142-面对对象的三大特性">1.4.2. 面对对象的三大特性&lt;/h4>
&lt;p>封装、继承和多态。&lt;/p>
&lt;p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。&lt;/p>
&lt;p>继承：不同类型的对象，相互之间经常有一定数量的共同点。&lt;/p>
&lt;p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。&lt;/p>
&lt;h3 id="14-反射机制">1.4. 反射机制&lt;/h3>
&lt;p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。&lt;/p>
&lt;p>&lt;strong>反射机制优缺点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>优点：&lt;/strong> 运行期类型的判断，动态加载类，提高代码灵活度。&lt;/li>
&lt;li>&lt;strong>缺点：&lt;/strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>反射的应用场景&lt;/strong>&lt;/p>
&lt;p>&lt;strong>反射是框架设计的灵魂。&lt;/strong>&lt;/p>
&lt;p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。&lt;/p>
&lt;p>举例：&lt;/p>
&lt;ol>
&lt;li>我们在使用 JDBC 连接数据库时使用 &lt;code>Class.forName()&lt;/code>通过反射加载数据库的驱动程序；&lt;/li>
&lt;li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；&lt;/li>
&lt;li>动态配置实例的属性；&lt;/li>
&lt;/ol>
&lt;h3 id="15-文件与io流">1.5. 文件与IO流&lt;/h3>
&lt;h4 id="151-bionioaio-有什么区别">1.5.1. BIO,NIO,AIO 有什么区别?&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>BIO (Blocking I/O):&lt;/strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。&lt;/li>
&lt;li>&lt;strong>NIO (Non-blocking/New I/O):&lt;/strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 &lt;code>Socket&lt;/code> 和 &lt;code>ServerSocket&lt;/code> 相对应的 &lt;code>SocketChannel&lt;/code> 和 &lt;code>ServerSocketChannel&lt;/code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发&lt;/li>
&lt;li>&lt;strong>AIO (Asynchronous I/O):&lt;/strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。&lt;/li>
&lt;/ul>
&lt;h2 id="2-容器">2. 容器&lt;/h2>
&lt;h2 id="3-参考">3. 参考&lt;/h2>
&lt;p>[1] &lt;a href="https://github.com/Snailclimb/JavaGuide">JavaGuide&lt;/a>&lt;/p></description></item><item><title>解决setcap导致Java加载libjli.so 失败问题</title><link>https://ahamoment.cn/post/linux-cap/</link><pubDate>Fri, 11 Sep 2020 11:12:43 +0800</pubDate><guid>https://ahamoment.cn/post/linux-cap/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>最近碰到一个问题，有个应用在启动的时候一直报错，错误信息如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>java: error &lt;span class="k">while&lt;/span> loading shared libraries: libjli.so: cannot open shared object file: No such file or directory
&lt;/code>&lt;/pre>&lt;/div>&lt;p>错误信息是说 java 应用加载不到 libjli.so 文件，我们使用 &lt;code>java -version&lt;/code> 命令，同样的错误又出现了。使用 ldd 命令查看一下 java 应用是否加载了这个 so 文件，发现 java 应用加载的 so 文件中存在 libjli.so。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ ldd java
&lt;span class="ln">2&lt;/span> linux-vdso.so.1 &lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="o">(&lt;/span>0x00007ffe2a9c7000&lt;span class="o">)&lt;/span>
&lt;span class="ln">3&lt;/span> /usr/local/lib/libsysconfcpus.so &lt;span class="o">(&lt;/span>0x00002ac503ca8000&lt;span class="o">)&lt;/span>
&lt;span class="ln">4&lt;/span> libz.so.1 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libz.so.1 &lt;span class="o">(&lt;/span>0x00002ac503eaa000&lt;span class="o">)&lt;/span>
&lt;span class="ln">5&lt;/span> libjli.so &lt;span class="o">=&lt;/span>&amp;gt; /apps/svr/jdk-14.0.1/bin/./../lib/libjli.so &lt;span class="o">(&lt;/span>0x00002ac5040c0000&lt;span class="o">)&lt;/span>
&lt;span class="ln">6&lt;/span> libpthread.so.0 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libpthread.so.0 &lt;span class="o">(&lt;/span>0x00002ac5042d1000&lt;span class="o">)&lt;/span>
&lt;span class="ln">7&lt;/span> libdl.so.2 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libdl.so.2 &lt;span class="o">(&lt;/span>0x00002ac5044ee000&lt;span class="o">)&lt;/span>
&lt;span class="ln">8&lt;/span> libc.so.6 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libc.so.6 &lt;span class="o">(&lt;/span>0x00002ac5046f2000&lt;span class="o">)&lt;/span>
&lt;span class="ln">9&lt;/span> /lib64/ld-linux-x86-64.so.2 &lt;span class="o">(&lt;/span>0x00002ac503883000&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们接着查看了 &lt;code>LD_LIBRARY_PATH&lt;/code> 和 &lt;code>/etc/ld.so.conf.d/xxx.conf&lt;/code> 文件的配置，发现都是正常的。通过对比其他应用的启动配置，发现该应用使用了 80 端口启动，但是我们的容器只能使用 apps 权限登录，所以在启动前使用 &lt;code>setcap&lt;/code> 命令提升了 java 应用的权限，允许其使用 80 端口，会不会是这个操作导致的呢？在查看原因之前，我们需要先理解几个概念。&lt;/p>
&lt;h2 id="linux-动态库">Linux 动态库&lt;/h2>
&lt;p>动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，不同的应用程序如果调用相同的库,那么在内存中只需要有一份该动态库(共享库)的实例。这类库的名字一般是libxxx.so，其中so是 Shared Object 的缩写，即可以共享的目标文件。在链接动态库生成可执行文件时，并不会把动态库的代码复制到执行文件中，而是在执行文件中记录对动态库的引用。&lt;/p>
&lt;p>Linux下生成和使用动态库的步骤如下：&lt;/p>
&lt;ol>
&lt;li>编写源文件。&lt;/li>
&lt;li>将一个或几个源文件编译链接，生成共享库。&lt;/li>
&lt;li>通过 &lt;code>-L -lxxx&lt;/code> 的gcc选项链接生成的libxxx.so。例如&lt;code>gcc -fPIC -shared -o libmax.so max.c&lt;/code> , &lt;code>-fPIC&lt;/code> 是编译选项，PIC是 Position Independent Code 的缩写，表示要生成位置无关的代码，这是动态库需要的特性； &lt;code>-shared&lt;/code> 是链接选项，告诉gcc生成动态库而不是可执行文件&lt;/li>
&lt;li>把libxxx.so放入链接库的标准路径，或指定 &lt;code>LD_LIBRARY_PATH&lt;/code>，才能运行链接了libxxx.so的程序。&lt;/li>
&lt;/ol>
&lt;p>Linux是通过 &lt;code>/etc/ld.so.cache&lt;/code> 文件搜寻要链接的动态库的。而 &lt;code>/etc/ld.so.cache&lt;/code> 是 ldconfig 程序读取 &lt;code>/etc/ld.so.conf&lt;/code> 文件生成的。
（注意， &lt;code>/etc/ld.so.conf&lt;/code> 中并不必包含 &lt;code>/lib&lt;/code> 和 &lt;code>/usr/lib&lt;/code>，&lt;code>ldconfig&lt;/code>程序会自动搜索这两个目录）&lt;/p>
&lt;p>我们把要用的 libxx.so 文件所在的路径添加到 &lt;code>/etc/ld.so.conf&lt;/code> 中，再以root权限运行 &lt;code>ldconfig&lt;/code> 程序，更新 &lt;code>/etc/ld.so.cache&lt;/code> ，程序运行时，就可以找到 &lt;code>libxx.so&lt;/code>。另外就是通过配置 &lt;code>LD_LIBRARY_PATH&lt;/code> 的方式来指定通过某些路径寻找链接的动态库。&lt;/p>
&lt;h3 id="ldd-查看程序依赖">ldd 查看程序依赖&lt;/h3>
&lt;p>理解了动态库的概念之后，当碰到某个程序报错缺少某个库文件时，我们应该怎么查看该程序当前加载了哪些库文件呢？可以用 &lt;code>ldd&lt;/code> 命令。&lt;/p>
&lt;p>ldd 命令的作用是用来查看程式运行所需的共享库,常用来解决程式因缺少某个库文件而不能运行的一些问题。&lt;/p>
&lt;p>例如：查看test程序运行所依赖的库:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost testso&lt;span class="o">]&lt;/span>&lt;span class="c1"># ldd /etc/alternatives/java&lt;/span>
&lt;span class="ln">2&lt;/span> linux-vdso.so.1 &lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="o">(&lt;/span>0x00007ffde15f8000&lt;span class="o">)&lt;/span>
&lt;span class="ln">3&lt;/span> libpthread.so.0 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libpthread.so.0 &lt;span class="o">(&lt;/span>0x00007f03f2f8d000&lt;span class="o">)&lt;/span>
&lt;span class="ln">4&lt;/span> libdl.so.2 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libdl.so.2 &lt;span class="o">(&lt;/span>0x00007f03f2d89000&lt;span class="o">)&lt;/span>
&lt;span class="ln">5&lt;/span> libc.so.6 &lt;span class="o">=&lt;/span>&amp;gt; /lib64/libc.so.6 &lt;span class="o">(&lt;/span>0x00007f03f29bb000&lt;span class="o">)&lt;/span>
&lt;span class="ln">6&lt;/span> /lib64/ld-linux-x86-64.so.2 &lt;span class="o">(&lt;/span>0x00007f03f33ab000&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>第一列：程序需要依赖什么库&lt;/li>
&lt;li>第二列: 系统提供的与程序需要的库所对应的库&lt;/li>
&lt;li>第三列：库加载的开始地址&lt;/li>
&lt;/ul>
&lt;p>通过上面的信息，我们可以得到以下几个信息：&lt;/p>
&lt;ol>
&lt;li>通过对比第一列和第二列，我们可以分析程序需要依赖的库和系统实际提供的，是否相匹配&lt;/li>
&lt;li>通过观察第三列，我们可以知道在当前的库中的符号在对应的进程的地址空间中的开始位置&lt;/li>
&lt;/ol>
&lt;p>如果依赖的某个库找不到，通过这个命令可以迅速定位问题所在.&lt;/p>
&lt;h2 id="linux-capability">Linux capability&lt;/h2>
&lt;p>从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 capabilites。Capabilites 作为线程(Linux 并不真正区分进程和线程)的属性存在，每个单元可以独立启用和禁用。如此一来，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作。&lt;/p>
&lt;p>下面是从 &lt;a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities man page&lt;/a> 中摘取的 capabilites 列表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>capability 名称&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CAP_AUDIT_CONTROL&lt;/td>
&lt;td>启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_AUDIT_READ&lt;/td>
&lt;td>允许通过 multicast netlink 套接字读取审计日志&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_AUDIT_WRITE&lt;/td>
&lt;td>将记录写入内核审计日志&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_BLOCK_SUSPEND&lt;/td>
&lt;td>使用可以阻止系统挂起的特性&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_CHOWN&lt;/td>
&lt;td>修改文件所有者的权限&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_DAC_OVERRIDE&lt;/td>
&lt;td>忽略文件的 DAC 访问限制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_DAC_READ_SEARCH&lt;/td>
&lt;td>忽略文件读及目录搜索的 DAC 访问限制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_FOWNER&lt;/td>
&lt;td>忽略文件属主 ID 必须和进程用户 ID 相匹配的限制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_FSETID&lt;/td>
&lt;td>允许设置文件的 setuid 位&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_IPC_LOCK&lt;/td>
&lt;td>允许锁定共享内存片段&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_IPC_OWNER&lt;/td>
&lt;td>忽略 IPC 所有权检查&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_KILL&lt;/td>
&lt;td>允许对不属于自己的进程发送信号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_LEASE&lt;/td>
&lt;td>允许修改文件锁的 FL_LEASE 标志&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_LINUX_IMMUTABLE&lt;/td>
&lt;td>允许修改文件的 IMMUTABLE 和 APPEND 属性标志&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_MAC_ADMIN&lt;/td>
&lt;td>允许 MAC 配置或状态更改&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_MAC_OVERRIDE&lt;/td>
&lt;td>覆盖 MAC(Mandatory Access Control)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_MKNOD&lt;/td>
&lt;td>允许使用 mknod() 系统调用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_NET_ADMIN&lt;/td>
&lt;td>允许执行网络管理任务&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_NET_BIND_SERVICE&lt;/td>
&lt;td>允许绑定到小于 1024 的端口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_NET_BROADCAST&lt;/td>
&lt;td>允许网络广播和多播访问&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_NET_RAW&lt;/td>
&lt;td>允许使用原始套接字&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SETGID&lt;/td>
&lt;td>允许改变进程的 GID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SETFCAP&lt;/td>
&lt;td>允许为文件设置任意的 capabilities&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SETPCAP&lt;/td>
&lt;td>参考 &lt;a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities man page&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SETUID&lt;/td>
&lt;td>允许改变进程的 UID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_ADMIN&lt;/td>
&lt;td>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_BOOT&lt;/td>
&lt;td>允许重新启动系统&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_CHROOT&lt;/td>
&lt;td>允许使用 chroot() 系统调用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_MODULE&lt;/td>
&lt;td>允许插入和删除内核模块&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_NICE&lt;/td>
&lt;td>允许提升优先级及设置其他进程的优先级&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_PACCT&lt;/td>
&lt;td>允许执行进程的 BSD 式审计&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_PTRACE&lt;/td>
&lt;td>允许跟踪任何进程&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_RAWIO&lt;/td>
&lt;td>允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_RESOURCE&lt;/td>
&lt;td>忽略资源限制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_TIME&lt;/td>
&lt;td>允许改变系统时钟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYS_TTY_CONFIG&lt;/td>
&lt;td>允许配置 TTY 设备&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_SYSLOG&lt;/td>
&lt;td>允许使用 syslog() 系统调用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CAP_WAKE_ALARM&lt;/td>
&lt;td>允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>getcap&lt;/strong> 命令和 &lt;strong>setcap&lt;/strong> 命令分别用来查看和设置程序文件的 capabilities 属性。&lt;/p>
&lt;p>例如&lt;strong>为 ping 命令文件添加 capabilities&lt;/strong>&lt;/p>
&lt;p>执行 ping 命令所需的 capabilities 为 cap_net_admin 和 cap_net_raw，通过 setcap 命令可以添加它们：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ sudo setcap cap_net_admin,cap_net_raw+ep /bin/ping
&lt;/code>&lt;/pre>&lt;/div>&lt;p>移除添加的 capabilities ，执行下面的命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ sudo setcap cap_net_admin,cap_net_raw-ep /bin/ping
&lt;/code>&lt;/pre>&lt;/div>&lt;p>命令中的 ep 分别表示 Effective 和 Permitted 集合(接下来会介绍)，+ 号表示把指定的 capabilities 添加到这些集合中，- 号表示从集合中移除(对于 Effective 来说是设置或者清除位)。&lt;/p>
&lt;h2 id="解决问题">解决问题&lt;/h2>
&lt;p>回到我们开始的问题，由于我们为非 root 用户赋予了使用 80 端口的权限，调用了如下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>setcap &lt;span class="nv">cap_net_bind_service&lt;/span>&lt;span class="o">=&lt;/span>+ep /usr/bin/java
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当一个可执行文件提升了权限后，运行时加载程序（rtld）— ld.so，它不会与不受信任路径中的库链接。Linux 会为使用了 &lt;code>setcap&lt;/code> 或 &lt;code>suid&lt;/code> 的程序禁用掉 &lt;code>LD_LIBRARY_PATH&lt;/code>。所以就出现了 java 程序加载不到 libjli.so 的情况了，这是 JDK 的一个 bug。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="http://bugs.sun.com/view_bug.do?bug_id=7157699">JDK-7157699 : can not run java after granting posix capabilities&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>那么既然使用 setcap 后不会加载链接库，我们就可以将 libjli.so 所在的路径添加到 &lt;code>/etc/ld.so.conf/xxx.conf&lt;/code>中，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>% cat /etc/ld.so.conf.d/java.conf
&lt;span class="ln">2&lt;/span>/usr/java/jdk1.8.0_261-amd64/lib/amd64/jli
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>ldconfig&lt;/code> 重载 so 文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">[&lt;/span>root@localhost jli&lt;span class="o">]&lt;/span>&lt;span class="c1"># ldconfig -p | grep libjli&lt;/span>
&lt;span class="ln">2&lt;/span> libjli.so &lt;span class="o">(&lt;/span>libc6,x86-64&lt;span class="o">)&lt;/span> &lt;span class="o">=&lt;/span>&amp;gt; /usr/java/jdk1.8.0_261-amd64/lib/amd64/jli/libjli.so% ldconfig &lt;span class="p">|&lt;/span> grep libjli
&lt;span class="ln">3&lt;/span>libjli.so -&amp;gt; libjli.so
&lt;span class="ln">4&lt;/span>.......
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样再次测试就可以了。&lt;/p>
&lt;h2 id="参考文章">参考文章&lt;/h2>
&lt;p>【1】&lt;a href="https://www.cnblogs.com/jiqingwu/p/linux_dynamic_lib_create.html">Linux动态库生成与使用指南&lt;/a>&lt;/p>
&lt;p>【2】&lt;a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html#ldd">ldd 查看程序依赖库&lt;/a>&lt;/p>
&lt;p>【3】&lt;a href="https://www.cnblogs.com/sparkdev/p/11417781.html">Linux Capabiliites 简介&lt;/a>&lt;/p>
&lt;p>【4】&lt;a href="https://linux.die.net/man/7/capabilities">capabilities(7) - Linux man page&lt;/a>&lt;/p>
&lt;p>【5】&lt;a href="https://www.boris1993.com/linux/allow-non-root-process-to-bind-low-numbered-ports.html">如何允许非 root 进程绑定低位端口&lt;/a>&lt;/p>
&lt;p>【6】[&lt;a href="https://unix.stackexchange.com/questions/87978/how-to-get-oracle-java-7-to-work-with-setcap-cap-net-bind-serviceep">How to get Oracle java 7 to work with setcap cap_net_bind_service+ep&lt;/a>](&lt;a href="https://unix.stackexchange.com/questions/87978/how-to-get-oracle-java-7-to-work-with-setcap-cap-net-bind-serviceep">https://unix.stackexchange.com/questions/87978/how-to-get-oracle-java-7-to-work-with-setcap-cap-net-bind-serviceep&lt;/a>)&lt;/p></description></item></channel></rss>