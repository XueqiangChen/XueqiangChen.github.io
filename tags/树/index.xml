<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>树 on AhaMoment</title><link>https://ahamoment.cn/tags/%E6%A0%91/</link><description>Recent content in 树 on AhaMoment</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2021</copyright><lastBuildDate>Thu, 15 Apr 2021 10:03:48 +0800</lastBuildDate><atom:link href="https://ahamoment.cn/tags/%E6%A0%91/index.xml" rel="self" type="application/rss+xml"/><item><title>二叉树的中序遍历</title><link>https://ahamoment.cn/posts/algorithm/algorithm-tree-inorder/</link><pubDate>Thu, 15 Apr 2021 10:03:48 +0800</pubDate><guid>https://ahamoment.cn/posts/algorithm/algorithm-tree-inorder/</guid><description>二叉树的遍历方法分为先序遍历，中序遍历，后序遍历以及层序遍历这四种，其中先序，中序以及后序又可以用递归和非递归的方式来实现，层序遍历一般则是用一个队列来实现。关于这几种遍历方式和代码可以参考本博客的之前的一篇文章&amp;mdash;&amp;gt;传送门
这里我们通过一道 leetcode 题目来对二叉树的中序遍历法展开讨论。这道题的描述如下：
leetcode 94 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/] 给定一个二叉树的根节点 root ，返回它的 中序 遍历。 示例1： 1 \ 2 / 3 输入：root = [1,null,2,3] 输出：[1,3,2] 1.</description></item><item><title>堆</title><link>https://ahamoment.cn/posts/algorithm/algorithm-heap/</link><pubDate>Tue, 15 Sep 2020 11:44:06 +0800</pubDate><guid>https://ahamoment.cn/posts/algorithm/algorithm-heap/</guid><description>什么是堆 了解什么是堆之前，我们知道队列的概念，队列的特点是先进先出，但是有一种特殊的队列，取出元素的顺序是按照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序，这就是优先队列(Priority Queue)。
若采用数组或者链表实现优先队列，总会有插入、删除或者查找中的一项操作的复杂度是$O(N)$ 的。
若采用二叉搜索树实现，那么插入和删除都跟树的高度有关，也就是$O(log_2N)$ 的复杂度，但是删除的时候，由于每次都要删除最大的或者最小的，这样操作几次后，会造成搜索树失去平衡，所以不能简单的使用二叉搜索树。
如果采用二叉树结构，我们更关注的应该是删除的操作，那么我们把最大的值放到根结点，左右两边也是最大值作为左右子树的根结点，每次删除只需要删除根结点。同时，为了保证树的平衡性，可以考虑使用完全二叉树来实现优先队列。
优先队列使用完全二叉树表示如上图所示，数组的第 0 个元素空着，后面的按照层序遍历的顺序存放到数组中。使用完全二叉实现的优先队列，也可以称之为堆，堆的特性如下：
结构性：用数组表示的完全二叉树。 有序性：任一结点的关键字是其子树所有结点的最大值（或最小值） &amp;ldquo;最大堆&amp;rdquo;，也称 &amp;ldquo;大顶堆&amp;rdquo;：堆顶元素是整个树的最大值 &amp;ldquo;最小堆&amp;rdquo;，也称&amp;quot;小顶堆&amp;quot;：堆顶元素是整个树的最小值 如下图所示的几个二叉树，不是堆。</description></item><item><title>平衡二叉树</title><link>https://ahamoment.cn/posts/algorithm/algorithm-balanced-binary-tree/</link><pubDate>Mon, 31 Aug 2020 18:11:54 +0800</pubDate><guid>https://ahamoment.cn/posts/algorithm/algorithm-balanced-binary-tree/</guid><description>平衡二叉树 平衡二叉树也是一种搜索树。
搜索树节点不同插入次序，将导致不同的深度和平均查找长度 ASL。
平衡因子（Balance Factor）:BF(T)=hL-hR，其中hL和hR分别是T的左右子树的高度。平衡二叉树（Balanced Binary Tree) 又叫 AVL树，当树不为空时，在任一节点左，右子树高度差的绝对值不超过1，即 |BF(T)|&amp;lt;=1。
平衡二叉树的高度能够达到 $log_2n$
平衡二叉树的调整 任何情况都可以归结为四种模式。根据插入节点的位置不同使用不同的查找方法，同时记住平衡二叉树是搜索树，节点小于左边大于右边。平衡二叉树的四种调整方法为：右单旋，左单旋，右左双旋，左右双旋。
右单旋 按照字母大小插入三个结点，Mar, May, Nov：
如上图左边所示，在插入 Nov 结点后，二叉树的平衡被破坏，结点Mar 的平衡因子为 -2，这个时候我们称 Mar 为不平衡的发现者，麻烦节点 Nov 在发现者右子树的右边，需要RR旋转（右单旋）。</description></item><item><title>二叉搜索树</title><link>https://ahamoment.cn/posts/algorithm/algorithm-binary-search-tree/</link><pubDate>Wed, 19 Aug 2020 17:05:29 +0800</pubDate><guid>https://ahamoment.cn/posts/algorithm/algorithm-binary-search-tree/</guid><description>1. 二叉搜索树的概念 二叉搜索树，也称为二叉排序树或二叉查找树。一棵不为空的二叉搜索树满足以下性质：
非空左子树的所有键值小于其根结点的键值。 非空右子树的所有键值大于其根结点的键值。 左，右子树都是二叉搜索树。 2. 二叉搜索树的查找 从二叉搜索树BST中查找元素X，返回其所在结点的地址。二叉搜索树的查找过程可以描述为以下步骤：
查找从根结点开始，如果树为空，直接返回 null 若查找树非空，则根结点关键字与 X 进行比较，并进行不同的处理。 x 小于根结点的键值，在左子树中搜索； x 大于根结点的键值，在右子树中搜索； 若两者比较的结果相等，搜索完成，直接返回指向结点的指针。 我们用递归来实现查找过程，</description></item><item><title>二叉树及存储结构</title><link>https://ahamoment.cn/posts/algorithm/algorithm-binary-tree/</link><pubDate>Tue, 11 Aug 2020 10:40:08 +0800</pubDate><guid>https://ahamoment.cn/posts/algorithm/algorithm-binary-tree/</guid><description>&lt;p>摘要：二叉树的定义，遍历二叉树&lt;/p></description></item><item><title>树的定义及表示</title><link>https://ahamoment.cn/posts/algorithm/algorithm-tree/</link><pubDate>Tue, 11 Aug 2020 10:31:07 +0800</pubDate><guid>https://ahamoment.cn/posts/algorithm/algorithm-tree/</guid><description>这一部分主要介绍一下数据结构中很重要的一个概念：树。那么什么是树呢？在说明这个概念之前，我们先来看看和它相关的一些内容。
1. 查找 查找是根据某个给定关键字K ，从集合R中找出关键字与K相同的记录。查找又分为静态查找和动态查找，静态查找的集合中记录是固定的，没有插入和删除操作，只有查找，而动态查找的集合中记录是动态变化的，除了查找外，还可能发生插入和删除操作。
1.1 静态查找 方法一：顺序查找 顺序查找就是从数组中一个一个地找，直到找到我们想要的元素为止。
如图所示，在长度为8的数组中查找元素K，如果我们从最后一个元素找起来，查找成功就返回所在单元下表，不成功返回0。查找过程中，在第一个几点建立哨兵，哨兵的作用可以让程序知道什么时候应该停下来，同时可以少些一个判断条件。
public int sequentialSearch(int[] array, int k) { int i; array[0] = k; // 建立哨兵 for (i = array.</description></item></channel></rss>