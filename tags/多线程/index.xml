<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>多线程 - Tag - Aha Moment</title><link>https://ahamoment.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><description>多线程 - Tag - Aha Moment</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xueqiang.chen@foxmail..com (xueqiang.chen)</managingEditor><webMaster>xueqiang.chen@foxmail..com (xueqiang.chen)</webMaster><lastBuildDate>Thu, 12 Nov 2020 10:22:13 +0800</lastBuildDate><atom:link href="https://ahamoment.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="self" type="application/rss+xml"/><item><title>Java 多线程 - 自定义线程池</title><link>https://ahamoment.cn/posts/java/java-multithread-thread-pool/</link><pubDate>Thu, 12 Nov 2020 10:22:13 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-thread-pool/</guid><description>1. 为什么要用线程池？ 池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减</description></item><item><title>Java 多线程 - 线程生命周期</title><link>https://ahamoment.cn/posts/java/java-multithread-thread-lifecycle/</link><pubDate>Wed, 11 Nov 2020 18:23:31 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-thread-lifecycle/</guid><description>线程的生命周期大体可以分为如下6个主要的阶段： NEW RUNNABLE WAITING TIMED_WAITING BLOCKED TERMINATED 从 JDK 的源代码中也能看到关于线程状态的描述： // Thread.State public enum State { /** * Thread state for a thread which has not yet started. */ NEW,</description></item><item><title>Java 多线程面试题总结</title><link>https://ahamoment.cn/posts/java/java-multithread-interview-questions/</link><pubDate>Wed, 11 Nov 2020 10:41:32 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-interview-questions/</guid><description></description></item><item><title>Java 多线程 - 深入理解synchronized关键字</title><link>https://ahamoment.cn/posts/java/java-multithread-synchronized2/</link><pubDate>Sun, 25 Oct 2020 07:20:03 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-synchronized2/</guid><description>synchronized关键字提供了一种互斥机制，也就是说在同一时刻，只能有一个线程访问同步资源，很多资料、书籍将synchronized（</description></item><item><title>Java 多线程 - 线程中断 Interrupt</title><link>https://ahamoment.cn/posts/java/java-multithread-interrupt/</link><pubDate>Sat, 24 Oct 2020 07:17:54 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-interrupt/</guid><description>&lt;p>线程interrupt，是一个非常重要的API，也是经常使用的方法，在本文中我们将Thread深入源码对其进行详细的剖析。&lt;/p></description></item><item><title>Java 多线程 - 死锁问题</title><link>https://ahamoment.cn/posts/java/java-multithread-dead-lock/</link><pubDate>Wed, 10 Jun 2020 19:21:07 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-dead-lock/</guid><description>锁是非常有用的工具，运用场景非常多，因为它使用起来非常方便，而且易于理解。但同时它也会带来一些困扰，那就是可能引起死锁。 1. 什么是死锁 百度百科</description></item><item><title>Java 多线程 - 初识 Synchronized</title><link>https://ahamoment.cn/posts/java/java-multithread-synchronized/</link><pubDate>Wed, 10 Jun 2020 19:16:24 +0800</pubDate><author>xueqiang.chen</author><guid>https://ahamoment.cn/posts/java/java-multithread-synchronized/</guid><description>Synchronized 简介 本文出自汪文君老师的《Java 并发编程》课程，如需转载，请注明源出处！ 先来看一个例子，这个例子是模拟银行叫号的，使用三个线程模拟三个柜</description></item></channel></rss>